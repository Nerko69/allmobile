/*
Copyright (c) 2011, Yahoo! Inc. All rights reserved.
Code licensed under the BSD License:
http://developer.yahoo.com/yui/license.html
version: 2.9.0
*/
if(typeof YAHOO=="undefined"||!YAHOO){var YAHOO={};}YAHOO.namespace=function(){var b=arguments,g=null,e,c,f;for(e=0;e<b.length;e=e+1){f=(""+b[e]).split(".");g=YAHOO;for(c=(f[0]=="YAHOO")?1:0;c<f.length;c=c+1){g[f[c]]=g[f[c]]||{};g=g[f[c]];}}return g;};YAHOO.log=function(d,a,c){var b=YAHOO.widget.Logger;if(b&&b.log){return b.log(d,a,c);}else{return false;}};YAHOO.register=function(a,f,e){var k=YAHOO.env.modules,c,j,h,g,d;if(!k[a]){k[a]={versions:[],builds:[]};}c=k[a];j=e.version;h=e.build;g=YAHOO.env.listeners;c.name=a;c.version=j;c.build=h;c.versions.push(j);c.builds.push(h);c.mainClass=f;for(d=0;d<g.length;d=d+1){g[d](c);}if(f){f.VERSION=j;f.BUILD=h;}else{YAHOO.log("mainClass is undefined for module "+a,"warn");}};YAHOO.env=YAHOO.env||{modules:[],listeners:[]};YAHOO.env.getVersion=function(a){return YAHOO.env.modules[a]||null;};YAHOO.env.parseUA=function(d){var e=function(i){var j=0;return parseFloat(i.replace(/\./g,function(){return(j++==1)?"":".";}));},h=navigator,g={ie:0,opera:0,gecko:0,webkit:0,chrome:0,mobile:null,air:0,ipad:0,iphone:0,ipod:0,ios:null,android:0,webos:0,caja:h&&h.cajaVersion,secure:false,os:null},c=d||(navigator&&navigator.userAgent),f=window&&window.location,b=f&&f.href,a;g.secure=b&&(b.toLowerCase().indexOf("https")===0);if(c){if((/windows|win32/i).test(c)){g.os="windows";}else{if((/macintosh/i).test(c)){g.os="macintosh";}else{if((/rhino/i).test(c)){g.os="rhino";}}}if((/KHTML/).test(c)){g.webkit=1;}a=c.match(/AppleWebKit\/([^\s]*)/);if(a&&a[1]){g.webkit=e(a[1]);if(/ Mobile\//.test(c)){g.mobile="Apple";a=c.match(/OS ([^\s]*)/);if(a&&a[1]){a=e(a[1].replace("_","."));}g.ios=a;g.ipad=g.ipod=g.iphone=0;a=c.match(/iPad|iPod|iPhone/);if(a&&a[0]){g[a[0].toLowerCase()]=g.ios;}}else{a=c.match(/NokiaN[^\/]*|Android \d\.\d|webOS\/\d\.\d/);if(a){g.mobile=a[0];}if(/webOS/.test(c)){g.mobile="WebOS";a=c.match(/webOS\/([^\s]*);/);if(a&&a[1]){g.webos=e(a[1]);}}if(/ Android/.test(c)){g.mobile="Android";a=c.match(/Android ([^\s]*);/);if(a&&a[1]){g.android=e(a[1]);}}}a=c.match(/Chrome\/([^\s]*)/);if(a&&a[1]){g.chrome=e(a[1]);}else{a=c.match(/AdobeAIR\/([^\s]*)/);if(a){g.air=a[0];}}}if(!g.webkit){a=c.match(/Opera[\s\/]([^\s]*)/);if(a&&a[1]){g.opera=e(a[1]);a=c.match(/Version\/([^\s]*)/);if(a&&a[1]){g.opera=e(a[1]);}a=c.match(/Opera Mini[^;]*/);if(a){g.mobile=a[0];}}else{a=c.match(/MSIE\s([^;]*)/);if(a&&a[1]){g.ie=e(a[1]);}else{a=c.match(/Gecko\/([^\s]*)/);if(a){g.gecko=1;a=c.match(/rv:([^\s\)]*)/);if(a&&a[1]){g.gecko=e(a[1]);}}}}}}return g;};YAHOO.env.ua=YAHOO.env.parseUA();(function(){YAHOO.namespace("util","widget","example");if("undefined"!==typeof YAHOO_config){var b=YAHOO_config.listener,a=YAHOO.env.listeners,d=true,c;if(b){for(c=0;c<a.length;c++){if(a[c]==b){d=false;break;}}if(d){a.push(b);}}}})();YAHOO.lang=YAHOO.lang||{};(function(){var f=YAHOO.lang,a=Object.prototype,c="[object Array]",h="[object Function]",i="[object Object]",b=[],g={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#x27;","/":"&#x2F;","`":"&#x60;"},d=["toString","valueOf"],e={isArray:function(j){return a.toString.apply(j)===c;},isBoolean:function(j){return typeof j==="boolean";},isFunction:function(j){return(typeof j==="function")||a.toString.apply(j)===h;},isNull:function(j){return j===null;},isNumber:function(j){return typeof j==="number"&&isFinite(j);},isObject:function(j){return(j&&(typeof j==="object"||f.isFunction(j)))||false;},isString:function(j){return typeof j==="string";},isUndefined:function(j){return typeof j==="undefined";},_IEEnumFix:(YAHOO.env.ua.ie)?function(l,k){var j,n,m;for(j=0;j<d.length;j=j+1){n=d[j];m=k[n];if(f.isFunction(m)&&m!=a[n]){l[n]=m;}}}:function(){},escapeHTML:function(j){return j.replace(/[&<>"'\/`]/g,function(k){return g[k];});},extend:function(m,n,l){if(!n||!m){throw new Error("extend failed, please check that "+"all dependencies are included.");}var k=function(){},j;k.prototype=n.prototype;m.prototype=new k();m.prototype.constructor=m;m.superclass=n.prototype;if(n.prototype.constructor==a.constructor){n.prototype.constructor=n;}if(l){for(j in l){if(f.hasOwnProperty(l,j)){m.prototype[j]=l[j];}}f._IEEnumFix(m.prototype,l);}},augmentObject:function(n,m){if(!m||!n){throw new Error("Absorb failed, verify dependencies.");}var j=arguments,l,o,k=j[2];if(k&&k!==true){for(l=2;l<j.length;l=l+1){n[j[l]]=m[j[l]];}}else{for(o in m){if(k||!(o in n)){n[o]=m[o];}}f._IEEnumFix(n,m);}return n;},augmentProto:function(m,l){if(!l||!m){throw new Error("Augment failed, verify dependencies.");}var j=[m.prototype,l.prototype],k;for(k=2;k<arguments.length;k=k+1){j.push(arguments[k]);}f.augmentObject.apply(this,j);return m;},dump:function(j,p){var l,n,r=[],t="{...}",k="f(){...}",q=", ",m=" => ";if(!f.isObject(j)){return j+"";}else{if(j instanceof Date||("nodeType" in j&&"tagName" in j)){return j;}else{if(f.isFunction(j)){return k;}}}p=(f.isNumber(p))?p:3;if(f.isArray(j)){r.push("[");for(l=0,n=j.length;l<n;l=l+1){if(f.isObject(j[l])){r.push((p>0)?f.dump(j[l],p-1):t);}else{r.push(j[l]);}r.push(q);}if(r.length>1){r.pop();}r.push("]");}else{r.push("{");for(l in j){if(f.hasOwnProperty(j,l)){r.push(l+m);if(f.isObject(j[l])){r.push((p>0)?f.dump(j[l],p-1):t);}else{r.push(j[l]);}r.push(q);}}if(r.length>1){r.pop();}r.push("}");}return r.join("");},substitute:function(x,y,E,l){var D,C,B,G,t,u,F=[],p,z=x.length,A="dump",r=" ",q="{",m="}",n,w;for(;;){D=x.lastIndexOf(q,z);if(D<0){break;}C=x.indexOf(m,D);if(D+1>C){break;}p=x.substring(D+1,C);G=p;u=null;B=G.indexOf(r);if(B>-1){u=G.substring(B+1);G=G.substring(0,B);}t=y[G];if(E){t=E(G,t,u);}if(f.isObject(t)){if(f.isArray(t)){t=f.dump(t,parseInt(u,10));}else{u=u||"";n=u.indexOf(A);if(n>-1){u=u.substring(4);}w=t.toString();if(w===i||n>-1){t=f.dump(t,parseInt(u,10));}else{t=w;}}}else{if(!f.isString(t)&&!f.isNumber(t)){t="~-"+F.length+"-~";F[F.length]=p;}}x=x.substring(0,D)+t+x.substring(C+1);if(l===false){z=D-1;}}for(D=F.length-1;D>=0;D=D-1){x=x.replace(new RegExp("~-"+D+"-~"),"{"+F[D]+"}","g");}return x;},trim:function(j){try{return j.replace(/^\s+|\s+$/g,"");}catch(k){return j;
}},merge:function(){var n={},k=arguments,j=k.length,m;for(m=0;m<j;m=m+1){f.augmentObject(n,k[m],true);}return n;},later:function(t,k,u,n,p){t=t||0;k=k||{};var l=u,s=n,q,j;if(f.isString(u)){l=k[u];}if(!l){throw new TypeError("method undefined");}if(!f.isUndefined(n)&&!f.isArray(s)){s=[n];}q=function(){l.apply(k,s||b);};j=(p)?setInterval(q,t):setTimeout(q,t);return{interval:p,cancel:function(){if(this.interval){clearInterval(j);}else{clearTimeout(j);}}};},isValue:function(j){return(f.isObject(j)||f.isString(j)||f.isNumber(j)||f.isBoolean(j));}};f.hasOwnProperty=(a.hasOwnProperty)?function(j,k){return j&&j.hasOwnProperty&&j.hasOwnProperty(k);}:function(j,k){return !f.isUndefined(j[k])&&j.constructor.prototype[k]!==j[k];};e.augmentObject(f,e,true);YAHOO.util.Lang=f;f.augment=f.augmentProto;YAHOO.augment=f.augmentProto;YAHOO.extend=f.extend;})();YAHOO.register("yahoo",YAHOO,{version:"2.9.0",build:"2800"});(function(){YAHOO.env._id_counter=YAHOO.env._id_counter||0;var e=YAHOO.util,k=YAHOO.lang,L=YAHOO.env.ua,a=YAHOO.lang.trim,B={},F={},m=/^t(?:able|d|h)$/i,w=/color$/i,j=window.document,v=j.documentElement,C="ownerDocument",M="defaultView",U="documentElement",S="compatMode",z="offsetLeft",o="offsetTop",T="offsetParent",x="parentNode",K="nodeType",c="tagName",n="scrollLeft",H="scrollTop",p="getBoundingClientRect",V="getComputedStyle",y="currentStyle",l="CSS1Compat",A="BackCompat",E="class",f="className",i="",b=" ",R="(?:^|\\s)",J="(?= |$)",t="g",O="position",D="fixed",u="relative",I="left",N="top",Q="medium",P="borderLeftWidth",q="borderTopWidth",d=L.opera,h=L.webkit,g=L.gecko,s=L.ie;e.Dom={CUSTOM_ATTRIBUTES:(!v.hasAttribute)?{"for":"htmlFor","class":f}:{"htmlFor":"for","className":E},DOT_ATTRIBUTES:{checked:true},get:function(aa){var ac,X,ab,Z,W,G,Y=null;if(aa){if(typeof aa=="string"||typeof aa=="number"){ac=aa+"";aa=j.getElementById(aa);G=(aa)?aa.attributes:null;if(aa&&G&&G.id&&G.id.value===ac){return aa;}else{if(aa&&j.all){aa=null;X=j.all[ac];if(X&&X.length){for(Z=0,W=X.length;Z<W;++Z){if(X[Z].id===ac){return X[Z];}}}}}}else{if(e.Element&&aa instanceof e.Element){aa=aa.get("element");}else{if(!aa.nodeType&&"length" in aa){ab=[];for(Z=0,W=aa.length;Z<W;++Z){ab[ab.length]=e.Dom.get(aa[Z]);}aa=ab;}}}Y=aa;}return Y;},getComputedStyle:function(G,W){if(window[V]){return G[C][M][V](G,null)[W];}else{if(G[y]){return e.Dom.IE_ComputedStyle.get(G,W);}}},getStyle:function(G,W){return e.Dom.batch(G,e.Dom._getStyle,W);},_getStyle:function(){if(window[V]){return function(G,Y){Y=(Y==="float")?Y="cssFloat":e.Dom._toCamel(Y);var X=G.style[Y],W;if(!X){W=G[C][M][V](G,null);if(W){X=W[Y];}}return X;};}else{if(v[y]){return function(G,Y){var X;switch(Y){case"opacity":X=100;try{X=G.filters["DXImageTransform.Microsoft.Alpha"].opacity;}catch(Z){try{X=G.filters("alpha").opacity;}catch(W){}}return X/100;case"float":Y="styleFloat";default:Y=e.Dom._toCamel(Y);X=G[y]?G[y][Y]:null;return(G.style[Y]||X);}};}}}(),setStyle:function(G,W,X){e.Dom.batch(G,e.Dom._setStyle,{prop:W,val:X});},_setStyle:function(){if(!window.getComputedStyle&&j.documentElement.currentStyle){return function(W,G){var X=e.Dom._toCamel(G.prop),Y=G.val;if(W){switch(X){case"opacity":if(Y===""||Y===null||Y===1){W.style.removeAttribute("filter");}else{if(k.isString(W.style.filter)){W.style.filter="alpha(opacity="+Y*100+")";if(!W[y]||!W[y].hasLayout){W.style.zoom=1;}}}break;case"float":X="styleFloat";default:W.style[X]=Y;}}else{}};}else{return function(W,G){var X=e.Dom._toCamel(G.prop),Y=G.val;if(W){if(X=="float"){X="cssFloat";}W.style[X]=Y;}else{}};}}(),getXY:function(G){return e.Dom.batch(G,e.Dom._getXY);},_canPosition:function(G){return(e.Dom._getStyle(G,"display")!=="none"&&e.Dom._inDoc(G));},_getXY:function(W){var X,G,Z,ab,Y,aa,ac=Math.round,ad=false;if(e.Dom._canPosition(W)){Z=W[p]();ab=W[C];X=e.Dom.getDocumentScrollLeft(ab);G=e.Dom.getDocumentScrollTop(ab);ad=[Z[I],Z[N]];if(Y||aa){ad[0]-=aa;ad[1]-=Y;}if((G||X)){ad[0]+=X;ad[1]+=G;}ad[0]=ac(ad[0]);ad[1]=ac(ad[1]);}else{}return ad;},getX:function(G){var W=function(X){return e.Dom.getXY(X)[0];};return e.Dom.batch(G,W,e.Dom,true);},getY:function(G){var W=function(X){return e.Dom.getXY(X)[1];};return e.Dom.batch(G,W,e.Dom,true);},setXY:function(G,X,W){e.Dom.batch(G,e.Dom._setXY,{pos:X,noRetry:W});},_setXY:function(G,Z){var aa=e.Dom._getStyle(G,O),Y=e.Dom.setStyle,ad=Z.pos,W=Z.noRetry,ab=[parseInt(e.Dom.getComputedStyle(G,I),10),parseInt(e.Dom.getComputedStyle(G,N),10)],ac,X;ac=e.Dom._getXY(G);if(!ad||ac===false){return false;}if(aa=="static"){aa=u;Y(G,O,aa);}if(isNaN(ab[0])){ab[0]=(aa==u)?0:G[z];}if(isNaN(ab[1])){ab[1]=(aa==u)?0:G[o];}if(ad[0]!==null){Y(G,I,ad[0]-ac[0]+ab[0]+"px");}if(ad[1]!==null){Y(G,N,ad[1]-ac[1]+ab[1]+"px");}if(!W){X=e.Dom._getXY(G);if((ad[0]!==null&&X[0]!=ad[0])||(ad[1]!==null&&X[1]!=ad[1])){e.Dom._setXY(G,{pos:ad,noRetry:true});}}},setX:function(W,G){e.Dom.setXY(W,[G,null]);},setY:function(G,W){e.Dom.setXY(G,[null,W]);},getRegion:function(G){var W=function(X){var Y=false;if(e.Dom._canPosition(X)){Y=e.Region.getRegion(X);}else{}return Y;};return e.Dom.batch(G,W,e.Dom,true);},getClientWidth:function(){return e.Dom.getViewportWidth();},getClientHeight:function(){return e.Dom.getViewportHeight();},getElementsByClassName:function(ab,af,ac,ae,X,ad){af=af||"*";ac=(ac)?e.Dom.get(ac):null||j;if(!ac){return[];}var W=[],G=ac.getElementsByTagName(af),Z=e.Dom.hasClass;for(var Y=0,aa=G.length;Y<aa;++Y){if(Z(G[Y],ab)){W[W.length]=G[Y];}}if(ae){e.Dom.batch(W,ae,X,ad);}return W;},hasClass:function(W,G){return e.Dom.batch(W,e.Dom._hasClass,G);},_hasClass:function(X,W){var G=false,Y;if(X&&W){Y=e.Dom._getAttribute(X,f)||i;if(Y){Y=Y.replace(/\s+/g,b);}if(W.exec){G=W.test(Y);}else{G=W&&(b+Y+b).indexOf(b+W+b)>-1;}}else{}return G;},addClass:function(W,G){return e.Dom.batch(W,e.Dom._addClass,G);},_addClass:function(X,W){var G=false,Y;if(X&&W){Y=e.Dom._getAttribute(X,f)||i;if(!e.Dom._hasClass(X,W)){e.Dom.setAttribute(X,f,a(Y+b+W));G=true;}}else{}return G;},removeClass:function(W,G){return e.Dom.batch(W,e.Dom._removeClass,G);},_removeClass:function(Y,X){var W=false,aa,Z,G;if(Y&&X){aa=e.Dom._getAttribute(Y,f)||i;e.Dom.setAttribute(Y,f,aa.replace(e.Dom._getClassRegex(X),i));Z=e.Dom._getAttribute(Y,f);if(aa!==Z){e.Dom.setAttribute(Y,f,a(Z));W=true;if(e.Dom._getAttribute(Y,f)===""){G=(Y.hasAttribute&&Y.hasAttribute(E))?E:f;Y.removeAttribute(G);}}}else{}return W;},replaceClass:function(X,W,G){return e.Dom.batch(X,e.Dom._replaceClass,{from:W,to:G});},_replaceClass:function(Y,X){var W,ab,aa,G=false,Z;if(Y&&X){ab=X.from;aa=X.to;if(!aa){G=false;}else{if(!ab){G=e.Dom._addClass(Y,X.to);}else{if(ab!==aa){Z=e.Dom._getAttribute(Y,f)||i;W=(b+Z.replace(e.Dom._getClassRegex(ab),b+aa).replace(/\s+/g,b)).split(e.Dom._getClassRegex(aa));W.splice(1,0,b+aa);e.Dom.setAttribute(Y,f,a(W.join(i)));G=true;}}}}else{}return G;},generateId:function(G,X){X=X||"yui-gen";var W=function(Y){if(Y&&Y.id){return Y.id;}var Z=X+YAHOO.env._id_counter++;
if(Y){if(Y[C]&&Y[C].getElementById(Z)){return e.Dom.generateId(Y,Z+X);}Y.id=Z;}return Z;};return e.Dom.batch(G,W,e.Dom,true)||W.apply(e.Dom,arguments);},isAncestor:function(W,X){W=e.Dom.get(W);X=e.Dom.get(X);var G=false;if((W&&X)&&(W[K]&&X[K])){if(W.contains&&W!==X){G=W.contains(X);}else{if(W.compareDocumentPosition){G=!!(W.compareDocumentPosition(X)&16);}}}else{}return G;},inDocument:function(G,W){return e.Dom._inDoc(e.Dom.get(G),W);},_inDoc:function(W,X){var G=false;if(W&&W[c]){X=X||W[C];G=e.Dom.isAncestor(X[U],W);}else{}return G;},getElementsBy:function(W,af,ab,ad,X,ac,ae){af=af||"*";ab=(ab)?e.Dom.get(ab):null||j;var aa=(ae)?null:[],G;if(ab){G=ab.getElementsByTagName(af);for(var Y=0,Z=G.length;Y<Z;++Y){if(W(G[Y])){if(ae){aa=G[Y];break;}else{aa[aa.length]=G[Y];}}}if(ad){e.Dom.batch(aa,ad,X,ac);}}return aa;},getElementBy:function(X,G,W){return e.Dom.getElementsBy(X,G,W,null,null,null,true);},batch:function(X,ab,aa,Z){var Y=[],W=(Z)?aa:null;X=(X&&(X[c]||X.item))?X:e.Dom.get(X);if(X&&ab){if(X[c]||X.length===undefined){return ab.call(W,X,aa);}for(var G=0;G<X.length;++G){Y[Y.length]=ab.call(W||X[G],X[G],aa);}}else{return false;}return Y;},getDocumentHeight:function(){var W=(j[S]!=l||h)?j.body.scrollHeight:v.scrollHeight,G=Math.max(W,e.Dom.getViewportHeight());return G;},getDocumentWidth:function(){var W=(j[S]!=l||h)?j.body.scrollWidth:v.scrollWidth,G=Math.max(W,e.Dom.getViewportWidth());return G;},getViewportHeight:function(){var G=self.innerHeight,W=j[S];if((W||s)&&!d){G=(W==l)?v.clientHeight:j.body.clientHeight;}return G;},getViewportWidth:function(){var G=self.innerWidth,W=j[S];if(W||s){G=(W==l)?v.clientWidth:j.body.clientWidth;}return G;},getAncestorBy:function(G,W){while((G=G[x])){if(e.Dom._testElement(G,W)){return G;}}return null;},getAncestorByClassName:function(W,G){W=e.Dom.get(W);if(!W){return null;}var X=function(Y){return e.Dom.hasClass(Y,G);};return e.Dom.getAncestorBy(W,X);},getAncestorByTagName:function(W,G){W=e.Dom.get(W);if(!W){return null;}var X=function(Y){return Y[c]&&Y[c].toUpperCase()==G.toUpperCase();};return e.Dom.getAncestorBy(W,X);},getPreviousSiblingBy:function(G,W){while(G){G=G.previousSibling;if(e.Dom._testElement(G,W)){return G;}}return null;},getPreviousSibling:function(G){G=e.Dom.get(G);if(!G){return null;}return e.Dom.getPreviousSiblingBy(G);},getNextSiblingBy:function(G,W){while(G){G=G.nextSibling;if(e.Dom._testElement(G,W)){return G;}}return null;},getNextSibling:function(G){G=e.Dom.get(G);if(!G){return null;}return e.Dom.getNextSiblingBy(G);},getFirstChildBy:function(G,X){var W=(e.Dom._testElement(G.firstChild,X))?G.firstChild:null;return W||e.Dom.getNextSiblingBy(G.firstChild,X);},getFirstChild:function(G,W){G=e.Dom.get(G);if(!G){return null;}return e.Dom.getFirstChildBy(G);},getLastChildBy:function(G,X){if(!G){return null;}var W=(e.Dom._testElement(G.lastChild,X))?G.lastChild:null;return W||e.Dom.getPreviousSiblingBy(G.lastChild,X);},getLastChild:function(G){G=e.Dom.get(G);return e.Dom.getLastChildBy(G);},getChildrenBy:function(W,Y){var X=e.Dom.getFirstChildBy(W,Y),G=X?[X]:[];e.Dom.getNextSiblingBy(X,function(Z){if(!Y||Y(Z)){G[G.length]=Z;}return false;});return G;},getChildren:function(G){G=e.Dom.get(G);if(!G){}return e.Dom.getChildrenBy(G);},getDocumentScrollLeft:function(G){G=G||j;return Math.max(G[U].scrollLeft,G.body.scrollLeft);},getDocumentScrollTop:function(G){G=G||j;return Math.max(G[U].scrollTop,G.body.scrollTop);},insertBefore:function(W,G){W=e.Dom.get(W);G=e.Dom.get(G);if(!W||!G||!G[x]){return null;}return G[x].insertBefore(W,G);},insertAfter:function(W,G){W=e.Dom.get(W);G=e.Dom.get(G);if(!W||!G||!G[x]){return null;}if(G.nextSibling){return G[x].insertBefore(W,G.nextSibling);}else{return G[x].appendChild(W);}},getClientRegion:function(){var X=e.Dom.getDocumentScrollTop(),W=e.Dom.getDocumentScrollLeft(),Y=e.Dom.getViewportWidth()+W,G=e.Dom.getViewportHeight()+X;return new e.Region(X,Y,G,W);},setAttribute:function(W,G,X){e.Dom.batch(W,e.Dom._setAttribute,{attr:G,val:X});},_setAttribute:function(X,W){var G=e.Dom._toCamel(W.attr),Y=W.val;if(X&&X.setAttribute){if(e.Dom.DOT_ATTRIBUTES[G]&&X.tagName&&X.tagName!="BUTTON"){X[G]=Y;}else{G=e.Dom.CUSTOM_ATTRIBUTES[G]||G;X.setAttribute(G,Y);}}else{}},getAttribute:function(W,G){return e.Dom.batch(W,e.Dom._getAttribute,G);},_getAttribute:function(W,G){var X;G=e.Dom.CUSTOM_ATTRIBUTES[G]||G;if(e.Dom.DOT_ATTRIBUTES[G]){X=W[G];}else{if(W&&"getAttribute" in W){if(/^(?:href|src)$/.test(G)){X=W.getAttribute(G,2);}else{X=W.getAttribute(G);}}else{}}return X;},_toCamel:function(W){var X=B;function G(Y,Z){return Z.toUpperCase();}return X[W]||(X[W]=W.indexOf("-")===-1?W:W.replace(/-([a-z])/gi,G));},_getClassRegex:function(W){var G;if(W!==undefined){if(W.exec){G=W;}else{G=F[W];if(!G){W=W.replace(e.Dom._patterns.CLASS_RE_TOKENS,"\\$1");W=W.replace(/\s+/g,b);G=F[W]=new RegExp(R+W+J,t);}}}return G;},_patterns:{ROOT_TAG:/^body|html$/i,CLASS_RE_TOKENS:/([\.\(\)\^\$\*\+\?\|\[\]\{\}\\])/g},_testElement:function(G,W){return G&&G[K]==1&&(!W||W(G));},_calcBorders:function(X,Y){var W=parseInt(e.Dom[V](X,q),10)||0,G=parseInt(e.Dom[V](X,P),10)||0;if(g){if(m.test(X[c])){W=0;G=0;}}Y[0]+=G;Y[1]+=W;return Y;}};var r=e.Dom[V];if(L.opera){e.Dom[V]=function(W,G){var X=r(W,G);if(w.test(G)){X=e.Dom.Color.toRGB(X);}return X;};}if(L.webkit){e.Dom[V]=function(W,G){var X=r(W,G);if(X==="rgba(0, 0, 0, 0)"){X="transparent";}return X;};}if(L.ie&&L.ie>=8){e.Dom.DOT_ATTRIBUTES.type=true;}})();YAHOO.util.Region=function(d,e,a,c){this.top=d;this.y=d;this[1]=d;this.right=e;this.bottom=a;this.left=c;this.x=c;this[0]=c;this.width=this.right-this.left;this.height=this.bottom-this.top;};YAHOO.util.Region.prototype.contains=function(a){return(a.left>=this.left&&a.right<=this.right&&a.top>=this.top&&a.bottom<=this.bottom);};YAHOO.util.Region.prototype.getArea=function(){return((this.bottom-this.top)*(this.right-this.left));};YAHOO.util.Region.prototype.intersect=function(f){var d=Math.max(this.top,f.top),e=Math.min(this.right,f.right),a=Math.min(this.bottom,f.bottom),c=Math.max(this.left,f.left);
if(a>=d&&e>=c){return new YAHOO.util.Region(d,e,a,c);}else{return null;}};YAHOO.util.Region.prototype.union=function(f){var d=Math.min(this.top,f.top),e=Math.max(this.right,f.right),a=Math.max(this.bottom,f.bottom),c=Math.min(this.left,f.left);return new YAHOO.util.Region(d,e,a,c);};YAHOO.util.Region.prototype.toString=function(){return("Region {"+"top: "+this.top+", right: "+this.right+", bottom: "+this.bottom+", left: "+this.left+", height: "+this.height+", width: "+this.width+"}");};YAHOO.util.Region.getRegion=function(e){var g=YAHOO.util.Dom.getXY(e),d=g[1],f=g[0]+e.offsetWidth,a=g[1]+e.offsetHeight,c=g[0];return new YAHOO.util.Region(d,f,a,c);};YAHOO.util.Point=function(a,b){if(YAHOO.lang.isArray(a)){b=a[1];a=a[0];}YAHOO.util.Point.superclass.constructor.call(this,b,a,b,a);};YAHOO.extend(YAHOO.util.Point,YAHOO.util.Region);(function(){var b=YAHOO.util,a="clientTop",f="clientLeft",j="parentNode",k="right",w="hasLayout",i="px",u="opacity",l="auto",d="borderLeftWidth",g="borderTopWidth",p="borderRightWidth",v="borderBottomWidth",s="visible",q="transparent",n="height",e="width",h="style",t="currentStyle",r=/^width|height$/,o=/^(\d[.\d]*)+(em|ex|px|gd|rem|vw|vh|vm|ch|mm|cm|in|pt|pc|deg|rad|ms|s|hz|khz|%){1}?/i,m={get:function(x,z){var y="",A=x[t][z];if(z===u){y=b.Dom.getStyle(x,u);}else{if(!A||(A.indexOf&&A.indexOf(i)>-1)){y=A;}else{if(b.Dom.IE_COMPUTED[z]){y=b.Dom.IE_COMPUTED[z](x,z);}else{if(o.test(A)){y=b.Dom.IE.ComputedStyle.getPixel(x,z);}else{y=A;}}}}return y;},getOffset:function(z,E){var B=z[t][E],x=E.charAt(0).toUpperCase()+E.substr(1),C="offset"+x,y="pixel"+x,A="",D;if(B==l){D=z[C];if(D===undefined){A=0;}A=D;if(r.test(E)){z[h][E]=D;if(z[C]>D){A=D-(z[C]-D);}z[h][E]=l;}}else{if(!z[h][y]&&!z[h][E]){z[h][E]=B;}A=z[h][y];}return A+i;},getBorderWidth:function(x,z){var y=null;if(!x[t][w]){x[h].zoom=1;}switch(z){case g:y=x[a];break;case v:y=x.offsetHeight-x.clientHeight-x[a];break;case d:y=x[f];break;case p:y=x.offsetWidth-x.clientWidth-x[f];break;}return y+i;},getPixel:function(y,x){var A=null,B=y[t][k],z=y[t][x];y[h][k]=z;A=y[h].pixelRight;y[h][k]=B;return A+i;},getMargin:function(y,x){var z;if(y[t][x]==l){z=0+i;}else{z=b.Dom.IE.ComputedStyle.getPixel(y,x);}return z;},getVisibility:function(y,x){var z;while((z=y[t])&&z[x]=="inherit"){y=y[j];}return(z)?z[x]:s;},getColor:function(y,x){return b.Dom.Color.toRGB(y[t][x])||q;},getBorderColor:function(y,x){var z=y[t],A=z[x]||z.color;return b.Dom.Color.toRGB(b.Dom.Color.toHex(A));}},c={};c.top=c.right=c.bottom=c.left=c[e]=c[n]=m.getOffset;c.color=m.getColor;c[g]=c[p]=c[v]=c[d]=m.getBorderWidth;c.marginTop=c.marginRight=c.marginBottom=c.marginLeft=m.getMargin;c.visibility=m.getVisibility;c.borderColor=c.borderTopColor=c.borderRightColor=c.borderBottomColor=c.borderLeftColor=m.getBorderColor;b.Dom.IE_COMPUTED=c;b.Dom.IE_ComputedStyle=m;})();(function(){var c="toString",a=parseInt,b=RegExp,d=YAHOO.util;d.Dom.Color={KEYWORDS:{black:"000",silver:"c0c0c0",gray:"808080",white:"fff",maroon:"800000",red:"f00",purple:"800080",fuchsia:"f0f",green:"008000",lime:"0f0",olive:"808000",yellow:"ff0",navy:"000080",blue:"00f",teal:"008080",aqua:"0ff"},re_RGB:/^rgb\(([0-9]+)\s*,\s*([0-9]+)\s*,\s*([0-9]+)\)$/i,re_hex:/^#?([0-9A-F]{2})([0-9A-F]{2})([0-9A-F]{2})$/i,re_hex3:/([0-9A-F])/gi,toRGB:function(e){if(!d.Dom.Color.re_RGB.test(e)){e=d.Dom.Color.toHex(e);}if(d.Dom.Color.re_hex.exec(e)){e="rgb("+[a(b.$1,16),a(b.$2,16),a(b.$3,16)].join(", ")+")";}return e;},toHex:function(f){f=d.Dom.Color.KEYWORDS[f]||f;if(d.Dom.Color.re_RGB.exec(f)){f=[Number(b.$1).toString(16),Number(b.$2).toString(16),Number(b.$3).toString(16)];for(var e=0;e<f.length;e++){if(f[e].length<2){f[e]="0"+f[e];}}f=f.join("");}if(f.length<6){f=f.replace(d.Dom.Color.re_hex3,"$1$1");}if(f!=="transparent"&&f.indexOf("#")<0){f="#"+f;}return f.toUpperCase();}};}());YAHOO.register("dom",YAHOO.util.Dom,{version:"2.9.0",build:"2800"});YAHOO.util.CustomEvent=function(d,c,b,a,e){this.type=d;this.scope=c||window;this.silent=b;this.fireOnce=e;this.fired=false;this.firedWith=null;this.signature=a||YAHOO.util.CustomEvent.LIST;this.subscribers=[];if(!this.silent){}var f="_YUICEOnSubscribe";if(d!==f){this.subscribeEvent=new YAHOO.util.CustomEvent(f,this,true);}this.lastError=null;};YAHOO.util.CustomEvent.LIST=0;YAHOO.util.CustomEvent.FLAT=1;YAHOO.util.CustomEvent.prototype={subscribe:function(b,c,d){if(!b){throw new Error("Invalid callback for subscriber to '"+this.type+"'");}if(this.subscribeEvent){this.subscribeEvent.fire(b,c,d);}var a=new YAHOO.util.Subscriber(b,c,d);if(this.fireOnce&&this.fired){this.notify(a,this.firedWith);}else{this.subscribers.push(a);}},unsubscribe:function(d,f){if(!d){return this.unsubscribeAll();}var e=false;for(var b=0,a=this.subscribers.length;b<a;++b){var c=this.subscribers[b];if(c&&c.contains(d,f)){this._delete(b);e=true;}}return e;},fire:function(){this.lastError=null;var h=[],a=this.subscribers.length;var d=[].slice.call(arguments,0),c=true,f,b=false;if(this.fireOnce){if(this.fired){return true;}else{this.firedWith=d;}}this.fired=true;if(!a&&this.silent){return true;}if(!this.silent){}var e=this.subscribers.slice();for(f=0;f<a;++f){var g=e[f];if(!g||!g.fn){b=true;}else{c=this.notify(g,d);if(false===c){if(!this.silent){}break;}}}return(c!==false);},notify:function(g,c){var b,i=null,f=g.getScope(this.scope),a=YAHOO.util.Event.throwErrors;if(!this.silent){}if(this.signature==YAHOO.util.CustomEvent.FLAT){if(c.length>0){i=c[0];}try{b=g.fn.call(f,i,g.obj);}catch(h){this.lastError=h;if(a){throw h;}}}else{try{b=g.fn.call(f,this.type,c,g.obj);}catch(d){this.lastError=d;if(a){throw d;}}}return b;},unsubscribeAll:function(){var a=this.subscribers.length,b;for(b=a-1;b>-1;b--){this._delete(b);}this.subscribers=[];return a;},_delete:function(a){var b=this.subscribers[a];if(b){delete b.fn;delete b.obj;}this.subscribers.splice(a,1);},toString:function(){return"CustomEvent: "+"'"+this.type+"', "+"context: "+this.scope;}};YAHOO.util.Subscriber=function(a,b,c){this.fn=a;this.obj=YAHOO.lang.isUndefined(b)?null:b;this.overrideContext=c;};YAHOO.util.Subscriber.prototype.getScope=function(a){if(this.overrideContext){if(this.overrideContext===true){return this.obj;}else{return this.overrideContext;}}return a;};YAHOO.util.Subscriber.prototype.contains=function(a,b){if(b){return(this.fn==a&&this.obj==b);}else{return(this.fn==a);}};YAHOO.util.Subscriber.prototype.toString=function(){return"Subscriber { obj: "+this.obj+", overrideContext: "+(this.overrideContext||"no")+" }";};if(!YAHOO.util.Event){YAHOO.util.Event=function(){var g=false,h=[],j=[],a=0,e=[],b=0,c={63232:38,63233:40,63234:37,63235:39,63276:33,63277:34,25:9},d=YAHOO.env.ua.ie,f="focusin",i="focusout";return{POLL_RETRYS:500,POLL_INTERVAL:40,EL:0,TYPE:1,FN:2,WFN:3,UNLOAD_OBJ:3,ADJ_SCOPE:4,OBJ:5,OVERRIDE:6,CAPTURE:7,lastError:null,isSafari:YAHOO.env.ua.webkit,webkit:YAHOO.env.ua.webkit,isIE:d,_interval:null,_dri:null,_specialTypes:{focusin:(d?"focusin":"focus"),focusout:(d?"focusout":"blur")},DOMReady:false,throwErrors:false,startInterval:function(){if(!this._interval){this._interval=YAHOO.lang.later(this.POLL_INTERVAL,this,this._tryPreloadAttach,null,true);}},onAvailable:function(q,m,o,p,n){var k=(YAHOO.lang.isString(q))?[q]:q;for(var l=0;l<k.length;l=l+1){e.push({id:k[l],fn:m,obj:o,overrideContext:p,checkReady:n});}a=this.POLL_RETRYS;this.startInterval();},onContentReady:function(n,k,l,m){this.onAvailable(n,k,l,m,true);},onDOMReady:function(){this.DOMReadyEvent.subscribe.apply(this.DOMReadyEvent,arguments);},_addListener:function(m,k,v,p,t,y){if(!v||!v.call){return false;}if(this._isValidCollection(m)){var w=true;for(var q=0,s=m.length;q<s;++q){w=this.on(m[q],k,v,p,t)&&w;}return w;}else{if(YAHOO.lang.isString(m)){var o=this.getEl(m);if(o){m=o;}else{this.onAvailable(m,function(){YAHOO.util.Event._addListener(m,k,v,p,t,y);});return true;}}}if(!m){return false;}if("unload"==k&&p!==this){j[j.length]=[m,k,v,p,t];return true;}var l=m;if(t){if(t===true){l=p;}else{l=t;}}var n=function(z){return v.call(l,YAHOO.util.Event.getEvent(z,m),p);};var x=[m,k,v,n,l,p,t,y];var r=h.length;h[r]=x;try{this._simpleAdd(m,k,n,y);}catch(u){this.lastError=u;this.removeListener(m,k,v);return false;}return true;},_getType:function(k){return this._specialTypes[k]||k;},addListener:function(m,p,l,n,o){var k=((p==f||p==i)&&!YAHOO.env.ua.ie)?true:false;return this._addListener(m,this._getType(p),l,n,o,k);},addFocusListener:function(l,k,m,n){return this.on(l,f,k,m,n);},removeFocusListener:function(l,k){return this.removeListener(l,f,k);},addBlurListener:function(l,k,m,n){return this.on(l,i,k,m,n);},removeBlurListener:function(l,k){return this.removeListener(l,i,k);},removeListener:function(l,k,r){var m,p,u;k=this._getType(k);if(typeof l=="string"){l=this.getEl(l);}else{if(this._isValidCollection(l)){var s=true;for(m=l.length-1;m>-1;m--){s=(this.removeListener(l[m],k,r)&&s);}return s;}}if(!r||!r.call){return this.purgeElement(l,false,k);}if("unload"==k){for(m=j.length-1;m>-1;m--){u=j[m];if(u&&u[0]==l&&u[1]==k&&u[2]==r){j.splice(m,1);return true;}}return false;}var n=null;var o=arguments[3];if("undefined"===typeof o){o=this._getCacheIndex(h,l,k,r);}if(o>=0){n=h[o];}if(!l||!n){return false;}var t=n[this.CAPTURE]===true?true:false;try{this._simpleRemove(l,k,n[this.WFN],t);}catch(q){this.lastError=q;return false;}delete h[o][this.WFN];delete h[o][this.FN];h.splice(o,1);return true;},getTarget:function(m,l){var k=m.target||m.srcElement;return this.resolveTextNode(k);},resolveTextNode:function(l){try{if(l&&3==l.nodeType){return l.parentNode;}}catch(k){return null;}return l;},getPageX:function(l){var k=l.pageX;if(!k&&0!==k){k=l.clientX||0;if(this.isIE){k+=this._getScrollLeft();}}return k;},getPageY:function(k){var l=k.pageY;if(!l&&0!==l){l=k.clientY||0;if(this.isIE){l+=this._getScrollTop();}}return l;},getXY:function(k){return[this.getPageX(k),this.getPageY(k)];},getRelatedTarget:function(l){var k=l.relatedTarget;
if(!k){if(l.type=="mouseout"){k=l.toElement;}else{if(l.type=="mouseover"){k=l.fromElement;}}}return this.resolveTextNode(k);},getTime:function(m){if(!m.time){var l=new Date().getTime();try{m.time=l;}catch(k){this.lastError=k;return l;}}return m.time;},stopEvent:function(k){this.stopPropagation(k);this.preventDefault(k);},stopPropagation:function(k){if(k.stopPropagation){k.stopPropagation();}else{k.cancelBubble=true;}},preventDefault:function(k){if(k.preventDefault){k.preventDefault();}else{k.returnValue=false;}},getEvent:function(m,k){var l=m||window.event;if(!l){var n=this.getEvent.caller;while(n){l=n.arguments[0];if(l&&Event==l.constructor){break;}n=n.caller;}}return l;},getCharCode:function(l){var k=l.keyCode||l.charCode||0;if(YAHOO.env.ua.webkit&&(k in c)){k=c[k];}return k;},_getCacheIndex:function(n,q,r,p){for(var o=0,m=n.length;o<m;o=o+1){var k=n[o];if(k&&k[this.FN]==p&&k[this.EL]==q&&k[this.TYPE]==r){return o;}}return -1;},generateId:function(k){var l=k.id;if(!l){l="yuievtautoid-"+b;++b;k.id=l;}return l;},_isValidCollection:function(l){try{return(l&&typeof l!=="string"&&l.length&&!l.tagName&&!l.alert&&typeof l[0]!=="undefined");}catch(k){return false;}},elCache:{},getEl:function(k){return(typeof k==="string")?document.getElementById(k):k;},clearCache:function(){},DOMReadyEvent:new YAHOO.util.CustomEvent("DOMReady",YAHOO,0,0,1),_load:function(l){if(!g){g=true;var k=YAHOO.util.Event;k._ready();k._tryPreloadAttach();}},_ready:function(l){var k=YAHOO.util.Event;if(!k.DOMReady){k.DOMReady=true;k.DOMReadyEvent.fire();k._simpleRemove(document,"DOMContentLoaded",k._ready);}},_tryPreloadAttach:function(){if(e.length===0){a=0;if(this._interval){this._interval.cancel();this._interval=null;}return;}if(this.locked){return;}if(this.isIE){if(!this.DOMReady){this.startInterval();return;}}this.locked=true;var q=!g;if(!q){q=(a>0&&e.length>0);}var p=[];var r=function(t,u){var s=t;if(u.overrideContext){if(u.overrideContext===true){s=u.obj;}else{s=u.overrideContext;}}u.fn.call(s,u.obj);};var l,k,o,n,m=[];for(l=0,k=e.length;l<k;l=l+1){o=e[l];if(o){n=this.getEl(o.id);if(n){if(o.checkReady){if(g||n.nextSibling||!q){m.push(o);e[l]=null;}}else{r(n,o);e[l]=null;}}else{p.push(o);}}}for(l=0,k=m.length;l<k;l=l+1){o=m[l];r(this.getEl(o.id),o);}a--;if(q){for(l=e.length-1;l>-1;l--){o=e[l];if(!o||!o.id){e.splice(l,1);}}this.startInterval();}else{if(this._interval){this._interval.cancel();this._interval=null;}}this.locked=false;},purgeElement:function(p,q,s){var n=(YAHOO.lang.isString(p))?this.getEl(p):p;var r=this.getListeners(n,s),o,k;if(r){for(o=r.length-1;o>-1;o--){var m=r[o];this.removeListener(n,m.type,m.fn);}}if(q&&n&&n.childNodes){for(o=0,k=n.childNodes.length;o<k;++o){this.purgeElement(n.childNodes[o],q,s);}}},getListeners:function(n,k){var q=[],m;if(!k){m=[h,j];}else{if(k==="unload"){m=[j];}else{k=this._getType(k);m=[h];}}var s=(YAHOO.lang.isString(n))?this.getEl(n):n;for(var p=0;p<m.length;p=p+1){var u=m[p];if(u){for(var r=0,t=u.length;r<t;++r){var o=u[r];if(o&&o[this.EL]===s&&(!k||k===o[this.TYPE])){q.push({type:o[this.TYPE],fn:o[this.FN],obj:o[this.OBJ],adjust:o[this.OVERRIDE],scope:o[this.ADJ_SCOPE],index:r});}}}}return(q.length)?q:null;},_unload:function(s){var m=YAHOO.util.Event,p,o,n,r,q,t=j.slice(),k;for(p=0,r=j.length;p<r;++p){n=t[p];if(n){try{k=window;if(n[m.ADJ_SCOPE]){if(n[m.ADJ_SCOPE]===true){k=n[m.UNLOAD_OBJ];}else{k=n[m.ADJ_SCOPE];}}n[m.FN].call(k,m.getEvent(s,n[m.EL]),n[m.UNLOAD_OBJ]);}catch(w){}t[p]=null;}}n=null;k=null;j=null;if(h){for(o=h.length-1;o>-1;o--){n=h[o];if(n){try{m.removeListener(n[m.EL],n[m.TYPE],n[m.FN],o);}catch(v){}}}n=null;}try{m._simpleRemove(window,"unload",m._unload);m._simpleRemove(window,"load",m._load);}catch(u){}},_getScrollLeft:function(){return this._getScroll()[1];},_getScrollTop:function(){return this._getScroll()[0];},_getScroll:function(){var k=document.documentElement,l=document.body;if(k&&(k.scrollTop||k.scrollLeft)){return[k.scrollTop,k.scrollLeft];}else{if(l){return[l.scrollTop,l.scrollLeft];}else{return[0,0];}}},regCE:function(){},_simpleAdd:function(){if(window.addEventListener){return function(m,n,l,k){m.addEventListener(n,l,(k));};}else{if(window.attachEvent){return function(m,n,l,k){m.attachEvent("on"+n,l);};}else{return function(){};}}}(),_simpleRemove:function(){if(window.removeEventListener){return function(m,n,l,k){m.removeEventListener(n,l,(k));};}else{if(window.detachEvent){return function(l,m,k){l.detachEvent("on"+m,k);};}else{return function(){};}}}()};}();(function(){var a=YAHOO.util.Event;a.on=a.addListener;a.onFocus=a.addFocusListener;a.onBlur=a.addBlurListener;
/*
 * ! DOMReady: based on work by: Dean Edwards/John Resig/Matthias Miller/Diego
 * Perini
 */
if(a.isIE){if(self!==self.top){document.onreadystatechange=function(){if(document.readyState=="complete"){document.onreadystatechange=null;a._ready();}};}else{YAHOO.util.Event.onDOMReady(YAHOO.util.Event._tryPreloadAttach,YAHOO.util.Event,true);var b=document.createElement("p");a._dri=setInterval(function(){try{b.doScroll("left");clearInterval(a._dri);a._dri=null;a._ready();b=null;}catch(c){}},a.POLL_INTERVAL);}}else{if(a.webkit&&a.webkit<525){a._dri=setInterval(function(){var c=document.readyState;if("loaded"==c||"complete"==c){clearInterval(a._dri);a._dri=null;a._ready();}},a.POLL_INTERVAL);}else{a._simpleAdd(document,"DOMContentLoaded",a._ready);}}a._simpleAdd(window,"load",a._load);a._simpleAdd(window,"unload",a._unload);a._tryPreloadAttach();})();}YAHOO.util.EventProvider=function(){};YAHOO.util.EventProvider.prototype={__yui_events:null,__yui_subscribers:null,subscribe:function(a,c,f,e){this.__yui_events=this.__yui_events||{};var d=this.__yui_events[a];if(d){d.subscribe(c,f,e);}else{this.__yui_subscribers=this.__yui_subscribers||{};var b=this.__yui_subscribers;if(!b[a]){b[a]=[];}b[a].push({fn:c,obj:f,overrideContext:e});}},unsubscribe:function(c,e,g){this.__yui_events=this.__yui_events||{};var a=this.__yui_events;if(c){var f=a[c];if(f){return f.unsubscribe(e,g);}}else{var b=true;for(var d in a){if(YAHOO.lang.hasOwnProperty(a,d)){b=b&&a[d].unsubscribe(e,g);
}}return b;}return false;},unsubscribeAll:function(a){return this.unsubscribe(a);},createEvent:function(b,g){this.__yui_events=this.__yui_events||{};var e=g||{},d=this.__yui_events,f;if(d[b]){}else{f=new YAHOO.util.CustomEvent(b,e.scope||this,e.silent,YAHOO.util.CustomEvent.FLAT,e.fireOnce);d[b]=f;if(e.onSubscribeCallback){f.subscribeEvent.subscribe(e.onSubscribeCallback);}this.__yui_subscribers=this.__yui_subscribers||{};var a=this.__yui_subscribers[b];if(a){for(var c=0;c<a.length;++c){f.subscribe(a[c].fn,a[c].obj,a[c].overrideContext);}}}return d[b];},fireEvent:function(b){this.__yui_events=this.__yui_events||{};var d=this.__yui_events[b];if(!d){return null;}var a=[];for(var c=1;c<arguments.length;++c){a.push(arguments[c]);}return d.fire.apply(d,a);},hasEvent:function(a){if(this.__yui_events){if(this.__yui_events[a]){return true;}}return false;}};(function(){var a=YAHOO.util.Event,c=YAHOO.lang;YAHOO.util.KeyListener=function(d,i,e,f){if(!d){}else{if(!i){}else{if(!e){}}}if(!f){f=YAHOO.util.KeyListener.KEYDOWN;}var g=new YAHOO.util.CustomEvent("keyPressed");this.enabledEvent=new YAHOO.util.CustomEvent("enabled");this.disabledEvent=new YAHOO.util.CustomEvent("disabled");if(c.isString(d)){d=document.getElementById(d);}if(c.isFunction(e)){g.subscribe(e);}else{g.subscribe(e.fn,e.scope,e.correctScope);}function h(o,n){if(!i.shift){i.shift=false;}if(!i.alt){i.alt=false;}if(!i.ctrl){i.ctrl=false;}if(o.shiftKey==i.shift&&o.altKey==i.alt&&o.ctrlKey==i.ctrl){var j,m=i.keys,l;if(YAHOO.lang.isArray(m)){for(var k=0;k<m.length;k++){j=m[k];l=a.getCharCode(o);if(j==l){g.fire(l,o);break;}}}else{l=a.getCharCode(o);if(m==l){g.fire(l,o);}}}}this.enable=function(){if(!this.enabled){a.on(d,f,h);this.enabledEvent.fire(i);}this.enabled=true;};this.disable=function(){if(this.enabled){a.removeListener(d,f,h);this.disabledEvent.fire(i);}this.enabled=false;};this.toString=function(){return"KeyListener ["+i.keys+"] "+d.tagName+(d.id?"["+d.id+"]":"");};};var b=YAHOO.util.KeyListener;b.KEYDOWN="keydown";b.KEYUP="keyup";b.KEY={ALT:18,BACK_SPACE:8,CAPS_LOCK:20,CONTROL:17,DELETE:46,DOWN:40,END:35,ENTER:13,ESCAPE:27,HOME:36,LEFT:37,META:224,NUM_LOCK:144,PAGE_DOWN:34,PAGE_UP:33,PAUSE:19,PRINTSCREEN:44,RIGHT:39,SCROLL_LOCK:145,SHIFT:16,SPACE:32,TAB:9,UP:38};})();YAHOO.register("event",YAHOO.util.Event,{version:"2.9.0",build:"2800"});YAHOO.register("yahoo-dom-event", YAHOO, {version: "2.9.0", build: "2800"});/*
																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																												 * Copyright
																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																												 * (c)
																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																												 * 2011,
																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																												 * Yahoo!
																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																												 * Inc.
																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																												 * All
																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																												 * rights
																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																												 * reserved.
																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																												 * Code
																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																												 * licensed
																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																												 * under
																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																												 * the
																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																												 * BSD
																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																												 * License:
																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																												 * http://developer.yahoo.com/yui/license.html
																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																												 * version:
																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																												 * 2.9.0
																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																												 */
(function() {

var Y = YAHOO.util;

/*
 * Copyright (c) 2006, Yahoo! Inc. All rights reserved. Code licensed under the
 * BSD License: http://developer.yahoo.net/yui/license.txt
 */

/**
 * The animation module provides allows effects to be added to HTMLElements.
 * 
 * @module animation
 * @requires yahoo, event, dom
 */

/**
 * 
 * Base animation class that provides the interface for building animated
 * effects.
 * <p>
 * Usage: var myAnim = new YAHOO.util.Anim(el, { width: { from: 10, to: 100 } },
 * 1, YAHOO.util.Easing.easeOut);
 * </p>
 * 
 * @class Anim
 * @namespace YAHOO.util
 * @requires YAHOO.util.AnimMgr
 * @requires YAHOO.util.Easing
 * @requires YAHOO.util.Dom
 * @requires YAHOO.util.Event
 * @requires YAHOO.util.CustomEvent
 * @constructor
 * @param {String |
 *            HTMLElement} el Reference to the element that will be animated
 * @param {Object}
 *            attributes The attribute(s) to be animated. Each attribute is an
 *            object with at minimum a "to" or "by" member defined. Additional
 *            optional members are "from" (defaults to current value), "units"
 *            (defaults to "px"). All attribute names use camelCase.
 * @param {Number}
 *            duration (optional, defaults to 1 second) Length of animation
 *            (frames or seconds), defaults to time-based
 * @param {Function}
 *            method (optional, defaults to YAHOO.util.Easing.easeNone) Computes
 *            the values that are applied to the attributes per frame (generally
 *            a YAHOO.util.Easing method)
 */

var Anim = function(el, attributes, duration, method) {
    if (!el) {
    }
    this.init(el, attributes, duration, method); 
};

Anim.NAME = 'Anim';

Anim.prototype = {
    /**
	 * Provides a readable name for the Anim instance.
	 * 
	 * @method toString
	 * @return {String}
	 */
    toString: function() {
        var el = this.getEl() || {};
        var id = el.id || el.tagName;
        return (this.constructor.NAME + ': ' + id);
    },
    
    patterns: { // cached for performance
        noNegatives:        /width|height|opacity|padding/i, // keep at zero
																// or above
        offsetAttribute:  /^((width|height)|(top|left))$/, // use offsetValue
															// as default
        defaultUnit:        /width|height|top$|bottom$|left$|right$/i, // use
																		// 'px'
																		// by
																		// default
        offsetUnit:         /\d+(em|%|en|ex|pt|in|cm|mm|pc)$/i // IE may return
																// these, so
																// convert these
																// to offset
    },
    
    /**
	 * Returns the value computed by the animation's "method".
	 * 
	 * @method doMethod
	 * @param {String}
	 *            attr The name of the attribute.
	 * @param {Number}
	 *            start The value this attribute should start from for this
	 *            animation.
	 * @param {Number}
	 *            end The value this attribute should end at for this animation.
	 * @return {Number} The Value to be applied to the attribute.
	 */
    doMethod: function(attr, start, end) {
        return this.method(this.currentFrame, start, end - start, this.totalFrames);
    },
    
    /**
	 * Applies a value to an attribute.
	 * 
	 * @method setAttribute
	 * @param {String}
	 *            attr The name of the attribute.
	 * @param {Number}
	 *            val The value to be applied to the attribute.
	 * @param {String}
	 *            unit The unit ('px', '%', etc.) of the value.
	 */
    setAttribute: function(attr, val, unit) {
        var el = this.getEl();
        if ( this.patterns.noNegatives.test(attr) ) {
            val = (val > 0) ? val : 0;
        }

        if (attr in el && !('style' in el && attr in el.style)) {
            el[attr] = val;
        } else {
            Y.Dom.setStyle(el, attr, val + unit);
        }
    },                        
    
    /**
	 * Returns current value of the attribute.
	 * 
	 * @method getAttribute
	 * @param {String}
	 *            attr The name of the attribute.
	 * @return {Number} val The current value of the attribute.
	 */
    getAttribute: function(attr) {
        var el = this.getEl();
        var val = Y.Dom.getStyle(el, attr);

        if (val !== 'auto' && !this.patterns.offsetUnit.test(val)) {
            return parseFloat(val);
        }
        
        var a = this.patterns.offsetAttribute.exec(attr) || [];
        var pos = !!( a[3] ); // top or left
        var box = !!( a[2] ); // width or height
        
        if ('style' in el) {
            // use offsets for width/height and abs pos top/left
            if ( box || (Y.Dom.getStyle(el, 'position') == 'absolute' && pos) ) {
                val = el['offset' + a[0].charAt(0).toUpperCase() + a[0].substr(1)];
            } else { // default to zero for other 'auto'
                val = 0;
            }
        } else if (attr in el) {
            val = el[attr];
        }

        return val;
    },
    
    /**
	 * Returns the unit to use when none is supplied.
	 * 
	 * @method getDefaultUnit
	 * @param {attr}
	 *            attr The name of the attribute.
	 * @return {String} The default unit to be used.
	 */
    getDefaultUnit: function(attr) {
         if ( this.patterns.defaultUnit.test(attr) ) {
            return 'px';
         }
         
         return '';
    },
        
    /**
	 * Sets the actual values to be used during the animation. Should only be
	 * needed for subclass use.
	 * 
	 * @method setRuntimeAttribute
	 * @param {Object}
	 *            attr The attribute object
	 * @private
	 */
    setRuntimeAttribute: function(attr) {
        var start;
        var end;
        var attributes = this.attributes;

        this.runtimeAttributes[attr] = {};
        
        var isset = function(prop) {
            return (typeof prop !== 'undefined');
        };
        
        if ( !isset(attributes[attr]['to']) && !isset(attributes[attr]['by']) ) {
            return false; // note return; nothing to animate to
        }
        
        start = ( isset(attributes[attr]['from']) ) ? attributes[attr]['from'] : this.getAttribute(attr);

        // To beats by, per SMIL 2.1 spec
        if ( isset(attributes[attr]['to']) ) {
            end = attributes[attr]['to'];
        } else if ( isset(attributes[attr]['by']) ) {
            if (start.constructor == Array) {
                end = [];
                for (var i = 0, len = start.length; i < len; ++i) {
                    end[i] = start[i] + attributes[attr]['by'][i] * 1; // times
																		// 1 to
																		// cast
																		// "by"
                }
            } else {
                end = start + attributes[attr]['by'] * 1;
            }
        }
        
        this.runtimeAttributes[attr].start = start;
        this.runtimeAttributes[attr].end = end;

        // set units if needed
        this.runtimeAttributes[attr].unit = ( isset(attributes[attr].unit) ) ?
                attributes[attr]['unit'] : this.getDefaultUnit(attr);
        return true;
    },

    /**
	 * Constructor for Anim instance.
	 * 
	 * @method init
	 * @param {String |
	 *            HTMLElement} el Reference to the element that will be animated
	 * @param {Object}
	 *            attributes The attribute(s) to be animated. Each attribute is
	 *            an object with at minimum a "to" or "by" member defined.
	 *            Additional optional members are "from" (defaults to current
	 *            value), "units" (defaults to "px"). All attribute names use
	 *            camelCase.
	 * @param {Number}
	 *            duration (optional, defaults to 1 second) Length of animation
	 *            (frames or seconds), defaults to time-based
	 * @param {Function}
	 *            method (optional, defaults to YAHOO.util.Easing.easeNone)
	 *            Computes the values that are applied to the attributes per
	 *            frame (generally a YAHOO.util.Easing method)
	 */ 
    init: function(el, attributes, duration, method) {
        /**
		 * Whether or not the animation is running.
		 * 
		 * @property isAnimated
		 * @private
		 * @type Boolean
		 */
        var isAnimated = false;
        
        /**
		 * A Date object that is created when the animation begins.
		 * 
		 * @property startTime
		 * @private
		 * @type Date
		 */
        var startTime = null;
        
        /**
		 * The number of frames this animation was able to execute.
		 * 
		 * @property actualFrames
		 * @private
		 * @type Int
		 */
        var actualFrames = 0; 

        /**
		 * The element to be animated.
		 * 
		 * @property el
		 * @private
		 * @type HTMLElement
		 */
        el = Y.Dom.get(el);
        
        /**
		 * The collection of attributes to be animated. Each attribute must have
		 * at least a "to" or "by" defined in order to animate. If "to" is
		 * supplied, the animation will end with the attribute at that value. If
		 * "by" is supplied, the animation will end at that value plus its
		 * starting value. If both are supplied, "to" is used, and "by" is
		 * ignored. Optional additional member include "from" (the value the
		 * attribute should start animating from, defaults to current value),
		 * and "unit" (the units to apply to the values).
		 * 
		 * @property attributes
		 * @type Object
		 */
        this.attributes = attributes || {};
        
        /**
		 * The length of the animation. Defaults to "1" (second).
		 * 
		 * @property duration
		 * @type Number
		 */
        this.duration = !YAHOO.lang.isUndefined(duration) ? duration : 1;
        
        /**
		 * The method that will provide values to the attribute(s) during the
		 * animation. Defaults to "YAHOO.util.Easing.easeNone".
		 * 
		 * @property method
		 * @type Function
		 */
        this.method = method || Y.Easing.easeNone;

        /**
		 * Whether or not the duration should be treated as seconds. Defaults to
		 * true.
		 * 
		 * @property useSeconds
		 * @type Boolean
		 */
        this.useSeconds = true; // default to seconds
        
        /**
		 * The location of the current animation on the timeline. In time-based
		 * animations, this is used by AnimMgr to ensure the animation finishes
		 * on time.
		 * 
		 * @property currentFrame
		 * @type Int
		 */
        this.currentFrame = 0;
        
        /**
		 * The total number of frames to be executed. In time-based animations,
		 * this is used by AnimMgr to ensure the animation finishes on time.
		 * 
		 * @property totalFrames
		 * @type Int
		 */
        this.totalFrames = Y.AnimMgr.fps;
        
        /**
		 * Changes the animated element
		 * 
		 * @method setEl
		 */
        this.setEl = function(element) {
            el = Y.Dom.get(element);
        };
        
        /**
		 * Returns a reference to the animated element.
		 * 
		 * @method getEl
		 * @return {HTMLElement}
		 */
        this.getEl = function() { return el; };
        
        /**
		 * Checks whether the element is currently animated.
		 * 
		 * @method isAnimated
		 * @return {Boolean} current value of isAnimated.
		 */
        this.isAnimated = function() {
            return isAnimated;
        };
        
        /**
		 * Returns the animation start time.
		 * 
		 * @method getStartTime
		 * @return {Date} current value of startTime.
		 */
        this.getStartTime = function() {
            return startTime;
        };        
        
        this.runtimeAttributes = {};
        
        
        
        /**
		 * Starts the animation by registering it with the animation manager.
		 * 
		 * @method animate
		 */
        this.animate = function() {
            if ( this.isAnimated() ) {
                return false;
            }
            
            this.currentFrame = 0;
            
            this.totalFrames = ( this.useSeconds ) ? Math.ceil(Y.AnimMgr.fps * this.duration) : this.duration;
    
            if (this.duration === 0 && this.useSeconds) { // jump to last
															// frame if zero
															// second duration
                this.totalFrames = 1; 
            }
            Y.AnimMgr.registerElement(this);
            return true;
        };
          
        /**
		 * Stops the animation. Normally called by AnimMgr when animation
		 * completes.
		 * 
		 * @method stop
		 * @param {Boolean}
		 *            finish (optional) If true, animation will jump to final
		 *            frame.
		 */ 
        this.stop = function(finish) {
            if (!this.isAnimated()) { // nothing to stop
                return false;
            }

            if (finish) {
                 this.currentFrame = this.totalFrames;
                 this._onTween.fire();
            }
            Y.AnimMgr.stop(this);
        };
        
        this._handleStart = function() {            
            this.onStart.fire();
            
            this.runtimeAttributes = {};
            for (var attr in this.attributes) {
                if (this.attributes.hasOwnProperty(attr)) {
                    this.setRuntimeAttribute(attr);
                }
            }
            
            isAnimated = true;
            actualFrames = 0;
            startTime = new Date(); 
        };
        
        /**
		 * Feeds the starting and ending values for each animated attribute to
		 * doMethod once per frame, then applies the resulting value to the
		 * attribute(s).
		 * 
		 * @private
		 */
         
        this._handleTween = function() {
            var data = {
                duration: new Date() - this.getStartTime(),
                currentFrame: this.currentFrame
            };
            
            data.toString = function() {
                return (
                    'duration: ' + data.duration +
                    ', currentFrame: ' + data.currentFrame
                );
            };
            
            this.onTween.fire(data);
            
            var runtimeAttributes = this.runtimeAttributes;
            
            for (var attr in runtimeAttributes) {
                if (runtimeAttributes.hasOwnProperty(attr)) {
                    this.setAttribute(attr, this.doMethod(attr, runtimeAttributes[attr].start, runtimeAttributes[attr].end), runtimeAttributes[attr].unit); 
                }
            }
            
            this.afterTween.fire(data);
            
            actualFrames += 1;
        };
        
        this._handleComplete = function() {
            var actual_duration = (new Date() - startTime) / 1000 ;
            
            var data = {
                duration: actual_duration,
                frames: actualFrames,
                fps: actualFrames / actual_duration
            };
            
            data.toString = function() {
                return (
                    'duration: ' + data.duration +
                    ', frames: ' + data.frames +
                    ', fps: ' + data.fps
                );
            };
            
            isAnimated = false;
            actualFrames = 0;
            this.onComplete.fire(data);
        };
        
        /**
		 * Custom event that fires after onStart, useful in subclassing
		 * 
		 * @private
		 */    
        this._onStart = new Y.CustomEvent('_start', this, true);

        /**
		 * Custom event that fires when animation begins Listen via subscribe
		 * method (e.g. myAnim.onStart.subscribe(someFunction)
		 * 
		 * @event onStart
		 */    
        this.onStart = new Y.CustomEvent('start', this);
        
        /**
		 * Custom event that fires between each frame Listen via subscribe
		 * method (e.g. myAnim.onTween.subscribe(someFunction)
		 * 
		 * @event onTween
		 */
        this.onTween = new Y.CustomEvent('tween', this);
        
        /**
		 * Custom event that fires between each frame Listen via subscribe
		 * method (e.g. myAnim.afterTween.subscribe(someFunction)
		 * 
		 * @event afterTween
		 */
        this.afterTween = new Y.CustomEvent('afterTween', this);
        
        /**
		 * Custom event that fires after onTween
		 * 
		 * @private
		 */
        this._onTween = new Y.CustomEvent('_tween', this, true);
        
        /**
		 * Custom event that fires when animation ends Listen via subscribe
		 * method (e.g. myAnim.onComplete.subscribe(someFunction)
		 * 
		 * @event onComplete
		 */
        this.onComplete = new Y.CustomEvent('complete', this);
        /**
		 * Custom event that fires after onComplete
		 * 
		 * @private
		 */
        this._onComplete = new Y.CustomEvent('_complete', this, true);

        this._onStart.subscribe(this._handleStart);
        this._onTween.subscribe(this._handleTween);
        this._onComplete.subscribe(this._handleComplete);
    }
};

    Y.Anim = Anim;
})();
/**
 * Handles animation queueing and threading. Used by Anim and subclasses.
 * 
 * @class AnimMgr
 * @namespace YAHOO.util
 */
YAHOO.util.AnimMgr = new function() {
    /**
	 * Reference to the animation Interval.
	 * 
	 * @property thread
	 * @private
	 * @type Int
	 */
    var thread = null;
    
    /**
	 * The current queue of registered animation objects.
	 * 
	 * @property queue
	 * @private
	 * @type Array
	 */    
    var queue = [];

    /**
	 * The number of active animations.
	 * 
	 * @property tweenCount
	 * @private
	 * @type Int
	 */        
    var tweenCount = 0;

    /**
	 * Base frame rate (frames per second). Arbitrarily high for better
	 * x-browser calibration (slower browsers drop more frames).
	 * 
	 * @property fps
	 * @type Int
	 * 
	 */
    this.fps = 1000;

    /**
	 * Interval delay in milliseconds, defaults to fastest possible.
	 * 
	 * @property delay
	 * @type Int
	 * 
	 */
    this.delay = 20;

    /**
	 * Adds an animation instance to the animation queue. All animation
	 * instances must be registered in order to animate.
	 * 
	 * @method registerElement
	 * @param {object}
	 *            tween The Anim instance to be be registered
	 */
    this.registerElement = function(tween) {
        queue[queue.length] = tween;
        tweenCount += 1;
        tween._onStart.fire();
        this.start();
    };
    
    var _unregisterQueue = [];
    var _unregistering = false;

    var doUnregister = function() {
        var next_args = _unregisterQueue.shift();
        unRegister.apply(YAHOO.util.AnimMgr,next_args);
        if (_unregisterQueue.length) {
            arguments.callee();
        }
    };

    var unRegister = function(tween, index) {
        index = index || getIndex(tween);
        if (!tween.isAnimated() || index === -1) {
            return false;
        }
        
        tween._onComplete.fire();
        queue.splice(index, 1);

        tweenCount -= 1;
        if (tweenCount <= 0) {
            this.stop();
        }

        return true;
    };

    /**
	 * removes an animation instance from the animation queue. All animation
	 * instances must be registered in order to animate.
	 * 
	 * @method unRegister
	 * @param {object}
	 *            tween The Anim instance to be be registered
	 * @param {Int}
	 *            index The index of the Anim instance
	 * @private
	 */
    this.unRegister = function() {
        _unregisterQueue.push(arguments);
        if (!_unregistering) {
            _unregistering = true;
            doUnregister();
            _unregistering = false;
        }
    }

    /**
	 * Starts the animation thread. Only one thread can run at a time.
	 * 
	 * @method start
	 */    
    this.start = function() {
        if (thread === null) {
            thread = setInterval(this.run, this.delay);
        }
    };

    /**
	 * Stops the animation thread or a specific animation instance.
	 * 
	 * @method stop
	 * @param {object}
	 *            tween A specific Anim instance to stop (optional) If no
	 *            instance given, Manager stops thread and all animations.
	 */    
    this.stop = function(tween) {
        if (!tween) {
            clearInterval(thread);
            
            for (var i = 0, len = queue.length; i < len; ++i) {
                this.unRegister(queue[0], 0);  
            }

            queue = [];
            thread = null;
            tweenCount = 0;
        }
        else {
            this.unRegister(tween);
        }
    };
    
    /**
	 * Called per Interval to handle each animation frame.
	 * 
	 * @method run
	 */    
    this.run = function() {
        for (var i = 0, len = queue.length; i < len; ++i) {
            var tween = queue[i];
            if ( !tween || !tween.isAnimated() ) { continue; }

            if (tween.currentFrame < tween.totalFrames || tween.totalFrames === null)
            {
                tween.currentFrame += 1;
                
                if (tween.useSeconds) {
                    correctFrame(tween);
                }
                tween._onTween.fire();          
            }
            else { YAHOO.util.AnimMgr.stop(tween, i); }
        }
    };
    
    var getIndex = function(anim) {
        for (var i = 0, len = queue.length; i < len; ++i) {
            if (queue[i] === anim) {
                return i; // note return;
            }
        }
        return -1;
    };
    
    /**
	 * On the fly frame correction to keep animation on time.
	 * 
	 * @method correctFrame
	 * @private
	 * @param {Object}
	 *            tween The Anim instance being corrected.
	 */
    var correctFrame = function(tween) {
        var frames = tween.totalFrames;
        var frame = tween.currentFrame;
        var expected = (tween.currentFrame * tween.duration * 1000 / tween.totalFrames);
        var elapsed = (new Date() - tween.getStartTime());
        var tweak = 0;
        
        if (elapsed < tween.duration * 1000) { // check if falling behind
            tweak = Math.round((elapsed / expected - 1) * tween.currentFrame);
        } else { // went over duration, so jump to end
            tweak = frames - (frame + 1); 
        }
        if (tweak > 0 && isFinite(tweak)) { // adjust if needed
            if (tween.currentFrame + tweak >= frames) {// dont go past last
														// frame
                tweak = frames - (frame + 1);
            }
            
            tween.currentFrame += tweak;      
        }
    };
    this._queue = queue;
    this._getIndex = getIndex;
};
/**
 * Used to calculate Bezier splines for any number of control points.
 * 
 * @class Bezier
 * @namespace YAHOO.util
 * 
 */
YAHOO.util.Bezier = new function() {
    /**
	 * Get the current position of the animated element based on t. Each point
	 * is an array of "x" and "y" values (0 = x, 1 = y) At least 2 points are
	 * required (start and end). First point is start. Last point is end.
	 * Additional control points are optional.
	 * 
	 * @method getPosition
	 * @param {Array}
	 *            points An array containing Bezier points
	 * @param {Number}
	 *            t A number between 0 and 1 which is the basis for determining
	 *            current position
	 * @return {Array} An array containing int x and y member data
	 */
    this.getPosition = function(points, t) {  
        var n = points.length;
        var tmp = [];

        for (var i = 0; i < n; ++i){
            tmp[i] = [points[i][0], points[i][1]]; // save input
        }
        
        for (var j = 1; j < n; ++j) {
            for (i = 0; i < n - j; ++i) {
                tmp[i][0] = (1 - t) * tmp[i][0] + t * tmp[parseInt(i + 1, 10)][0];
                tmp[i][1] = (1 - t) * tmp[i][1] + t * tmp[parseInt(i + 1, 10)][1]; 
            }
        }
    
        return [ tmp[0][0], tmp[0][1] ]; 
    
    };
};
(function() {
/**
 * Anim subclass for color transitions.
 * <p>
 * Usage:
 * <code>var myAnim = new Y.ColorAnim(el, { backgroundColor: { from: '#FF0000', to: '#FFFFFF' } }, 1, Y.Easing.easeOut);</code>
 * Color values can be specified with either 112233, #112233, [255,255,255], or
 * rgb(255,255,255)
 * </p>
 * 
 * @class ColorAnim
 * @namespace YAHOO.util
 * @requires YAHOO.util.Anim
 * @requires YAHOO.util.AnimMgr
 * @requires YAHOO.util.Easing
 * @requires YAHOO.util.Bezier
 * @requires YAHOO.util.Dom
 * @requires YAHOO.util.Event
 * @constructor
 * @extends YAHOO.util.Anim
 * @param {HTMLElement |
 *            String} el Reference to the element that will be animated
 * @param {Object}
 *            attributes The attribute(s) to be animated. Each attribute is an
 *            object with at minimum a "to" or "by" member defined. Additional
 *            optional members are "from" (defaults to current value), "units"
 *            (defaults to "px"). All attribute names use camelCase.
 * @param {Number}
 *            duration (optional, defaults to 1 second) Length of animation
 *            (frames or seconds), defaults to time-based
 * @param {Function}
 *            method (optional, defaults to YAHOO.util.Easing.easeNone) Computes
 *            the values that are applied to the attributes per frame (generally
 *            a YAHOO.util.Easing method)
 */
    var ColorAnim = function(el, attributes, duration,  method) {
        ColorAnim.superclass.constructor.call(this, el, attributes, duration, method);
    };
    
    ColorAnim.NAME = 'ColorAnim';

    ColorAnim.DEFAULT_BGCOLOR = '#fff';
    // shorthand
    var Y = YAHOO.util;
    YAHOO.extend(ColorAnim, Y.Anim);

    var superclass = ColorAnim.superclass;
    var proto = ColorAnim.prototype;
    
    proto.patterns.color = /color$/i;
    proto.patterns.rgb            = /^rgb\(([0-9]+)\s*,\s*([0-9]+)\s*,\s*([0-9]+)\)$/i;
    proto.patterns.hex            = /^#?([0-9A-F]{2})([0-9A-F]{2})([0-9A-F]{2})$/i;
    proto.patterns.hex3          = /^#?([0-9A-F]{1})([0-9A-F]{1})([0-9A-F]{1})$/i;
    proto.patterns.transparent = /^transparent|rgba\(0, 0, 0, 0\)$/; // need
																		// rgba
																		// for
																		// safari
    
    /**
	 * Attempts to parse the given string and return a 3-tuple.
	 * 
	 * @method parseColor
	 * @param {String}
	 *            s The string to parse.
	 * @return {Array} The 3-tuple of rgb values.
	 */
    proto.parseColor = function(s) {
        if (s.length == 3) { return s; }
    
        var c = this.patterns.hex.exec(s);
        if (c && c.length == 4) {
            return [ parseInt(c[1], 16), parseInt(c[2], 16), parseInt(c[3], 16) ];
        }
    
        c = this.patterns.rgb.exec(s);
        if (c && c.length == 4) {
            return [ parseInt(c[1], 10), parseInt(c[2], 10), parseInt(c[3], 10) ];
        }
    
        c = this.patterns.hex3.exec(s);
        if (c && c.length == 4) {
            return [ parseInt(c[1] + c[1], 16), parseInt(c[2] + c[2], 16), parseInt(c[3] + c[3], 16) ];
        }
        
        return null;
    };

    proto.getAttribute = function(attr) {
        var el = this.getEl();
        if (this.patterns.color.test(attr) ) {
            var val = YAHOO.util.Dom.getStyle(el, attr);
            
            var that = this;
            if (this.patterns.transparent.test(val)) { // bgcolor default
                var parent = YAHOO.util.Dom.getAncestorBy(el, function(node) {
                    return !that.patterns.transparent.test(val);
                });

                if (parent) {
                    val = Y.Dom.getStyle(parent, attr);
                } else {
                    val = ColorAnim.DEFAULT_BGCOLOR;
                }
            }
        } else {
            val = superclass.getAttribute.call(this, attr);
        }

        return val;
    };
    
    proto.doMethod = function(attr, start, end) {
        var val;
    
        if ( this.patterns.color.test(attr) ) {
            val = [];
            for (var i = 0, len = start.length; i < len; ++i) {
                val[i] = superclass.doMethod.call(this, attr, start[i], end[i]);
            }
            
            val = 'rgb('+Math.floor(val[0])+','+Math.floor(val[1])+','+Math.floor(val[2])+')';
        }
        else {
            val = superclass.doMethod.call(this, attr, start, end);
        }

        return val;
    };

    proto.setRuntimeAttribute = function(attr) {
        superclass.setRuntimeAttribute.call(this, attr);
        
        if ( this.patterns.color.test(attr) ) {
            var attributes = this.attributes;
            var start = this.parseColor(this.runtimeAttributes[attr].start);
            var end = this.parseColor(this.runtimeAttributes[attr].end);
            // fix colors if going "by"
            if ( typeof attributes[attr]['to'] === 'undefined' && typeof attributes[attr]['by'] !== 'undefined' ) {
                end = this.parseColor(attributes[attr].by);
            
                for (var i = 0, len = start.length; i < len; ++i) {
                    end[i] = start[i] + end[i];
                }
            }
            
            this.runtimeAttributes[attr].start = start;
            this.runtimeAttributes[attr].end = end;
        }
    };

    Y.ColorAnim = ColorAnim;
})();
/*
 * ! TERMS OF USE - EASING EQUATIONS Open source under the BSD License.
 * Copyright 2001 Robert Penner All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 * Redistributions of source code must retain the above copyright notice, this
 * list of conditions and the following disclaimer. Redistributions in binary
 * form must reproduce the above copyright notice, this list of conditions and
 * the following disclaimer in the documentation and/or other materials provided
 * with the distribution. Neither the name of the author nor the names of
 * contributors may be used to endorse or promote products derived from this
 * software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * Singleton that determines how an animation proceeds from start to end.
 * 
 * @class Easing
 * @namespace YAHOO.util
 */

YAHOO.util.Easing = {

    /**
	 * Uniform speed between points.
	 * 
	 * @method easeNone
	 * @param {Number}
	 *            t Time value used to compute current value
	 * @param {Number}
	 *            b Starting value
	 * @param {Number}
	 *            c Delta between start and end values
	 * @param {Number}
	 *            d Total length of animation
	 * @return {Number} The computed value for the current animation frame
	 */
    easeNone: function (t, b, c, d) {
    	return c*t/d + b;
    },
    
    /**
	 * Begins slowly and accelerates towards end.
	 * 
	 * @method easeIn
	 * @param {Number}
	 *            t Time value used to compute current value
	 * @param {Number}
	 *            b Starting value
	 * @param {Number}
	 *            c Delta between start and end values
	 * @param {Number}
	 *            d Total length of animation
	 * @return {Number} The computed value for the current animation frame
	 */
    easeIn: function (t, b, c, d) {
    	return c*(t/=d)*t + b;
    },

    /**
	 * Begins quickly and decelerates towards end.
	 * 
	 * @method easeOut
	 * @param {Number}
	 *            t Time value used to compute current value
	 * @param {Number}
	 *            b Starting value
	 * @param {Number}
	 *            c Delta between start and end values
	 * @param {Number}
	 *            d Total length of animation
	 * @return {Number} The computed value for the current animation frame
	 */
    easeOut: function (t, b, c, d) {
    	return -c *(t/=d)*(t-2) + b;
    },
    
    /**
	 * Begins slowly and decelerates towards end.
	 * 
	 * @method easeBoth
	 * @param {Number}
	 *            t Time value used to compute current value
	 * @param {Number}
	 *            b Starting value
	 * @param {Number}
	 *            c Delta between start and end values
	 * @param {Number}
	 *            d Total length of animation
	 * @return {Number} The computed value for the current animation frame
	 */
    easeBoth: function (t, b, c, d) {
    	if ((t/=d/2) < 1) {
            return c/2*t*t + b;
        }
        
    	return -c/2 * ((--t)*(t-2) - 1) + b;
    },
    
    /**
	 * Begins slowly and accelerates towards end.
	 * 
	 * @method easeInStrong
	 * @param {Number}
	 *            t Time value used to compute current value
	 * @param {Number}
	 *            b Starting value
	 * @param {Number}
	 *            c Delta between start and end values
	 * @param {Number}
	 *            d Total length of animation
	 * @return {Number} The computed value for the current animation frame
	 */
    easeInStrong: function (t, b, c, d) {
    	return c*(t/=d)*t*t*t + b;
    },
    
    /**
	 * Begins quickly and decelerates towards end.
	 * 
	 * @method easeOutStrong
	 * @param {Number}
	 *            t Time value used to compute current value
	 * @param {Number}
	 *            b Starting value
	 * @param {Number}
	 *            c Delta between start and end values
	 * @param {Number}
	 *            d Total length of animation
	 * @return {Number} The computed value for the current animation frame
	 */
    easeOutStrong: function (t, b, c, d) {
    	return -c * ((t=t/d-1)*t*t*t - 1) + b;
    },
    
    /**
	 * Begins slowly and decelerates towards end.
	 * 
	 * @method easeBothStrong
	 * @param {Number}
	 *            t Time value used to compute current value
	 * @param {Number}
	 *            b Starting value
	 * @param {Number}
	 *            c Delta between start and end values
	 * @param {Number}
	 *            d Total length of animation
	 * @return {Number} The computed value for the current animation frame
	 */
    easeBothStrong: function (t, b, c, d) {
    	if ((t/=d/2) < 1) {
            return c/2*t*t*t*t + b;
        }
        
    	return -c/2 * ((t-=2)*t*t*t - 2) + b;
    },

    /**
	 * Snap in elastic effect.
	 * 
	 * @method elasticIn
	 * @param {Number}
	 *            t Time value used to compute current value
	 * @param {Number}
	 *            b Starting value
	 * @param {Number}
	 *            c Delta between start and end values
	 * @param {Number}
	 *            d Total length of animation
	 * @param {Number}
	 *            a Amplitude (optional)
	 * @param {Number}
	 *            p Period (optional)
	 * @return {Number} The computed value for the current animation frame
	 */

    elasticIn: function (t, b, c, d, a, p) {
    	if (t == 0) {
            return b;
        }
        if ( (t /= d) == 1 ) {
            return b+c;
        }
        if (!p) {
            p=d*.3;
        }
        
    	if (!a || a < Math.abs(c)) {
            a = c; 
            var s = p/4;
        }
    	else {
            var s = p/(2*Math.PI) * Math.asin (c/a);
        }
        
    	return -(a*Math.pow(2,10*(t-=1)) * Math.sin( (t*d-s)*(2*Math.PI)/p )) + b;
    },

    /**
	 * Snap out elastic effect.
	 * 
	 * @method elasticOut
	 * @param {Number}
	 *            t Time value used to compute current value
	 * @param {Number}
	 *            b Starting value
	 * @param {Number}
	 *            c Delta between start and end values
	 * @param {Number}
	 *            d Total length of animation
	 * @param {Number}
	 *            a Amplitude (optional)
	 * @param {Number}
	 *            p Period (optional)
	 * @return {Number} The computed value for the current animation frame
	 */
    elasticOut: function (t, b, c, d, a, p) {
    	if (t == 0) {
            return b;
        }
        if ( (t /= d) == 1 ) {
            return b+c;
        }
        if (!p) {
            p=d*.3;
        }
        
    	if (!a || a < Math.abs(c)) {
            a = c;
            var s = p / 4;
        }
    	else {
            var s = p/(2*Math.PI) * Math.asin (c/a);
        }
        
    	return a*Math.pow(2,-10*t) * Math.sin( (t*d-s)*(2*Math.PI)/p ) + c + b;
    },
    
    /**
	 * Snap both elastic effect.
	 * 
	 * @method elasticBoth
	 * @param {Number}
	 *            t Time value used to compute current value
	 * @param {Number}
	 *            b Starting value
	 * @param {Number}
	 *            c Delta between start and end values
	 * @param {Number}
	 *            d Total length of animation
	 * @param {Number}
	 *            a Amplitude (optional)
	 * @param {Number}
	 *            p Period (optional)
	 * @return {Number} The computed value for the current animation frame
	 */
    elasticBoth: function (t, b, c, d, a, p) {
    	if (t == 0) {
            return b;
        }
        
        if ( (t /= d/2) == 2 ) {
            return b+c;
        }
        
        if (!p) {
            p = d*(.3*1.5);
        }
        
    	if ( !a || a < Math.abs(c) ) {
            a = c; 
            var s = p/4;
        }
    	else {
            var s = p/(2*Math.PI) * Math.asin (c/a);
        }
        
    	if (t < 1) {
            return -.5*(a*Math.pow(2,10*(t-=1)) * 
                    Math.sin( (t*d-s)*(2*Math.PI)/p )) + b;
        }
    	return a*Math.pow(2,-10*(t-=1)) * 
                Math.sin( (t*d-s)*(2*Math.PI)/p )*.5 + c + b;
    },


    /**
	 * Backtracks slightly, then reverses direction and moves to end.
	 * 
	 * @method backIn
	 * @param {Number}
	 *            t Time value used to compute current value
	 * @param {Number}
	 *            b Starting value
	 * @param {Number}
	 *            c Delta between start and end values
	 * @param {Number}
	 *            d Total length of animation
	 * @param {Number}
	 *            s Overshoot (optional)
	 * @return {Number} The computed value for the current animation frame
	 */
    backIn: function (t, b, c, d, s) {
    	if (typeof s == 'undefined') {
            s = 1.70158;
        }
    	return c*(t/=d)*t*((s+1)*t - s) + b;
    },

    /**
	 * Overshoots end, then reverses and comes back to end.
	 * 
	 * @method backOut
	 * @param {Number}
	 *            t Time value used to compute current value
	 * @param {Number}
	 *            b Starting value
	 * @param {Number}
	 *            c Delta between start and end values
	 * @param {Number}
	 *            d Total length of animation
	 * @param {Number}
	 *            s Overshoot (optional)
	 * @return {Number} The computed value for the current animation frame
	 */
    backOut: function (t, b, c, d, s) {
    	if (typeof s == 'undefined') {
            s = 1.70158;
        }
    	return c*((t=t/d-1)*t*((s+1)*t + s) + 1) + b;
    },
    
    /**
	 * Backtracks slightly, then reverses direction, overshoots end, then
	 * reverses and comes back to end.
	 * 
	 * @method backBoth
	 * @param {Number}
	 *            t Time value used to compute current value
	 * @param {Number}
	 *            b Starting value
	 * @param {Number}
	 *            c Delta between start and end values
	 * @param {Number}
	 *            d Total length of animation
	 * @param {Number}
	 *            s Overshoot (optional)
	 * @return {Number} The computed value for the current animation frame
	 */
    backBoth: function (t, b, c, d, s) {
    	if (typeof s == 'undefined') {
            s = 1.70158; 
        }
        
    	if ((t /= d/2 ) < 1) {
            return c/2*(t*t*(((s*=(1.525))+1)*t - s)) + b;
        }
    	return c/2*((t-=2)*t*(((s*=(1.525))+1)*t + s) + 2) + b;
    },

    /**
	 * Bounce off of start.
	 * 
	 * @method bounceIn
	 * @param {Number}
	 *            t Time value used to compute current value
	 * @param {Number}
	 *            b Starting value
	 * @param {Number}
	 *            c Delta between start and end values
	 * @param {Number}
	 *            d Total length of animation
	 * @return {Number} The computed value for the current animation frame
	 */
    bounceIn: function (t, b, c, d) {
    	return c - YAHOO.util.Easing.bounceOut(d-t, 0, c, d) + b;
    },
    
    /**
	 * Bounces off end.
	 * 
	 * @method bounceOut
	 * @param {Number}
	 *            t Time value used to compute current value
	 * @param {Number}
	 *            b Starting value
	 * @param {Number}
	 *            c Delta between start and end values
	 * @param {Number}
	 *            d Total length of animation
	 * @return {Number} The computed value for the current animation frame
	 */
    bounceOut: function (t, b, c, d) {
    	if ((t/=d) < (1/2.75)) {
    		return c*(7.5625*t*t) + b;
    	} else if (t < (2/2.75)) {
    		return c*(7.5625*(t-=(1.5/2.75))*t + .75) + b;
    	} else if (t < (2.5/2.75)) {
    		return c*(7.5625*(t-=(2.25/2.75))*t + .9375) + b;
    	}
        return c*(7.5625*(t-=(2.625/2.75))*t + .984375) + b;
    },
    
    /**
	 * Bounces off start and end.
	 * 
	 * @method bounceBoth
	 * @param {Number}
	 *            t Time value used to compute current value
	 * @param {Number}
	 *            b Starting value
	 * @param {Number}
	 *            c Delta between start and end values
	 * @param {Number}
	 *            d Total length of animation
	 * @return {Number} The computed value for the current animation frame
	 */
    bounceBoth: function (t, b, c, d) {
    	if (t < d/2) {
            return YAHOO.util.Easing.bounceIn(t*2, 0, c, d) * .5 + b;
        }
    	return YAHOO.util.Easing.bounceOut(t*2-d, 0, c, d) * .5 + c*.5 + b;
    }
};

(function() {
/**
 * Anim subclass for moving elements along a path defined by the "points" member
 * of "attributes". All "points" are arrays with x, y coordinates.
 * <p>
 * Usage:
 * <code>var myAnim = new YAHOO.util.Motion(el, { points: { to: [800, 800] } }, 1, YAHOO.util.Easing.easeOut);</code>
 * </p>
 * 
 * @class Motion
 * @namespace YAHOO.util
 * @requires YAHOO.util.Anim
 * @requires YAHOO.util.AnimMgr
 * @requires YAHOO.util.Easing
 * @requires YAHOO.util.Bezier
 * @requires YAHOO.util.Dom
 * @requires YAHOO.util.Event
 * @requires YAHOO.util.CustomEvent
 * @constructor
 * @extends YAHOO.util.ColorAnim
 * @param {String |
 *            HTMLElement} el Reference to the element that will be animated
 * @param {Object}
 *            attributes The attribute(s) to be animated. Each attribute is an
 *            object with at minimum a "to" or "by" member defined. Additional
 *            optional members are "from" (defaults to current value), "units"
 *            (defaults to "px"). All attribute names use camelCase.
 * @param {Number}
 *            duration (optional, defaults to 1 second) Length of animation
 *            (frames or seconds), defaults to time-based
 * @param {Function}
 *            method (optional, defaults to YAHOO.util.Easing.easeNone) Computes
 *            the values that are applied to the attributes per frame (generally
 *            a YAHOO.util.Easing method)
 */
    var Motion = function(el, attributes, duration,  method) {
        if (el) { // dont break existing subclasses not using YAHOO.extend
            Motion.superclass.constructor.call(this, el, attributes, duration, method);
        }
    };


    Motion.NAME = 'Motion';

    // shorthand
    var Y = YAHOO.util;
    YAHOO.extend(Motion, Y.ColorAnim);
    
    var superclass = Motion.superclass;
    var proto = Motion.prototype;

    proto.patterns.points = /^points$/i;
    
    proto.setAttribute = function(attr, val, unit) {
        if (  this.patterns.points.test(attr) ) {
            unit = unit || 'px';
            superclass.setAttribute.call(this, 'left', val[0], unit);
            superclass.setAttribute.call(this, 'top', val[1], unit);
        } else {
            superclass.setAttribute.call(this, attr, val, unit);
        }
    };

    proto.getAttribute = function(attr) {
        if (  this.patterns.points.test(attr) ) {
            var val = [
                superclass.getAttribute.call(this, 'left'),
                superclass.getAttribute.call(this, 'top')
            ];
        } else {
            val = superclass.getAttribute.call(this, attr);
        }

        return val;
    };

    proto.doMethod = function(attr, start, end) {
        var val = null;

        if ( this.patterns.points.test(attr) ) {
            var t = this.method(this.currentFrame, 0, 100, this.totalFrames) / 100;				
            val = Y.Bezier.getPosition(this.runtimeAttributes[attr], t);
        } else {
            val = superclass.doMethod.call(this, attr, start, end);
        }
        return val;
    };

    proto.setRuntimeAttribute = function(attr) {
        if ( this.patterns.points.test(attr) ) {
            var el = this.getEl();
            var attributes = this.attributes;
            var start;
            var control = attributes['points']['control'] || [];
            var end;
            var i, len;
            
            if (control.length > 0 && !(control[0] instanceof Array) ) { // could
																			// be
																			// single
																			// point
																			// or
																			// array
																			// of
																			// points
                control = [control];
            } else { // break reference to attributes.points.control
                var tmp = []; 
                for (i = 0, len = control.length; i< len; ++i) {
                    tmp[i] = control[i];
                }
                control = tmp;
            }

            if (Y.Dom.getStyle(el, 'position') == 'static') { // default to
																// relative
                Y.Dom.setStyle(el, 'position', 'relative');
            }
    
            if ( isset(attributes['points']['from']) ) {
                Y.Dom.setXY(el, attributes['points']['from']); // set position
																// to from point
            } 
            else { Y.Dom.setXY( el, Y.Dom.getXY(el) ); } // set it to current
															// position
            
            start = this.getAttribute('points'); // get actual top & left
            
            // TO beats BY, per SMIL 2.1 spec
            if ( isset(attributes['points']['to']) ) {
                end = translateValues.call(this, attributes['points']['to'], start);
                
                var pageXY = Y.Dom.getXY(this.getEl());
                for (i = 0, len = control.length; i < len; ++i) {
                    control[i] = translateValues.call(this, control[i], start);
                }

                
            } else if ( isset(attributes['points']['by']) ) {
                end = [ start[0] + attributes['points']['by'][0], start[1] + attributes['points']['by'][1] ];
                
                for (i = 0, len = control.length; i < len; ++i) {
                    control[i] = [ start[0] + control[i][0], start[1] + control[i][1] ];
                }
            }

            this.runtimeAttributes[attr] = [start];
            
            if (control.length > 0) {
                this.runtimeAttributes[attr] = this.runtimeAttributes[attr].concat(control); 
            }

            this.runtimeAttributes[attr][this.runtimeAttributes[attr].length] = end;
        }
        else {
            superclass.setRuntimeAttribute.call(this, attr);
        }
    };
    
    var translateValues = function(val, start) {
        var pageXY = Y.Dom.getXY(this.getEl());
        val = [ val[0] - pageXY[0] + start[0], val[1] - pageXY[1] + start[1] ];

        return val; 
    };
    
    var isset = function(prop) {
        return (typeof prop !== 'undefined');
    };

    Y.Motion = Motion;
})();
(function() {
/**
 * Anim subclass for scrolling elements to a position defined by the "scroll"
 * member of "attributes". All "scroll" members are arrays with x, y scroll
 * positions.
 * <p>
 * Usage:
 * <code>var myAnim = new YAHOO.util.Scroll(el, { scroll: { to: [0, 800] } }, 1, YAHOO.util.Easing.easeOut);</code>
 * </p>
 * 
 * @class Scroll
 * @namespace YAHOO.util
 * @requires YAHOO.util.Anim
 * @requires YAHOO.util.AnimMgr
 * @requires YAHOO.util.Easing
 * @requires YAHOO.util.Bezier
 * @requires YAHOO.util.Dom
 * @requires YAHOO.util.Event
 * @requires YAHOO.util.CustomEvent
 * @extends YAHOO.util.ColorAnim
 * @constructor
 * @param {String
 *            or HTMLElement} el Reference to the element that will be animated
 * @param {Object}
 *            attributes The attribute(s) to be animated. Each attribute is an
 *            object with at minimum a "to" or "by" member defined. Additional
 *            optional members are "from" (defaults to current value), "units"
 *            (defaults to "px"). All attribute names use camelCase.
 * @param {Number}
 *            duration (optional, defaults to 1 second) Length of animation
 *            (frames or seconds), defaults to time-based
 * @param {Function}
 *            method (optional, defaults to YAHOO.util.Easing.easeNone) Computes
 *            the values that are applied to the attributes per frame (generally
 *            a YAHOO.util.Easing method)
 */
    var Scroll = function(el, attributes, duration,  method) {
        if (el) { // dont break existing subclasses not using YAHOO.extend
            Scroll.superclass.constructor.call(this, el, attributes, duration, method);
        }
    };

    Scroll.NAME = 'Scroll';

    // shorthand
    var Y = YAHOO.util;
    YAHOO.extend(Scroll, Y.ColorAnim);
    
    var superclass = Scroll.superclass;
    var proto = Scroll.prototype;

    proto.doMethod = function(attr, start, end) {
        var val = null;
    
        if (attr == 'scroll') {
            val = [
                this.method(this.currentFrame, start[0], end[0] - start[0], this.totalFrames),
                this.method(this.currentFrame, start[1], end[1] - start[1], this.totalFrames)
            ];
            
        } else {
            val = superclass.doMethod.call(this, attr, start, end);
        }
        return val;
    };

    proto.getAttribute = function(attr) {
        var val = null;
        var el = this.getEl();
        
        if (attr == 'scroll') {
            val = [ el.scrollLeft, el.scrollTop ];
        } else {
            val = superclass.getAttribute.call(this, attr);
        }
        
        return val;
    };

    proto.setAttribute = function(attr, val, unit) {
        var el = this.getEl();
        
        if (attr == 'scroll') {
            el.scrollLeft = val[0];
            el.scrollTop = val[1];
        } else {
            superclass.setAttribute.call(this, attr, val, unit);
        }
    };

    Y.Scroll = Scroll;
})();
YAHOO.register("animation", YAHOO.util.Anim, {version: "2.9.0", build: "2800"});
/*
 * Copyright (c) 2011, Yahoo! Inc. All rights reserved. Code licensed under the
 * BSD License: http://developer.yahoo.com/yui/license.html version: 2.9.0
 */
/**
 * Provides Attribute configurations.
 * 
 * @namespace YAHOO.util
 * @class Attribute
 * @constructor
 * @param hash
 *            {Object} The intial Attribute.
 * @param {YAHOO.util.AttributeProvider}
 *            The owner of the Attribute instance.
 */

YAHOO.util.Attribute = function(hash, owner) {
    if (owner) { 
        this.owner = owner;
        this.configure(hash, true);
    }
};

YAHOO.util.Attribute.INVALID_VALUE = {};

YAHOO.util.Attribute.prototype = {
    /**
	 * The name of the attribute.
	 * 
	 * @property name
	 * @type String
	 */
    name: undefined,
    
    /**
	 * The value of the attribute.
	 * 
	 * @property value
	 * @type String
	 */
    value: null,
    
    /**
	 * The owner of the attribute.
	 * 
	 * @property owner
	 * @type YAHOO.util.AttributeProvider
	 */
    owner: null,
    
    /**
	 * Whether or not the attribute is read only.
	 * 
	 * @property readOnly
	 * @type Boolean
	 */
    readOnly: false,
    
    /**
	 * Whether or not the attribute can only be written once.
	 * 
	 * @property writeOnce
	 * @type Boolean
	 */
    writeOnce: false,

    /**
	 * The attribute's initial configuration.
	 * 
	 * @private
	 * @property _initialConfig
	 * @type Object
	 */
    _initialConfig: null,
    
    /**
	 * Whether or not the attribute's value has been set.
	 * 
	 * @private
	 * @property _written
	 * @type Boolean
	 */
    _written: false,
    
    /**
	 * A function to call when setting the attribute's value. The method
	 * receives the new value as the first arg and the attribute name as the 2nd
	 * 
	 * @property method
	 * @type Function
	 */
    method: null,
    
    /**
	 * The function to use when setting the attribute's value. The setter
	 * receives the new value as the first arg and the attribute name as the 2nd
	 * The return value of the setter replaces the value passed to set().
	 * 
	 * @property setter
	 * @type Function
	 */
    setter: null,
    
    /**
	 * The function to use when getting the attribute's value. The getter
	 * receives the new value as the first arg and the attribute name as the 2nd
	 * The return value of the getter will be used as the return from get().
	 * 
	 * @property getter
	 * @type Function
	 */
    getter: null,

    /**
	 * The validator to use when setting the attribute's value.
	 * 
	 * @property validator
	 * @type Function
	 * @return Boolean
	 */
    validator: null,
    
    /**
	 * Retrieves the current value of the attribute.
	 * 
	 * @method getValue
	 * @return {any} The current value of the attribute.
	 */
    getValue: function() {
        var val = this.value;

        if (this.getter) {
            val = this.getter.call(this.owner, this.name, val);
        }

        return val;
    },
    
    /**
	 * Sets the value of the attribute and fires beforeChange and change events.
	 * 
	 * @method setValue
	 * @param {Any}
	 *            value The value to apply to the attribute.
	 * @param {Boolean}
	 *            silent If true the change events will not be fired.
	 * @return {Boolean} Whether or not the value was set.
	 */
    setValue: function(value, silent) {
        var beforeRetVal,
            owner = this.owner,
            name = this.name,
            invalidValue = YAHOO.util.Attribute.INVALID_VALUE,
        
            event = {
                type: name, 
                prevValue: this.getValue(),
                newValue: value
        };
        
        if (this.readOnly || ( this.writeOnce && this._written) ) {
            return false; // write not allowed
        }
        
        if (this.validator && !this.validator.call(owner, value) ) {
            return false; // invalid value
        }

        if (!silent) {
            beforeRetVal = owner.fireBeforeChangeEvent(event);
            if (beforeRetVal === false) {
                return false;
            }
        }

        if (this.setter) {
            value = this.setter.call(owner, value, this.name);
            if (value === undefined) {
            }

            if (value === invalidValue) {
                return false;
            }
        }
        
        if (this.method) {
            if (this.method.call(owner, value, this.name) === invalidValue) {
                return false; 
            }
        }
        
        this.value = value; // TODO: set before calling setter/method?
        this._written = true;
        
        event.type = name;
        
        if (!silent) {
            this.owner.fireChangeEvent(event);
        }
        
        return true;
    },
    
    /**
	 * Allows for configuring the Attribute's properties.
	 * 
	 * @method configure
	 * @param {Object}
	 *            map A key-value map of Attribute properties.
	 * @param {Boolean}
	 *            init Whether or not this should become the initial config.
	 */
    configure: function(map, init) {
        map = map || {};

        if (init) {
            this._written = false; // reset writeOnce
        }

        this._initialConfig = this._initialConfig || {};
        
        for (var key in map) {
            if ( map.hasOwnProperty(key) ) {
                this[key] = map[key];
                if (init) {
                    this._initialConfig[key] = map[key];
                }
            }
        }
    },
    
    /**
	 * Resets the value to the initial config value.
	 * 
	 * @method resetValue
	 * @return {Boolean} Whether or not the value was set.
	 */
    resetValue: function() {
        return this.setValue(this._initialConfig.value);
    },
    
    /**
	 * Resets the attribute config to the initial config state.
	 * 
	 * @method resetConfig
	 */
    resetConfig: function() {
        this.configure(this._initialConfig, true);
    },
    
    /**
	 * Resets the value to the current value. Useful when values may have gotten
	 * out of sync with actual properties.
	 * 
	 * @method refresh
	 * @return {Boolean} Whether or not the value was set.
	 */
    refresh: function(silent) {
        this.setValue(this.value, silent);
    }
};

(function() {
    var Lang = YAHOO.util.Lang;

    /*
	 * Copyright (c) 2006, Yahoo! Inc. All rights reserved. Code licensed under
	 * the BSD License: http://developer.yahoo.net/yui/license.txt
	 */
    
    /**
	 * Provides and manages YAHOO.util.Attribute instances
	 * 
	 * @namespace YAHOO.util
	 * @class AttributeProvider
	 * @uses YAHOO.util.EventProvider
	 */
    YAHOO.util.AttributeProvider = function() {};

    YAHOO.util.AttributeProvider.prototype = {
        
        /**
		 * A key-value map of Attribute configurations
		 * 
		 * @property _configs
		 * @protected (may be used by subclasses and augmentors)
		 * @private
		 * @type {Object}
		 */
        _configs: null,
        /**
		 * Returns the current value of the attribute.
		 * 
		 * @method get
		 * @param {String}
		 *            key The attribute whose value will be returned.
		 * @return {Any} The current value of the attribute.
		 */
        get: function(key){
            this._configs = this._configs || {};
            var config = this._configs[key];
            
            if (!config || !this._configs.hasOwnProperty(key)) {
                return null;
            }
            
            return config.getValue();
        },
        
        /**
		 * Sets the value of a config.
		 * 
		 * @method set
		 * @param {String}
		 *            key The name of the attribute
		 * @param {Any}
		 *            value The value to apply to the attribute
		 * @param {Boolean}
		 *            silent Whether or not to suppress change events
		 * @return {Boolean} Whether or not the value was set.
		 */
        set: function(key, value, silent){
            this._configs = this._configs || {};
            var config = this._configs[key];
            
            if (!config) {
                return false;
            }
            
            return config.setValue(value, silent);
        },
    
        /**
		 * Returns an array of attribute names.
		 * 
		 * @method getAttributeKeys
		 * @return {Array} An array of attribute names.
		 */
        getAttributeKeys: function(){
            this._configs = this._configs;
            var keys = [], key;

            for (key in this._configs) {
                if ( Lang.hasOwnProperty(this._configs, key) && 
                        !Lang.isUndefined(this._configs[key]) ) {
                    keys[keys.length] = key;
                }
            }
            
            return keys;
        },
        
        /**
		 * Sets multiple attribute values.
		 * 
		 * @method setAttributes
		 * @param {Object}
		 *            map A key-value map of attributes
		 * @param {Boolean}
		 *            silent Whether or not to suppress change events
		 */
        setAttributes: function(map, silent){
            for (var key in map) {
                if ( Lang.hasOwnProperty(map, key) ) {
                    this.set(key, map[key], silent);
                }
            }
        },
    
        /**
		 * Resets the specified attribute's value to its initial value.
		 * 
		 * @method resetValue
		 * @param {String}
		 *            key The name of the attribute
		 * @param {Boolean}
		 *            silent Whether or not to suppress change events
		 * @return {Boolean} Whether or not the value was set
		 */
        resetValue: function(key, silent){
            this._configs = this._configs || {};
            if (this._configs[key]) {
                this.set(key, this._configs[key]._initialConfig.value, silent);
                return true;
            }
            return false;
        },
    
        /**
		 * Sets the attribute's value to its current value.
		 * 
		 * @method refresh
		 * @param {String |
		 *            Array} key The attribute(s) to refresh
		 * @param {Boolean}
		 *            silent Whether or not to suppress change events
		 */
        refresh: function(key, silent) {
            this._configs = this._configs || {};
            var configs = this._configs;
            
            key = ( ( Lang.isString(key) ) ? [key] : key ) || 
                    this.getAttributeKeys();
            
            for (var i = 0, len = key.length; i < len; ++i) { 
                if (configs.hasOwnProperty(key[i])) {
                    this._configs[key[i]].refresh(silent);
                }
            }
        },
    
        /**
		 * Adds an Attribute to the AttributeProvider instance.
		 * 
		 * @method register
		 * @param {String}
		 *            key The attribute's name
		 * @param {Object}
		 *            map A key-value map containing the attribute's properties.
		 * @deprecated Use setAttributeConfig
		 */
        register: function(key, map) {
            this.setAttributeConfig(key, map);
        },
        
        
        /**
		 * Returns the attribute's properties.
		 * 
		 * @method getAttributeConfig
		 * @param {String}
		 *            key The attribute's name
		 * @private
		 * @return {object} A key-value map containing all of the attribute's
		 *         properties.
		 */
        getAttributeConfig: function(key) {
            this._configs = this._configs || {};
            var config = this._configs[key] || {};
            var map = {}; // returning a copy to prevent overrides
            
            for (key in config) {
                if ( Lang.hasOwnProperty(config, key) ) {
                    map[key] = config[key];
                }
            }
    
            return map;
        },
        
        /**
		 * Sets or updates an Attribute instance's properties.
		 * 
		 * @method setAttributeConfig
		 * @param {String}
		 *            key The attribute's name.
		 * @param {Object}
		 *            map A key-value map of attribute properties
		 * @param {Boolean}
		 *            init Whether or not this should become the intial config.
		 */
        setAttributeConfig: function(key, map, init) {
            this._configs = this._configs || {};
            map = map || {};
            if (!this._configs[key]) {
                map.name = key;
                this._configs[key] = this.createAttribute(map);
            } else {
                this._configs[key].configure(map, init);
            }
        },
        
        /**
		 * Sets or updates an Attribute instance's properties.
		 * 
		 * @method configureAttribute
		 * @param {String}
		 *            key The attribute's name.
		 * @param {Object}
		 *            map A key-value map of attribute properties
		 * @param {Boolean}
		 *            init Whether or not this should become the intial config.
		 * @deprecated Use setAttributeConfig
		 */
        configureAttribute: function(key, map, init) {
            this.setAttributeConfig(key, map, init);
        },
        
        /**
		 * Resets an attribute to its intial configuration.
		 * 
		 * @method resetAttributeConfig
		 * @param {String}
		 *            key The attribute's name.
		 * @private
		 */
        resetAttributeConfig: function(key){
            this._configs = this._configs || {};
            this._configs[key].resetConfig();
        },
        
        // wrapper for EventProvider.subscribe
        // to create events on the fly
        subscribe: function(type, callback) {
            this._events = this._events || {};

            if ( !(type in this._events) ) {
                this._events[type] = this.createEvent(type);
            }

            YAHOO.util.EventProvider.prototype.subscribe.apply(this, arguments);
        },

        on: function() {
            this.subscribe.apply(this, arguments);
        },

        addListener: function() {
            this.subscribe.apply(this, arguments);
        },

        /**
		 * Fires the attribute's beforeChange event.
		 * 
		 * @method fireBeforeChangeEvent
		 * @param {String}
		 *            key The attribute's name.
		 * @param {Obj}
		 *            e The event object to pass to handlers.
		 */
        fireBeforeChangeEvent: function(e) {
            var type = 'before';
            type += e.type.charAt(0).toUpperCase() + e.type.substr(1) + 'Change';
            e.type = type;
            return this.fireEvent(e.type, e);
        },
        
        /**
		 * Fires the attribute's change event.
		 * 
		 * @method fireChangeEvent
		 * @param {String}
		 *            key The attribute's name.
		 * @param {Obj}
		 *            e The event object to pass to the handlers.
		 */
        fireChangeEvent: function(e) {
            e.type += 'Change';
            return this.fireEvent(e.type, e);
        },

        createAttribute: function(map) {
            return new YAHOO.util.Attribute(map, this);
        }
    };
    
    YAHOO.augment(YAHOO.util.AttributeProvider, YAHOO.util.EventProvider);
})();

(function() {
// internal shorthand
var Dom = YAHOO.util.Dom,
    AttributeProvider = YAHOO.util.AttributeProvider,
	specialTypes = {
		mouseenter: true,
		mouseleave: true
	};

/**
 * Element provides an wrapper object to simplify adding event listeners, using
 * dom methods, and managing attributes.
 * 
 * @module element
 * @namespace YAHOO.util
 * @requires yahoo, dom, event
 */

/**
 * Element provides an wrapper object to simplify adding event listeners, using
 * dom methods, and managing attributes.
 * 
 * @class Element
 * @uses YAHOO.util.AttributeProvider
 * @constructor
 * @param el
 *            {HTMLElement | String} The html element that represents the
 *            Element.
 * @param {Object}
 *            map A key-value map of initial config names and values
 */
var Element = function(el, map) {
    this.init.apply(this, arguments);
};

Element.DOM_EVENTS = {
    'click': true,
    'dblclick': true,
    'keydown': true,
    'keypress': true,
    'keyup': true,
    'mousedown': true,
    'mousemove': true,
    'mouseout': true, 
    'mouseover': true, 
    'mouseup': true,
    'mouseenter': true, 
    'mouseleave': true,
    'focus': true,
    'blur': true,
    'submit': true,
    'change': true
};

Element.prototype = {
    /**
	 * Dom events supported by the Element instance.
	 * 
	 * @property DOM_EVENTS
	 * @type Object
	 */
    DOM_EVENTS: null,

    DEFAULT_HTML_SETTER: function(value, key) {
        var el = this.get('element');
        
        if (el) {
            el[key] = value;
        }

		return value;

    },

    DEFAULT_HTML_GETTER: function(key) {
        var el = this.get('element'),
            val;

        if (el) {
            val = el[key];
        }

        return val;
    },

    /**
	 * Wrapper for HTMLElement method.
	 * 
	 * @method appendChild
	 * @param {YAHOO.util.Element ||
	 *            HTMLElement} child The element to append.
	 * @return {HTMLElement} The appended DOM element.
	 */
    appendChild: function(child) {
        child = child.get ? child.get('element') : child;
        return this.get('element').appendChild(child);
    },
    
    /**
	 * Wrapper for HTMLElement method.
	 * 
	 * @method getElementsByTagName
	 * @param {String}
	 *            tag The tagName to collect
	 * @return {HTMLCollection} A collection of DOM elements.
	 */
    getElementsByTagName: function(tag) {
        return this.get('element').getElementsByTagName(tag);
    },
    
    /**
	 * Wrapper for HTMLElement method.
	 * 
	 * @method hasChildNodes
	 * @return {Boolean} Whether or not the element has childNodes
	 */
    hasChildNodes: function() {
        return this.get('element').hasChildNodes();
    },
    
    /**
	 * Wrapper for HTMLElement method.
	 * 
	 * @method insertBefore
	 * @param {HTMLElement}
	 *            element The HTMLElement to insert
	 * @param {HTMLElement}
	 *            before The HTMLElement to insert the element before.
	 * @return {HTMLElement} The inserted DOM element.
	 */
    insertBefore: function(element, before) {
        element = element.get ? element.get('element') : element;
        before = (before && before.get) ? before.get('element') : before;
        
        return this.get('element').insertBefore(element, before);
    },
    
    /**
	 * Wrapper for HTMLElement method.
	 * 
	 * @method removeChild
	 * @param {HTMLElement}
	 *            child The HTMLElement to remove
	 * @return {HTMLElement} The removed DOM element.
	 */
    removeChild: function(child) {
        child = child.get ? child.get('element') : child;
        return this.get('element').removeChild(child);
    },
    
    /**
	 * Wrapper for HTMLElement method.
	 * 
	 * @method replaceChild
	 * @param {HTMLElement}
	 *            newNode The HTMLElement to insert
	 * @param {HTMLElement}
	 *            oldNode The HTMLElement to replace
	 * @return {HTMLElement} The replaced DOM element.
	 */
    replaceChild: function(newNode, oldNode) {
        newNode = newNode.get ? newNode.get('element') : newNode;
        oldNode = oldNode.get ? oldNode.get('element') : oldNode;
        return this.get('element').replaceChild(newNode, oldNode);
    },

    
    /**
	 * Registers Element specific attributes.
	 * 
	 * @method initAttributes
	 * @param {Object}
	 *            map A key-value map of initial attribute configs
	 */
    initAttributes: function(map) {
    },

    /**
	 * Adds a listener for the given event. These may be DOM or customEvent
	 * listeners. Any event that is fired via fireEvent can be listened for. All
	 * handlers receive an event object.
	 * 
	 * @method addListener
	 * @param {String}
	 *            type The name of the event to listen for
	 * @param {Function}
	 *            fn The handler to call when the event fires
	 * @param {Any}
	 *            obj A variable to pass to the handler
	 * @param {Object}
	 *            scope The object to use for the scope of the handler
	 */
    addListener: function(type, fn, obj, scope) {

        scope = scope || this;

        var Event = YAHOO.util.Event,
			el = this.get('element') || this.get('id'),
        	self = this;


		if (specialTypes[type] && !Event._createMouseDelegate) {
	        return false;	
		}


        if (!this._events[type]) { // create on the fly

            if (el && this.DOM_EVENTS[type]) {
				Event.on(el, type, function(e, matchedEl) {

					// Supplement IE with target, currentTarget relatedTarget

	                if (e.srcElement && !e.target) { 
	                    e.target = e.srcElement;
	                }

					if ((e.toElement && !e.relatedTarget) || (e.fromElement && !e.relatedTarget)) {
						e.relatedTarget = Event.getRelatedTarget(e);
					}
					
					if (!e.currentTarget) {
						e.currentTarget = el;
					}

					// Note: matchedEl el is passed back for delegated listeners
		            self.fireEvent(type, e, matchedEl);

		        }, obj, scope);
            }
            this.createEvent(type, {scope: this});
        }
        
        return YAHOO.util.EventProvider.prototype.subscribe.apply(this, arguments); // notify
																					// via
																					// customEvent
    },


    /**
	 * Alias for addListener
	 * 
	 * @method on
	 * @param {String}
	 *            type The name of the event to listen for
	 * @param {Function}
	 *            fn The function call when the event fires
	 * @param {Any}
	 *            obj A variable to pass to the handler
	 * @param {Object}
	 *            scope The object to use for the scope of the handler
	 */
    on: function() {
        return this.addListener.apply(this, arguments);
    },
    
    /**
	 * Alias for addListener
	 * 
	 * @method subscribe
	 * @param {String}
	 *            type The name of the event to listen for
	 * @param {Function}
	 *            fn The function call when the event fires
	 * @param {Any}
	 *            obj A variable to pass to the handler
	 * @param {Object}
	 *            scope The object to use for the scope of the handler
	 */
    subscribe: function() {
        return this.addListener.apply(this, arguments);
    },
    
    /**
	 * Remove an event listener
	 * 
	 * @method removeListener
	 * @param {String}
	 *            type The name of the event to listen for
	 * @param {Function}
	 *            fn The function call when the event fires
	 */
    removeListener: function(type, fn) {
        return this.unsubscribe.apply(this, arguments);
    },
    
    /**
	 * Wrapper for Dom method.
	 * 
	 * @method addClass
	 * @param {String}
	 *            className The className to add
	 */
    addClass: function(className) {
        Dom.addClass(this.get('element'), className);
    },
    
    /**
	 * Wrapper for Dom method.
	 * 
	 * @method getElementsByClassName
	 * @param {String}
	 *            className The className to collect
	 * @param {String}
	 *            tag (optional) The tag to use in conjunction with class name
	 * @return {Array} Array of HTMLElements
	 */
    getElementsByClassName: function(className, tag) {
        return Dom.getElementsByClassName(className, tag,
                this.get('element') );
    },
    
    /**
	 * Wrapper for Dom method.
	 * 
	 * @method hasClass
	 * @param {String}
	 *            className The className to add
	 * @return {Boolean} Whether or not the element has the class name
	 */
    hasClass: function(className) {
        return Dom.hasClass(this.get('element'), className); 
    },
    
    /**
	 * Wrapper for Dom method.
	 * 
	 * @method removeClass
	 * @param {String}
	 *            className The className to remove
	 */
    removeClass: function(className) {
        return Dom.removeClass(this.get('element'), className);
    },
    
    /**
	 * Wrapper for Dom method.
	 * 
	 * @method replaceClass
	 * @param {String}
	 *            oldClassName The className to replace
	 * @param {String}
	 *            newClassName The className to add
	 */
    replaceClass: function(oldClassName, newClassName) {
        return Dom.replaceClass(this.get('element'), 
                oldClassName, newClassName);
    },
    
    /**
	 * Wrapper for Dom method.
	 * 
	 * @method setStyle
	 * @param {String}
	 *            property The style property to set
	 * @param {String}
	 *            value The value to apply to the style property
	 */
    setStyle: function(property, value) {
        return Dom.setStyle(this.get('element'),  property, value); // TODO:
																	// always
																	// queuing?
    },
    
    /**
	 * Wrapper for Dom method.
	 * 
	 * @method getStyle
	 * @param {String}
	 *            property The style property to retrieve
	 * @return {String} The current value of the property
	 */
    getStyle: function(property) {
        return Dom.getStyle(this.get('element'),  property);
    },
    
    /**
	 * Apply any queued set calls.
	 * 
	 * @method fireQueue
	 */
    fireQueue: function() {
        var queue = this._queue;
        for (var i = 0, len = queue.length; i < len; ++i) {
            this[queue[i][0]].apply(this, queue[i][1]);
        }
    },
    
    /**
	 * Appends the HTMLElement into either the supplied parentNode.
	 * 
	 * @method appendTo
	 * @param {HTMLElement |
	 *            Element} parentNode The node to append to
	 * @param {HTMLElement |
	 *            Element} before An optional node to insert before
	 * @return {HTMLElement} The appended DOM element.
	 */
    appendTo: function(parent, before) {
        parent = (parent.get) ?  parent.get('element') : Dom.get(parent);
        
        this.fireEvent('beforeAppendTo', {
            type: 'beforeAppendTo',
            target: parent
        });
        
        
        before = (before && before.get) ? 
                before.get('element') : Dom.get(before);
        var element = this.get('element');
        
        if (!element) {
            return false;
        }
        
        if (!parent) {
            return false;
        }
        
        if (element.parent != parent) {
            if (before) {
                parent.insertBefore(element, before);
            } else {
                parent.appendChild(element);
            }
        }
        
        
        this.fireEvent('appendTo', {
            type: 'appendTo',
            target: parent
        });

        return element;
    },
    
    get: function(key) {
        var configs = this._configs || {},
            el = configs.element; // avoid loop due to 'element'

        if (el && !configs[key] && !YAHOO.lang.isUndefined(el.value[key]) ) {
            this._setHTMLAttrConfig(key);
        }

        return AttributeProvider.prototype.get.call(this, key);
    },

    setAttributes: function(map, silent) {
        // set based on configOrder
        var done = {},
            configOrder = this._configOrder;

        // set based on configOrder
        for (var i = 0, len = configOrder.length; i < len; ++i) {
            if (map[configOrder[i]] !== undefined) {
                done[configOrder[i]] = true;
                this.set(configOrder[i], map[configOrder[i]], silent);
            }
        }

        // unconfigured (e.g. Dom attributes)
        for (var att in map) {
            if (map.hasOwnProperty(att) && !done[att]) {
                this.set(att, map[att], silent);
            }
        }
    },

    set: function(key, value, silent) {
        var el = this.get('element');
        if (!el) {
            this._queue[this._queue.length] = ['set', arguments];
            if (this._configs[key]) {
                this._configs[key].value = value; // so "get" works while
													// queueing
            
            }
            return;
        }
        
        // set it on the element if not configured and is an HTML attribute
        if ( !this._configs[key] && !YAHOO.lang.isUndefined(el[key]) ) {
            this._setHTMLAttrConfig(key);
        }

        return AttributeProvider.prototype.set.apply(this, arguments);
    },
    
    setAttributeConfig: function(key, map, init) {
        this._configOrder.push(key);
        AttributeProvider.prototype.setAttributeConfig.apply(this, arguments);
    },

    createEvent: function(type, config) {
        this._events[type] = true;
        return AttributeProvider.prototype.createEvent.apply(this, arguments);
    },
    
    init: function(el, attr) {
        this._initElement(el, attr); 
    },

    destroy: function() {
        var el = this.get('element');
        YAHOO.util.Event.purgeElement(el, true); // purge DOM listeners
													// recursively
        this.unsubscribeAll(); // unsubscribe all custom events

        if (el && el.parentNode) {
            el.parentNode.removeChild(el); // pull from the DOM
        }

        // revert initial configs
        this._queue = [];
        this._events = {};
        this._configs = {};
        this._configOrder = []; 
    },

    _initElement: function(el, attr) {
        this._queue = this._queue || [];
        this._events = this._events || {};
        this._configs = this._configs || {};
        this._configOrder = []; 
        attr = attr || {};
        attr.element = attr.element || el || null;

        var isReady = false;  // to determine when to init HTMLElement and
								// content

        var DOM_EVENTS = Element.DOM_EVENTS;
        this.DOM_EVENTS = this.DOM_EVENTS || {};

        for (var event in DOM_EVENTS) {
            if (DOM_EVENTS.hasOwnProperty(event)) {
                this.DOM_EVENTS[event] = DOM_EVENTS[event];
            }
        }

        if (typeof attr.element === 'string') { // register ID for get() access
            this._setHTMLAttrConfig('id', { value: attr.element });
        }

        if (Dom.get(attr.element)) {
            isReady = true;
            this._initHTMLElement(attr);
            this._initContent(attr);
        }

        YAHOO.util.Event.onAvailable(attr.element, function() {
            if (!isReady) { // otherwise already done
                this._initHTMLElement(attr);
            }

            this.fireEvent('available', { type: 'available', target: Dom.get(attr.element) });  
        }, this, true);
        
        YAHOO.util.Event.onContentReady(attr.element, function() {
            if (!isReady) { // otherwise already done
                this._initContent(attr);
            }
            this.fireEvent('contentReady', { type: 'contentReady', target: Dom.get(attr.element) });  
        }, this, true);
    },

    _initHTMLElement: function(attr) {
        /**
		 * The HTMLElement the Element instance refers to.
		 * 
		 * @attribute element
		 * @type HTMLElement
		 */
        this.setAttributeConfig('element', {
            value: Dom.get(attr.element),
            readOnly: true
         });
    },

    _initContent: function(attr) {
        this.initAttributes(attr);
        this.setAttributes(attr, true);
        this.fireQueue();

    },

    /**
	 * Sets the value of the property and fires beforeChange and change events.
	 * 
	 * @private
	 * @method _setHTMLAttrConfig
	 * @param {YAHOO.util.Element}
	 *            element The Element instance to register the config to.
	 * @param {String}
	 *            key The name of the config to register
	 * @param {Object}
	 *            map A key-value map of the config's params
	 */
    _setHTMLAttrConfig: function(key, map) {
        var el = this.get('element');
        map = map || {};
        map.name = key;

        map.setter = map.setter || this.DEFAULT_HTML_SETTER;
        map.getter = map.getter || this.DEFAULT_HTML_GETTER;

        map.value = map.value || el[key];
        this._configs[key] = new YAHOO.util.Attribute(map, this);
    }
};

/**
 * Fires when the Element's HTMLElement can be retrieved by Id.
 * <p>
 * See: <a href="#addListener">Element.addListener</a>
 * </p>
 * <p>
 * <strong>Event fields:</strong><br>
 * <code>&lt;String&gt; type</code> available<br>
 * <code>&lt;HTMLElement&gt;
 * target</code> the HTMLElement bound to this
 * Element instance<br>
 * <p>
 * <strong>Usage:</strong><br>
 * <code>var handler = function(e) {var target = e.target};<br>
 * myTabs.addListener('available', handler);</code>
 * </p>
 * 
 * @event available
 */
 
/**
 * Fires when the Element's HTMLElement subtree is rendered.
 * <p>
 * See: <a href="#addListener">Element.addListener</a>
 * </p>
 * <p>
 * <strong>Event fields:</strong><br>
 * <code>&lt;String&gt; type</code> contentReady<br>
 * <code>&lt;HTMLElement&gt;
 * target</code> the HTMLElement bound to this
 * Element instance<br>
 * <p>
 * <strong>Usage:</strong><br>
 * <code>var handler = function(e) {var target = e.target};<br>
 * myTabs.addListener('contentReady', handler);</code>
 * </p>
 * 
 * @event contentReady
 */

/**
 * Fires before the Element is appended to another Element.
 * <p>
 * See: <a href="#addListener">Element.addListener</a>
 * </p>
 * <p>
 * <strong>Event fields:</strong><br>
 * <code>&lt;String&gt; type</code> beforeAppendTo<br>
 * <code>&lt;HTMLElement/Element&gt;
 * target</code> the HTMLElement/Element
 * being appended to
 * <p>
 * <strong>Usage:</strong><br>
 * <code>var handler = function(e) {var target = e.target};<br>
 * myTabs.addListener('beforeAppendTo', handler);</code>
 * </p>
 * 
 * @event beforeAppendTo
 */

/**
 * Fires after the Element is appended to another Element.
 * <p>
 * See: <a href="#addListener">Element.addListener</a>
 * </p>
 * <p>
 * <strong>Event fields:</strong><br>
 * <code>&lt;String&gt; type</code> appendTo<br>
 * <code>&lt;HTMLElement/Element&gt;
 * target</code> the HTMLElement/Element
 * being appended to
 * <p>
 * <strong>Usage:</strong><br>
 * <code>var handler = function(e) {var target = e.target};<br>
 * myTabs.addListener('appendTo', handler);</code>
 * </p>
 * 
 * @event appendTo
 */

YAHOO.augment(Element, AttributeProvider);
YAHOO.util.Element = Element;
})();

YAHOO.register("element", YAHOO.util.Element, {version: "2.9.0", build: "2800"});
/*
 * Copyright (c) 2011, Yahoo! Inc. All rights reserved. Code licensed under the
 * BSD License: http://developer.yahoo.com/yui/license.html version: 2.9.0
 */
/**
 * The drag and drop utility provides a framework for building drag and drop
 * applications. In addition to enabling drag and drop for specific elements,
 * the drag and drop elements are tracked by the manager class, and the
 * interactions between the various elements are tracked during the drag and the
 * implementing code is notified about these important moments.
 * 
 * @module dragdrop
 * @title Drag and Drop
 * @requires yahoo,dom,event
 * @namespace YAHOO.util
 */

// Only load the library once. Rewriting the manager class would orphan
// existing drag and drop instances.
if (!YAHOO.util.DragDropMgr) {

/**
 * DragDropMgr is a singleton that tracks the element interaction for all
 * DragDrop items in the window. Generally, you will not call this class
 * directly, but it does have helper methods that could be useful in your
 * DragDrop implementations.
 * 
 * @class DragDropMgr
 * @static
 */
YAHOO.util.DragDropMgr = function() {

    var Event = YAHOO.util.Event,
        Dom = YAHOO.util.Dom;

    return {
        /**
		 * This property is used to turn on global use of the shim element on
		 * all DragDrop instances, defaults to false for backcompat. (Use:
		 * YAHOO.util.DDM.useShim = true)
		 * 
		 * @property useShim
		 * @type Boolean
		 * @static
		 */
        useShim: false,
        /**
		 * This property is used to determine if the shim is active over the
		 * screen, default false.
		 * 
		 * @private
		 * @property _shimActive
		 * @type Boolean
		 * @static
		 */
        _shimActive: false,
        /**
		 * This property is used when useShim is set on a DragDrop object to
		 * store the current state of DDM.useShim so it can be reset when a drag
		 * operation is done.
		 * 
		 * @private
		 * @property _shimState
		 * @type Boolean
		 * @static
		 */
        _shimState: false,
        /**
		 * This property is used when useShim is set to true, it will set the
		 * opacity on the shim to .5 for debugging. Use:
		 * (YAHOO.util.DDM._debugShim = true;)
		 * 
		 * @private
		 * @property _debugShim
		 * @type Boolean
		 * @static
		 */
        _debugShim: false,
        /**
		 * This method will create a shim element (giving it the id of
		 * yui-ddm-shim), it also attaches the mousemove and mouseup listeners
		 * to it and attaches a scroll listener on the window
		 * 
		 * @private
		 * @method _sizeShim
		 * @static
		 */
        _createShim: function() {
            var s = document.createElement('div');
            s.id = 'yui-ddm-shim';
            if (document.body.firstChild) {
                document.body.insertBefore(s, document.body.firstChild);
            } else {
                document.body.appendChild(s);
            }
            s.style.display = 'none';
            s.style.backgroundColor = 'red';
            s.style.position = 'absolute';
            s.style.zIndex = '99999';
            Dom.setStyle(s, 'opacity', '0');
            this._shim = s;
            Event.on(s, "mouseup",   this.handleMouseUp, this, true);
            Event.on(s, "mousemove", this.handleMouseMove, this, true);
            Event.on(window, 'scroll', this._sizeShim, this, true);
        },
        /**
		 * This method will size the shim, called from activate and on window
		 * scroll event
		 * 
		 * @private
		 * @method _sizeShim
		 * @static
		 */
        _sizeShim: function() {
            if (this._shimActive) {
                var s = this._shim;
                s.style.height = Dom.getDocumentHeight() + 'px';
                s.style.width = Dom.getDocumentWidth() + 'px';
                s.style.top = '0';
                s.style.left = '0';
            }
        },
        /**
		 * This method will create the shim element if needed, then show the
		 * shim element, size the element and set the _shimActive property to
		 * true
		 * 
		 * @private
		 * @method _activateShim
		 * @static
		 */
        _activateShim: function() {
            if (this.useShim) {
                if (!this._shim) {
                    this._createShim();
                }
                this._shimActive = true;
                var s = this._shim,
                    o = '0';
                if (this._debugShim) {
                    o = '.5';
                }
                Dom.setStyle(s, 'opacity', o);
                this._sizeShim();
                s.style.display = 'block';
            }
        },
        /**
		 * This method will hide the shim element and set the _shimActive
		 * property to false
		 * 
		 * @private
		 * @method _deactivateShim
		 * @static
		 */
        _deactivateShim: function() {
            this._shim.style.display = 'none';
            this._shimActive = false;
        },
        /**
		 * The HTML element created to use as a shim over the document to track
		 * mouse movements
		 * 
		 * @private
		 * @property _shim
		 * @type HTMLElement
		 * @static
		 */
        _shim: null,
        /**
		 * Two dimensional Array of registered DragDrop objects. The first
		 * dimension is the DragDrop item group, the second the DragDrop object.
		 * 
		 * @property ids
		 * @type {string: string}
		 * @private
		 * @static
		 */
        ids: {},

        /**
		 * Array of element ids defined as drag handles. Used to determine if
		 * the element that generated the mousedown event is actually the handle
		 * and not the html element itself.
		 * 
		 * @property handleIds
		 * @type {string: string}
		 * @private
		 * @static
		 */
        handleIds: {},

        /**
		 * the DragDrop object that is currently being dragged
		 * 
		 * @property dragCurrent
		 * @type DragDrop
		 * @private
		 * @static
		 */
        dragCurrent: null,

        /**
		 * the DragDrop object(s) that are being hovered over
		 * 
		 * @property dragOvers
		 * @type Array
		 * @private
		 * @static
		 */
        dragOvers: {},

        /**
		 * the X distance between the cursor and the object being dragged
		 * 
		 * @property deltaX
		 * @type int
		 * @private
		 * @static
		 */
        deltaX: 0,

        /**
		 * the Y distance between the cursor and the object being dragged
		 * 
		 * @property deltaY
		 * @type int
		 * @private
		 * @static
		 */
        deltaY: 0,

        /**
		 * Flag to determine if we should prevent the default behavior of the
		 * events we define. By default this is true, but this can be set to
		 * false if you need the default behavior (not recommended)
		 * 
		 * @property preventDefault
		 * @type boolean
		 * @static
		 */
        preventDefault: true,

        /**
		 * Flag to determine if we should stop the propagation of the events we
		 * generate. This is true by default but you may want to set it to false
		 * if the html element contains other features that require the mouse
		 * click.
		 * 
		 * @property stopPropagation
		 * @type boolean
		 * @static
		 */
        stopPropagation: true,

        /**
		 * Internal flag that is set to true when drag and drop has been
		 * initialized
		 * 
		 * @property initialized
		 * @private
		 * @static
		 */
        initialized: false,

        /**
		 * All drag and drop can be disabled.
		 * 
		 * @property locked
		 * @private
		 * @static
		 */
        locked: false,

        /**
		 * Provides additional information about the the current set of
		 * interactions. Can be accessed from the event handlers. It contains
		 * the following properties:
		 * 
		 * out: onDragOut interactions enter: onDragEnter interactions over:
		 * onDragOver interactions drop: onDragDrop interactions point: The
		 * location of the cursor draggedRegion: The location of dragged element
		 * at the time of the interaction sourceRegion: The location of the
		 * source elemtn at the time of the interaction validDrop: boolean
		 * 
		 * @property interactionInfo
		 * @type object
		 * @static
		 */
        interactionInfo: null,

        /**
		 * Called the first time an element is registered.
		 * 
		 * @method init
		 * @private
		 * @static
		 */
        init: function() {
            this.initialized = true;
        },

        /**
		 * In point mode, drag and drop interaction is defined by the location
		 * of the cursor during the drag/drop
		 * 
		 * @property POINT
		 * @type int
		 * @static
		 * @final
		 */
        POINT: 0,

        /**
		 * In intersect mode, drag and drop interaction is defined by the cursor
		 * position or the amount of overlap of two or more drag and drop
		 * objects.
		 * 
		 * @property INTERSECT
		 * @type int
		 * @static
		 * @final
		 */
        INTERSECT: 1,

        /**
		 * In intersect mode, drag and drop interaction is defined only by the
		 * overlap of two or more drag and drop objects.
		 * 
		 * @property STRICT_INTERSECT
		 * @type int
		 * @static
		 * @final
		 */
        STRICT_INTERSECT: 2,

        /**
		 * The current drag and drop mode. Default: POINT
		 * 
		 * @property mode
		 * @type int
		 * @static
		 */
        mode: 0,

        /**
		 * Runs method on all drag and drop objects
		 * 
		 * @method _execOnAll
		 * @private
		 * @static
		 */
        _execOnAll: function(sMethod, args) {
            for (var i in this.ids) {
                for (var j in this.ids[i]) {
                    var oDD = this.ids[i][j];
                    if (! this.isTypeOfDD(oDD)) {
                        continue;
                    }
                    oDD[sMethod].apply(oDD, args);
                }
            }
        },

        /**
		 * Drag and drop initialization. Sets up the global event handlers
		 * 
		 * @method _onLoad
		 * @private
		 * @static
		 */
        _onLoad: function() {

            this.init();

            Event.on(document, "mouseup",   this.handleMouseUp, this, true);
            Event.on(document, "mousemove", this.handleMouseMove, this, true);
            Event.on(window,   "unload",    this._onUnload, this, true);
            Event.on(window,   "resize",    this._onResize, this, true);
            // Event.on(window, "mouseout", this._test);

        },

        /**
		 * Reset constraints on all drag and drop objs
		 * 
		 * @method _onResize
		 * @private
		 * @static
		 */
        _onResize: function(e) {
            this._execOnAll("resetConstraints", []);
        },

        /**
		 * Lock all drag and drop functionality
		 * 
		 * @method lock
		 * @static
		 */
        lock: function() { this.locked = true; },

        /**
		 * Unlock all drag and drop functionality
		 * 
		 * @method unlock
		 * @static
		 */
        unlock: function() { this.locked = false; },

        /**
		 * Is drag and drop locked?
		 * 
		 * @method isLocked
		 * @return {boolean} True if drag and drop is locked, false otherwise.
		 * @static
		 */
        isLocked: function() { return this.locked; },

        /**
		 * Location cache that is set for all drag drop objects when a drag is
		 * initiated, cleared when the drag is finished.
		 * 
		 * @property locationCache
		 * @private
		 * @static
		 */
        locationCache: {},

        /**
		 * Set useCache to false if you want to force object the lookup of each
		 * drag and drop linked element constantly during a drag.
		 * 
		 * @property useCache
		 * @type boolean
		 * @static
		 */
        useCache: true,

        /**
		 * The number of pixels that the mouse needs to move after the mousedown
		 * before the drag is initiated. Default=3;
		 * 
		 * @property clickPixelThresh
		 * @type int
		 * @static
		 */
        clickPixelThresh: 3,

        /**
		 * The number of milliseconds after the mousedown event to initiate the
		 * drag if we don't get a mouseup event. Default=1000
		 * 
		 * @property clickTimeThresh
		 * @type int
		 * @static
		 */
        clickTimeThresh: 1000,

        /**
		 * Flag that indicates that either the drag pixel threshold or the
		 * mousdown time threshold has been met
		 * 
		 * @property dragThreshMet
		 * @type boolean
		 * @private
		 * @static
		 */
        dragThreshMet: false,

        /**
		 * Timeout used for the click time threshold
		 * 
		 * @property clickTimeout
		 * @type Object
		 * @private
		 * @static
		 */
        clickTimeout: null,

        /**
		 * The X position of the mousedown event stored for later use when a
		 * drag threshold is met.
		 * 
		 * @property startX
		 * @type int
		 * @private
		 * @static
		 */
        startX: 0,

        /**
		 * The Y position of the mousedown event stored for later use when a
		 * drag threshold is met.
		 * 
		 * @property startY
		 * @type int
		 * @private
		 * @static
		 */
        startY: 0,

        /**
		 * Flag to determine if the drag event was fired from the click timeout
		 * and not the mouse move threshold.
		 * 
		 * @property fromTimeout
		 * @type boolean
		 * @private
		 * @static
		 */
        fromTimeout: false,

        /**
		 * Each DragDrop instance must be registered with the DragDropMgr. This
		 * is executed in DragDrop.init()
		 * 
		 * @method regDragDrop
		 * @param {DragDrop}
		 *            oDD the DragDrop object to register
		 * @param {String}
		 *            sGroup the name of the group this element belongs to
		 * @static
		 */
        regDragDrop: function(oDD, sGroup) {
            if (!this.initialized) { this.init(); }
            
            if (!this.ids[sGroup]) {
                this.ids[sGroup] = {};
            }
            this.ids[sGroup][oDD.id] = oDD;
        },

        /**
		 * Removes the supplied dd instance from the supplied group. Executed by
		 * DragDrop.removeFromGroup, so don't call this function directly.
		 * 
		 * @method removeDDFromGroup
		 * @private
		 * @static
		 */
        removeDDFromGroup: function(oDD, sGroup) {
            if (!this.ids[sGroup]) {
                this.ids[sGroup] = {};
            }

            var obj = this.ids[sGroup];
            if (obj && obj[oDD.id]) {
                delete obj[oDD.id];
            }
        },

        /**
		 * Unregisters a drag and drop item. This is executed in DragDrop.unreg,
		 * use that method instead of calling this directly.
		 * 
		 * @method _remove
		 * @private
		 * @static
		 */
        _remove: function(oDD) {
            for (var g in oDD.groups) {
                if (g) {
                    var item = this.ids[g];
                    if (item && item[oDD.id]) {
                        delete item[oDD.id];
                    }
                }
                
            }
            delete this.handleIds[oDD.id];
        },

        /**
		 * Each DragDrop handle element must be registered. This is done
		 * automatically when executing DragDrop.setHandleElId()
		 * 
		 * @method regHandle
		 * @param {String}
		 *            sDDId the DragDrop id this element is a handle for
		 * @param {String}
		 *            sHandleId the id of the element that is the drag handle
		 * @static
		 */
        regHandle: function(sDDId, sHandleId) {
            if (!this.handleIds[sDDId]) {
                this.handleIds[sDDId] = {};
            }
            this.handleIds[sDDId][sHandleId] = sHandleId;
        },

        /**
		 * Utility function to determine if a given element has been registered
		 * as a drag drop item.
		 * 
		 * @method isDragDrop
		 * @param {String}
		 *            id the element id to check
		 * @return {boolean} true if this element is a DragDrop item, false
		 *         otherwise
		 * @static
		 */
        isDragDrop: function(id) {
            return ( this.getDDById(id) ) ? true : false;
        },

        /**
		 * Returns the drag and drop instances that are in all groups the passed
		 * in instance belongs to.
		 * 
		 * @method getRelated
		 * @param {DragDrop}
		 *            p_oDD the obj to get related data for
		 * @param {boolean}
		 *            bTargetsOnly if true, only return targetable objs
		 * @return {DragDrop[]} the related instances
		 * @static
		 */
        getRelated: function(p_oDD, bTargetsOnly) {
            var oDDs = [];
            for (var i in p_oDD.groups) {
                for (var j in this.ids[i]) {
                    var dd = this.ids[i][j];
                    if (! this.isTypeOfDD(dd)) {
                        continue;
                    }
                    if (!bTargetsOnly || dd.isTarget) {
                        oDDs[oDDs.length] = dd;
                    }
                }
            }

            return oDDs;
        },

        /**
		 * Returns true if the specified dd target is a legal target for the
		 * specifice drag obj
		 * 
		 * @method isLegalTarget
		 * @param {DragDrop}
		 *            the drag obj
		 * @param {DragDrop}
		 *            the target
		 * @return {boolean} true if the target is a legal target for the dd obj
		 * @static
		 */
        isLegalTarget: function (oDD, oTargetDD) {
            var targets = this.getRelated(oDD, true);
            for (var i=0, len=targets.length;i<len;++i) {
                if (targets[i].id == oTargetDD.id) {
                    return true;
                }
            }

            return false;
        },

        /**
		 * My goal is to be able to transparently determine if an object is
		 * typeof DragDrop, and the exact subclass of DragDrop. typeof returns
		 * "object", oDD.constructor.toString() always returns "DragDrop" and
		 * not the name of the subclass. So for now it just evaluates a
		 * well-known variable in DragDrop.
		 * 
		 * @method isTypeOfDD
		 * @param {Object}
		 *            the object to evaluate
		 * @return {boolean} true if typeof oDD = DragDrop
		 * @static
		 */
        isTypeOfDD: function (oDD) {
            return (oDD && oDD.__ygDragDrop);
        },

        /**
		 * Utility function to determine if a given element has been registered
		 * as a drag drop handle for the given Drag Drop object.
		 * 
		 * @method isHandle
		 * @param {String}
		 *            id the element id to check
		 * @return {boolean} true if this element is a DragDrop handle, false
		 *         otherwise
		 * @static
		 */
        isHandle: function(sDDId, sHandleId) {
            return ( this.handleIds[sDDId] && 
                            this.handleIds[sDDId][sHandleId] );
        },

        /**
		 * Returns the DragDrop instance for a given id
		 * 
		 * @method getDDById
		 * @param {String}
		 *            id the id of the DragDrop object
		 * @return {DragDrop} the drag drop object, null if it is not found
		 * @static
		 */
        getDDById: function(id) {
            for (var i in this.ids) {
                if (this.ids[i][id]) {
                    return this.ids[i][id];
                }
            }
            return null;
        },

        /**
		 * Fired after a registered DragDrop object gets the mousedown event.
		 * Sets up the events required to track the object being dragged
		 * 
		 * @method handleMouseDown
		 * @param {Event}
		 *            e the event
		 * @param oDD
		 *            the DragDrop object being dragged
		 * @private
		 * @static
		 */
        handleMouseDown: function(e, oDD) {
            // this._activateShim();

            this.currentTarget = YAHOO.util.Event.getTarget(e);

            this.dragCurrent = oDD;

            var el = oDD.getEl();

            // track start position
            this.startX = YAHOO.util.Event.getPageX(e);
            this.startY = YAHOO.util.Event.getPageY(e);

            this.deltaX = this.startX - el.offsetLeft;
            this.deltaY = this.startY - el.offsetTop;

            this.dragThreshMet = false;

            this.clickTimeout = setTimeout( 
                    function() { 
                        var DDM = YAHOO.util.DDM;
                        DDM.startDrag(DDM.startX, DDM.startY);
                        DDM.fromTimeout = true;
                    }, 
                    this.clickTimeThresh );
        },

        /**
		 * Fired when either the drag pixel threshold or the mousedown hold time
		 * threshold has been met.
		 * 
		 * @method startDrag
		 * @param x
		 *            {int} the X position of the original mousedown
		 * @param y
		 *            {int} the Y position of the original mousedown
		 * @static
		 */
        startDrag: function(x, y) {
            if (this.dragCurrent && this.dragCurrent.useShim) {
                this._shimState = this.useShim;
                this.useShim = true;
            }
            this._activateShim();
            clearTimeout(this.clickTimeout);
            var dc = this.dragCurrent;
            if (dc && dc.events.b4StartDrag) {
                dc.b4StartDrag(x, y);
                dc.fireEvent('b4StartDragEvent', { x: x, y: y });
            }
            if (dc && dc.events.startDrag) {
                dc.startDrag(x, y);
                dc.fireEvent('startDragEvent', { x: x, y: y });
            }
            this.dragThreshMet = true;
        },

        /**
		 * Internal function to handle the mouseup event. Will be invoked from
		 * the context of the document.
		 * 
		 * @method handleMouseUp
		 * @param {Event}
		 *            e the event
		 * @private
		 * @static
		 */
        handleMouseUp: function(e) {
            if (this.dragCurrent) {
                clearTimeout(this.clickTimeout);

                if (this.dragThreshMet) {
                    if (this.fromTimeout) {
                        this.fromTimeout = false;
                        this.handleMouseMove(e);
                    }
                    this.fromTimeout = false;
                    this.fireEvents(e, true);
                } else {
                }

                this.stopDrag(e);

                this.stopEvent(e);
            }
        },

        /**
		 * Utility to stop event propagation and event default, if these
		 * features are turned on.
		 * 
		 * @method stopEvent
		 * @param {Event}
		 *            e the event as returned by this.getEvent()
		 * @static
		 */
        stopEvent: function(e) {
            if (this.stopPropagation) {
                YAHOO.util.Event.stopPropagation(e);
            }

            if (this.preventDefault) {
                YAHOO.util.Event.preventDefault(e);
            }
        },

        /**
		 * Ends the current drag, cleans up the state, and fires the endDrag and
		 * mouseUp events. Called internally when a mouseup is detected during
		 * the drag. Can be fired manually during the drag by passing either
		 * another event (such as the mousemove event received in onDrag) or a
		 * fake event with pageX and pageY defined (so that endDrag and
		 * onMouseUp have usable position data.). Alternatively, pass true for
		 * the silent parameter so that the endDrag and onMouseUp events are
		 * skipped (so no event data is needed.)
		 * 
		 * @method stopDrag
		 * @param {Event}
		 *            e the mouseup event, another event (or a fake event) with
		 *            pageX and pageY defined, or nothing if the silent
		 *            parameter is true
		 * @param {boolean}
		 *            silent skips the enddrag and mouseup events if true
		 * @static
		 */
        stopDrag: function(e, silent) {
            var dc = this.dragCurrent;
            // Fire the drag end event for the item that was dragged
            if (dc && !silent) {
                if (this.dragThreshMet) {
                    if (dc.events.b4EndDrag) {
                        dc.b4EndDrag(e);
                        dc.fireEvent('b4EndDragEvent', { e: e });
                    }
                    if (dc.events.endDrag) {
                        dc.endDrag(e);
                        dc.fireEvent('endDragEvent', { e: e });
                    }
                }
                if (dc.events.mouseUp) {
                    dc.onMouseUp(e);
                    dc.fireEvent('mouseUpEvent', { e: e });
                }
            }

            if (this._shimActive) {
                this._deactivateShim();
                if (this.dragCurrent && this.dragCurrent.useShim) {
                    this.useShim = this._shimState;
                    this._shimState = false;
                }
            }

            this.dragCurrent = null;
            this.dragOvers = {};
        },

        /**
		 * Internal function to handle the mousemove event. Will be invoked from
		 * the context of the html element.
		 * 
		 * @TODO figure out what we can do about mouse events lost when the user
		 *       drags objects beyond the window boundary. Currently we can
		 *       detect this in internet explorer by verifying that the mouse is
		 *       down during the mousemove event. Firefox doesn't give us the
		 *       button state on the mousemove event.
		 * @method handleMouseMove
		 * @param {Event}
		 *            e the event
		 * @private
		 * @static
		 */
        handleMouseMove: function(e) {

            var dc = this.dragCurrent;
            if (dc) {

                // var button = e.which || e.button;

                // check for IE < 9 mouseup outside of page boundary
                if (YAHOO.env.ua.ie && (YAHOO.env.ua.ie < 9) && !e.button) {
                    this.stopEvent(e);
                    return this.handleMouseUp(e);
                } else {
                    if (e.clientX < 0 || e.clientY < 0) {
                        // This will stop the element from leaving the viewport
						// in FF, Opera & Safari
                        // Not turned on yet
                        // this.stopEvent(e);
                        // return false;
                    }
                }

                if (!this.dragThreshMet) {
                    var diffX = Math.abs(this.startX - YAHOO.util.Event.getPageX(e));
                    var diffY = Math.abs(this.startY - YAHOO.util.Event.getPageY(e));
                    if (diffX > this.clickPixelThresh || 
                                diffY > this.clickPixelThresh) {
                        this.startDrag(this.startX, this.startY);
                    }
                }

                if (this.dragThreshMet) {
                    if (dc && dc.events.b4Drag) {
                        dc.b4Drag(e);
                        dc.fireEvent('b4DragEvent', { e: e});
                    }
                    if (dc && dc.events.drag) {
                        dc.onDrag(e);
                        dc.fireEvent('dragEvent', { e: e});
                    }
                    if (dc) {
                        this.fireEvents(e, false);
                    }
                }

                this.stopEvent(e);
            }
        },
        
        /**
		 * Iterates over all of the DragDrop elements to find ones we are
		 * hovering over or dropping on
		 * 
		 * @method fireEvents
		 * @param {Event}
		 *            e the event
		 * @param {boolean}
		 *            isDrop is this a drop op or a mouseover op?
		 * @private
		 * @static
		 */
        fireEvents: function(e, isDrop) {
            var dc = this.dragCurrent;

            // If the user did the mouse up outside of the window, we could
            // get here even though we have ended the drag.
            // If the config option dragOnly is true, bail out and don't fire
			// the events
            if (!dc || dc.isLocked() || dc.dragOnly) {
                return;
            }

            var x = YAHOO.util.Event.getPageX(e),
                y = YAHOO.util.Event.getPageY(e),
                pt = new YAHOO.util.Point(x,y),
                pos = dc.getTargetCoord(pt.x, pt.y),
                el = dc.getDragEl(),
                events = ['out', 'over', 'drop', 'enter'],
                curRegion = new YAHOO.util.Region( pos.y, 
                                               pos.x + el.offsetWidth,
                                               pos.y + el.offsetHeight, 
                                               pos.x ),
            
                oldOvers = [], // cache the previous dragOver array
                inGroupsObj  = {},
                b4Results = {},
                inGroups  = [],
                data = {
                    outEvts: [],
                    overEvts: [],
                    dropEvts: [],
                    enterEvts: []
                };


            // Check to see if the object(s) we were hovering over is no longer
            // being hovered over so we can fire the onDragOut event
            for (var i in this.dragOvers) {

                var ddo = this.dragOvers[i];

                if (! this.isTypeOfDD(ddo)) {
                    continue;
                }
                if (! this.isOverTarget(pt, ddo, this.mode, curRegion)) {
                    data.outEvts.push( ddo );
                }

                oldOvers[i] = true;
                delete this.dragOvers[i];
            }

            for (var sGroup in dc.groups) {
                
                if ("string" != typeof sGroup) {
                    continue;
                }

                for (i in this.ids[sGroup]) {
                    var oDD = this.ids[sGroup][i];
                    if (! this.isTypeOfDD(oDD)) {
                        continue;
                    }

                    if (oDD.isTarget && !oDD.isLocked() && oDD != dc) {
                        if (this.isOverTarget(pt, oDD, this.mode, curRegion)) {
                            inGroupsObj[sGroup] = true;
                            // look for drop interactions
                            if (isDrop) {
                                data.dropEvts.push( oDD );
                            // look for drag enter and drag over interactions
                            } else {

                                // initial drag over: dragEnter fires
                                if (!oldOvers[oDD.id]) {
                                    data.enterEvts.push( oDD );
                                // subsequent drag overs: dragOver fires
                                } else {
                                    data.overEvts.push( oDD );
                                }

                                this.dragOvers[oDD.id] = oDD;
                            }
                        }
                    }
                }
            }

            this.interactionInfo = {
                out:       data.outEvts,
                enter:     data.enterEvts,
                over:      data.overEvts,
                drop:      data.dropEvts,
                point:     pt,
                draggedRegion:    curRegion,
                sourceRegion: this.locationCache[dc.id],
                validDrop: isDrop
            };

            
            for (var inG in inGroupsObj) {
                inGroups.push(inG);
            }

            // notify about a drop that did not find a target
            if (isDrop && !data.dropEvts.length) {
                this.interactionInfo.validDrop = false;
                if (dc.events.invalidDrop) {
                    dc.onInvalidDrop(e);
                    dc.fireEvent('invalidDropEvent', { e: e });
                }
            }
            for (i = 0; i < events.length; i++) {
                var tmp = null;
                if (data[events[i] + 'Evts']) {
                    tmp = data[events[i] + 'Evts'];
                }
                if (tmp && tmp.length) {
                    var type = events[i].charAt(0).toUpperCase() + events[i].substr(1),
                        ev = 'onDrag' + type,
                        b4 = 'b4Drag' + type,
                        cev = 'drag' + type + 'Event',
                        check = 'drag' + type;
                    if (this.mode) {
                        if (dc.events[b4]) {
                            dc[b4](e, tmp, inGroups);
                            b4Results[ev] = dc.fireEvent(b4 + 'Event', { event: e, info: tmp, group: inGroups });
                            
                        }
                        if (dc.events[check] && (b4Results[ev] !== false)) {
                            dc[ev](e, tmp, inGroups);
                            dc.fireEvent(cev, { event: e, info: tmp, group: inGroups });
                        }
                    } else {
                        for (var b = 0, len = tmp.length; b < len; ++b) {
                            if (dc.events[b4]) {
                                dc[b4](e, tmp[b].id, inGroups[0]);
                                b4Results[ev] = dc.fireEvent(b4 + 'Event', { event: e, info: tmp[b].id, group: inGroups[0] });
                            }
                            if (dc.events[check] && (b4Results[ev] !== false)) {
                                dc[ev](e, tmp[b].id, inGroups[0]);
                                dc.fireEvent(cev, { event: e, info: tmp[b].id, group: inGroups[0] });
                            }
                        }
                    }
                }
            }
        },

        /**
		 * Helper function for getting the best match from the list of drag and
		 * drop objects returned by the drag and drop events when we are in
		 * INTERSECT mode. It returns either the first object that the cursor is
		 * over, or the object that has the greatest overlap with the dragged
		 * element.
		 * 
		 * @method getBestMatch
		 * @param {DragDrop[]}
		 *            dds The array of drag and drop objects targeted
		 * @return {DragDrop} The best single match
		 * @static
		 */
        getBestMatch: function(dds) {
            var winner = null;

            var len = dds.length;

            if (len == 1) {
                winner = dds[0];
            } else {
                // Loop through the targeted items
                for (var i=0; i<len; ++i) {
                    var dd = dds[i];
                    // If the cursor is over the object, it wins. If the
                    // cursor is over multiple matches, the first one we come
                    // to wins.
                    if (this.mode == this.INTERSECT && dd.cursorIsOver) {
                        winner = dd;
                        break;
                    // Otherwise the object with the most overlap wins
                    } else {
                        if (!winner || !winner.overlap || (dd.overlap &&
                            winner.overlap.getArea() < dd.overlap.getArea())) {
                            winner = dd;
                        }
                    }
                }
            }

            return winner;
        },

        /**
		 * Refreshes the cache of the top-left and bottom-right points of the
		 * drag and drop objects in the specified group(s). This is in the
		 * format that is stored in the drag and drop instance, so typical usage
		 * is: <code>
         * YAHOO.util.DragDropMgr.refreshCache(ddinstance.groups);
         * </code>
		 * Alternatively: <code>
         * YAHOO.util.DragDropMgr.refreshCache({group1:true, group2:true});
         * </code>
		 * 
		 * @TODO this really should be an indexed array. Alternatively this
		 *       method could accept both.
		 * @method refreshCache
		 * @param {Object}
		 *            groups an associative array of groups to refresh
		 * @static
		 */
        refreshCache: function(groups) {

            // refresh everything if group array is not provided
            var g = groups || this.ids;

            for (var sGroup in g) {
                if ("string" != typeof sGroup) {
                    continue;
                }
                for (var i in this.ids[sGroup]) {
                    var oDD = this.ids[sGroup][i];

                    if (this.isTypeOfDD(oDD)) {
                        var loc = this.getLocation(oDD);
                        if (loc) {
                            this.locationCache[oDD.id] = loc;
                        } else {
                            delete this.locationCache[oDD.id];
                        }
                    }
                }
            }
        },

        /**
		 * This checks to make sure an element exists and is in the DOM. The
		 * main purpose is to handle cases where innerHTML is used to remove
		 * drag and drop objects from the DOM. IE provides an 'unspecified
		 * error' when trying to access the offsetParent of such an element
		 * 
		 * @method verifyEl
		 * @param {HTMLElement}
		 *            el the element to check
		 * @return {boolean} true if the element looks usable
		 * @static
		 */
        verifyEl: function(el) {
            try {
                if (el) {
                    var parent = el.offsetParent;
                    if (parent) {
                        return true;
                    }
                }
            } catch(e) {
            }

            return false;
        },
        
        /**
		 * Returns a Region object containing the drag and drop element's
		 * position and size, including the padding configured for it
		 * 
		 * @method getLocation
		 * @param {DragDrop}
		 *            oDD the drag and drop object to get the location for
		 * @return {YAHOO.util.Region} a Region object representing the total
		 *         area the element occupies, including any padding the instance
		 *         is configured for.
		 * @static
		 */
        getLocation: function(oDD) {
            if (! this.isTypeOfDD(oDD)) {
                return null;
            }

            var el = oDD.getEl(), pos, x1, x2, y1, y2, t, r, b, l;

            try {
                pos= YAHOO.util.Dom.getXY(el);
            } catch (e) { }

            if (!pos) {
                return null;
            }

            x1 = pos[0];
            x2 = x1 + el.offsetWidth;
            y1 = pos[1];
            y2 = y1 + el.offsetHeight;

            t = y1 - oDD.padding[0];
            r = x2 + oDD.padding[1];
            b = y2 + oDD.padding[2];
            l = x1 - oDD.padding[3];

            return new YAHOO.util.Region( t, r, b, l );
        },

        /**
		 * Checks the cursor location to see if it over the target
		 * 
		 * @method isOverTarget
		 * @param {YAHOO.util.Point}
		 *            pt The point to evaluate
		 * @param {DragDrop}
		 *            oTarget the DragDrop object we are inspecting
		 * @param {boolean}
		 *            intersect true if we are in intersect mode
		 * @param {YAHOO.util.Region}
		 *            pre-cached location of the dragged element
		 * @return {boolean} true if the mouse is over the target
		 * @private
		 * @static
		 */
        isOverTarget: function(pt, oTarget, intersect, curRegion) {
            // use cache if available
            var loc = this.locationCache[oTarget.id];
            if (!loc || !this.useCache) {
                loc = this.getLocation(oTarget);
                this.locationCache[oTarget.id] = loc;

            }

            if (!loc) {
                return false;
            }

            oTarget.cursorIsOver = loc.contains( pt );

            // DragDrop is using this as a sanity check for the initial
			// mousedown
            // in this case we are done. In POINT mode, if the drag obj has no
            // contraints, we are done. Otherwise we need to evaluate the
            // region the target as occupies to determine if the dragged element
            // overlaps with it.
            
            var dc = this.dragCurrent;
            if (!dc || (!intersect && !dc.constrainX && !dc.constrainY)) {

                // if (oTarget.cursorIsOver) {
                // }
                return oTarget.cursorIsOver;
            }

            oTarget.overlap = null;


            // Get the current location of the drag element, this is the
            // location of the mouse event less the delta that represents
            // where the original mousedown happened on the element. We
            // need to consider constraints and ticks as well.

            if (!curRegion) {
                var pos = dc.getTargetCoord(pt.x, pt.y);
                var el = dc.getDragEl();
                curRegion = new YAHOO.util.Region( pos.y, 
                                                   pos.x + el.offsetWidth,
                                                   pos.y + el.offsetHeight, 
                                                   pos.x );
            }

            var overlap = curRegion.intersect(loc);

            if (overlap) {
                oTarget.overlap = overlap;
                return (intersect) ? true : oTarget.cursorIsOver;
            } else {
                return false;
            }
        },

        /**
		 * unload event handler
		 * 
		 * @method _onUnload
		 * @private
		 * @static
		 */
        _onUnload: function(e, me) {
            this.unregAll();
        },

        /**
		 * Cleans up the drag and drop events and objects.
		 * 
		 * @method unregAll
		 * @private
		 * @static
		 */
        unregAll: function() {

            if (this.dragCurrent) {
                this.stopDrag();
                this.dragCurrent = null;
            }

            this._execOnAll("unreg", []);

            // for (var i in this.elementCache) {
                // delete this.elementCache[i];
            // }
            // this.elementCache = {};

            this.ids = {};
        },

        /**
		 * A cache of DOM elements
		 * 
		 * @property elementCache
		 * @private
		 * @static
		 * @deprecated elements are not cached now
		 */
        elementCache: {},
        
        /**
		 * Get the wrapper for the DOM element specified
		 * 
		 * @method getElWrapper
		 * @param {String}
		 *            id the id of the element to get
		 * @return {YAHOO.util.DDM.ElementWrapper} the wrapped element
		 * @private
		 * @deprecated This wrapper isn't that useful
		 * @static
		 */
        getElWrapper: function(id) {
            var oWrapper = this.elementCache[id];
            if (!oWrapper || !oWrapper.el) {
                oWrapper = this.elementCache[id] = 
                    new this.ElementWrapper(YAHOO.util.Dom.get(id));
            }
            return oWrapper;
        },

        /**
		 * Returns the actual DOM element
		 * 
		 * @method getElement
		 * @param {String}
		 *            id the id of the elment to get
		 * @return {Object} The element
		 * @deprecated use YAHOO.util.Dom.get instead
		 * @static
		 */
        getElement: function(id) {
            return YAHOO.util.Dom.get(id);
        },
        
        /**
		 * Returns the style property for the DOM element (i.e.,
		 * document.getElById(id).style)
		 * 
		 * @method getCss
		 * @param {String}
		 *            id the id of the elment to get
		 * @return {Object} The style property of the element
		 * @deprecated use YAHOO.util.Dom instead
		 * @static
		 */
        getCss: function(id) {
            var el = YAHOO.util.Dom.get(id);
            return (el) ? el.style : null;
        },

        /**
		 * Inner class for cached elements
		 * 
		 * @class DragDropMgr.ElementWrapper
		 * @for DragDropMgr
		 * @private
		 * @deprecated
		 */
        ElementWrapper: function(el) {
                /**
				 * The element
				 * 
				 * @property el
				 */
                this.el = el || null;
                /**
				 * The element id
				 * 
				 * @property id
				 */
                this.id = this.el && el.id;
                /**
				 * A reference to the style property
				 * 
				 * @property css
				 */
                this.css = this.el && el.style;
            },

        /**
		 * Returns the X position of an html element
		 * 
		 * @method getPosX
		 * @param el
		 *            the element for which to get the position
		 * @return {int} the X coordinate
		 * @for DragDropMgr
		 * @deprecated use YAHOO.util.Dom.getX instead
		 * @static
		 */
        getPosX: function(el) {
            return YAHOO.util.Dom.getX(el);
        },

        /**
		 * Returns the Y position of an html element
		 * 
		 * @method getPosY
		 * @param el
		 *            the element for which to get the position
		 * @return {int} the Y coordinate
		 * @deprecated use YAHOO.util.Dom.getY instead
		 * @static
		 */
        getPosY: function(el) {
            return YAHOO.util.Dom.getY(el); 
        },

        /**
		 * Swap two nodes. In IE, we use the native method, for others we
		 * emulate the IE behavior
		 * 
		 * @method swapNode
		 * @param n1
		 *            the first node to swap
		 * @param n2
		 *            the other node to swap
		 * @static
		 */
        swapNode: function(n1, n2) {
            if (n1.swapNode) {
                n1.swapNode(n2);
            } else {
                var p = n2.parentNode;
                var s = n2.nextSibling;

                if (s == n1) {
                    p.insertBefore(n1, n2);
                } else if (n2 == n1.nextSibling) {
                    p.insertBefore(n2, n1);
                } else {
                    n1.parentNode.replaceChild(n2, n1);
                    p.insertBefore(n1, s);
                }
            }
        },

        /**
		 * Returns the current scroll position
		 * 
		 * @method getScroll
		 * @private
		 * @static
		 */
        getScroll: function () {
            var t, l, dde=document.documentElement, db=document.body;
            if (dde && (dde.scrollTop || dde.scrollLeft)) {
                t = dde.scrollTop;
                l = dde.scrollLeft;
            } else if (db) {
                t = db.scrollTop;
                l = db.scrollLeft;
            } else {
            }
            return { top: t, left: l };
        },

        /**
		 * Returns the specified element style property
		 * 
		 * @method getStyle
		 * @param {HTMLElement}
		 *            el the element
		 * @param {string}
		 *            styleProp the style property
		 * @return {string} The value of the style property
		 * @deprecated use YAHOO.util.Dom.getStyle
		 * @static
		 */
        getStyle: function(el, styleProp) {
            return YAHOO.util.Dom.getStyle(el, styleProp);
        },

        /**
		 * Gets the scrollTop
		 * 
		 * @method getScrollTop
		 * @return {int} the document's scrollTop
		 * @static
		 */
        getScrollTop: function () { return this.getScroll().top; },

        /**
		 * Gets the scrollLeft
		 * 
		 * @method getScrollLeft
		 * @return {int} the document's scrollTop
		 * @static
		 */
        getScrollLeft: function () { return this.getScroll().left; },

        /**
		 * Sets the x/y position of an element to the location of the target
		 * element.
		 * 
		 * @method moveToEl
		 * @param {HTMLElement}
		 *            moveEl The element to move
		 * @param {HTMLElement}
		 *            targetEl The position reference element
		 * @static
		 */
        moveToEl: function (moveEl, targetEl) {
            var aCoord = YAHOO.util.Dom.getXY(targetEl);
            YAHOO.util.Dom.setXY(moveEl, aCoord);
        },

        /**
		 * Gets the client height
		 * 
		 * @method getClientHeight
		 * @return {int} client height in px
		 * @deprecated use YAHOO.util.Dom.getViewportHeight instead
		 * @static
		 */
        getClientHeight: function() {
            return YAHOO.util.Dom.getViewportHeight();
        },

        /**
		 * Gets the client width
		 * 
		 * @method getClientWidth
		 * @return {int} client width in px
		 * @deprecated use YAHOO.util.Dom.getViewportWidth instead
		 * @static
		 */
        getClientWidth: function() {
            return YAHOO.util.Dom.getViewportWidth();
        },

        /**
		 * Numeric array sort function
		 * 
		 * @method numericSort
		 * @static
		 */
        numericSort: function(a, b) { return (a - b); },

        /**
		 * Internal counter
		 * 
		 * @property _timeoutCount
		 * @private
		 * @static
		 */
        _timeoutCount: 0,

        /**
		 * Trying to make the load order less important. Without this we get an
		 * error if this file is loaded before the Event Utility.
		 * 
		 * @method _addListeners
		 * @private
		 * @static
		 */
        _addListeners: function() {
            var DDM = YAHOO.util.DDM;
            if ( YAHOO.util.Event && document ) {
                DDM._onLoad();
            } else {
                if (DDM._timeoutCount > 2000) {
                } else {
                    setTimeout(DDM._addListeners, 10);
                    if (document && document.body) {
                        DDM._timeoutCount += 1;
                    }
                }
            }
        },

        /**
		 * Recursively searches the immediate parent and all child nodes for the
		 * handle element in order to determine wheter or not it was clicked.
		 * 
		 * @method handleWasClicked
		 * @param node
		 *            the html element to inspect
		 * @static
		 */
        handleWasClicked: function(node, id) {
            if (this.isHandle(id, node.id)) {
                return true;
            } else {
                // check to see if this is a text node child of the one we want
                var p = node.parentNode;

                while (p) {
                    if (this.isHandle(id, p.id)) {
                        return true;
                    } else {
                        p = p.parentNode;
                    }
                }
            }

            return false;
        }

    };

}();

// shorter alias, save a few bytes
YAHOO.util.DDM = YAHOO.util.DragDropMgr;
YAHOO.util.DDM._addListeners();

}

(function() {

var Event=YAHOO.util.Event; 
var Dom=YAHOO.util.Dom;

/**
 * Defines the interface and base operation of items that that can be dragged or
 * can be drop targets. It was designed to be extended, overriding the event
 * handlers for startDrag, onDrag, onDragOver, onDragOut. Up to three html
 * elements can be associated with a DragDrop instance:
 * <ul>
 * <li>linked element: the element that is passed into the constructor. This is
 * the element which defines the boundaries for interaction with other DragDrop
 * objects.</li>
 * <li>handle element(s): The drag operation only occurs if the element that
 * was clicked matches a handle element. By default this is the linked element,
 * but there are times that you will want only a portion of the linked element
 * to initiate the drag operation, and the setHandleElId() method provides a way
 * to define this.</li>
 * <li>drag element: this represents an the element that would be moved along
 * with the cursor during a drag operation. By default, this is the linked
 * element itself as in {@link YAHOO.util.DD}. setDragElId() lets you define a
 * separate element that would be moved, as in {@link YAHOO.util.DDProxy} </li>
 * </ul>
 * This class should not be instantiated until the onload event to ensure that
 * the associated elements are available. The following would define a DragDrop
 * obj that would interact with any other DragDrop obj in the "group1" group:
 * 
 * <pre>
 * dd = new YAHOO.util.DragDrop(&quot;div1&quot;, &quot;group1&quot;);
 * </pre>
 * 
 * Since none of the event handlers have been implemented, nothing would
 * actually happen if you were to run the code above. Normally you would
 * override this class or one of the default implementations, but you can also
 * override the methods you want on an instance of the class...
 * 
 * <pre>
 * dd.onDragDrop = function(e, id) {
 * 	alert(&quot;dd was dropped on &quot; + id);
 * }
 * </pre>
 * 
 * @namespace YAHOO.util
 * @class DragDrop
 * @constructor
 * @param {String}
 *            id of the element that is linked to this instance
 * @param {String}
 *            sGroup the group of related DragDrop objects
 * @param {object}
 *            config an object containing configurable attributes Valid
 *            properties for DragDrop: padding, isTarget, maintainOffset,
 *            primaryButtonOnly,
 */
YAHOO.util.DragDrop = function(id, sGroup, config) {
    if (id) {
        this.init(id, sGroup, config); 
    }
};

YAHOO.util.DragDrop.prototype = {
    /**
	 * An Object Literal containing the events that we will be using: mouseDown,
	 * b4MouseDown, mouseUp, b4StartDrag, startDrag, b4EndDrag, endDrag,
	 * mouseUp, drag, b4Drag, invalidDrop, b4DragOut, dragOut, dragEnter,
	 * b4DragOver, dragOver, b4DragDrop, dragDrop By setting any of these to
	 * false, then event will not be fired.
	 * 
	 * @property events
	 * @type object
	 */
    events: null,
    /**
	 * @method on
	 * @description Shortcut for EventProvider.subscribe, see <a
	 *              href="YAHOO.util.EventProvider.html#subscribe">YAHOO.util.EventProvider.subscribe</a>
	 */
    on: function() {
        this.subscribe.apply(this, arguments);
    },
    /**
	 * The id of the element associated with this object. This is what we refer
	 * to as the "linked element" because the size and position of this element
	 * is used to determine when the drag and drop objects have interacted.
	 * 
	 * @property id
	 * @type String
	 */
    id: null,

    /**
	 * Configuration attributes passed into the constructor
	 * 
	 * @property config
	 * @type object
	 */
    config: null,

    /**
	 * The id of the element that will be dragged. By default this is same as
	 * the linked element , but could be changed to another element. Ex:
	 * YAHOO.util.DDProxy
	 * 
	 * @property dragElId
	 * @type String
	 * @private
	 */
    dragElId: null, 

    /**
	 * the id of the element that initiates the drag operation. By default this
	 * is the linked element, but could be changed to be a child of this
	 * element. This lets us do things like only starting the drag when the
	 * header element within the linked html element is clicked.
	 * 
	 * @property handleElId
	 * @type String
	 * @private
	 */
    handleElId: null, 

    /**
	 * An associative array of HTML tags that will be ignored if clicked.
	 * 
	 * @property invalidHandleTypes
	 * @type {string: string}
	 */
    invalidHandleTypes: null, 

    /**
	 * An associative array of ids for elements that will be ignored if clicked
	 * 
	 * @property invalidHandleIds
	 * @type {string: string}
	 */
    invalidHandleIds: null, 

    /**
	 * An indexted array of css class names for elements that will be ignored if
	 * clicked.
	 * 
	 * @property invalidHandleClasses
	 * @type string[]
	 */
    invalidHandleClasses: null, 

    /**
	 * The linked element's absolute X position at the time the drag was started
	 * 
	 * @property startPageX
	 * @type int
	 * @private
	 */
    startPageX: 0,

    /**
	 * The linked element's absolute X position at the time the drag was started
	 * 
	 * @property startPageY
	 * @type int
	 * @private
	 */
    startPageY: 0,

    /**
	 * The group defines a logical collection of DragDrop objects that are
	 * related. Instances only get events when interacting with other DragDrop
	 * object in the same group. This lets us define multiple groups using a
	 * single DragDrop subclass if we want.
	 * 
	 * @property groups
	 * @type {string: string}
	 */
    groups: null,

    /**
	 * Individual drag/drop instances can be locked. This will prevent
	 * onmousedown start drag.
	 * 
	 * @property locked
	 * @type boolean
	 * @private
	 */
    locked: false,

    /**
	 * Lock this instance
	 * 
	 * @method lock
	 */
    lock: function() { this.locked = true; },

    /**
	 * Unlock this instace
	 * 
	 * @method unlock
	 */
    unlock: function() { this.locked = false; },

    /**
	 * By default, all instances can be a drop target. This can be disabled by
	 * setting isTarget to false.
	 * 
	 * @property isTarget
	 * @type boolean
	 */
    isTarget: true,

    /**
	 * The padding configured for this drag and drop object for calculating the
	 * drop zone intersection with this object.
	 * 
	 * @property padding
	 * @type int[]
	 */
    padding: null,
    /**
	 * If this flag is true, do not fire drop events. The element is a drag only
	 * element (for movement not dropping)
	 * 
	 * @property dragOnly
	 * @type Boolean
	 */
    dragOnly: false,

    /**
	 * If this flag is true, a shim will be placed over the screen/viewable area
	 * to track mouse events. Should help with dragging elements over iframes
	 * and other controls.
	 * 
	 * @property useShim
	 * @type Boolean
	 */
    useShim: false,

    /**
	 * Cached reference to the linked element
	 * 
	 * @property _domRef
	 * @private
	 */
    _domRef: null,

    /**
	 * Internal typeof flag
	 * 
	 * @property __ygDragDrop
	 * @private
	 */
    __ygDragDrop: true,

    /**
	 * Set to true when horizontal contraints are applied
	 * 
	 * @property constrainX
	 * @type boolean
	 * @private
	 */
    constrainX: false,

    /**
	 * Set to true when vertical contraints are applied
	 * 
	 * @property constrainY
	 * @type boolean
	 * @private
	 */
    constrainY: false,

    /**
	 * The left constraint
	 * 
	 * @property minX
	 * @type int
	 * @private
	 */
    minX: 0,

    /**
	 * The right constraint
	 * 
	 * @property maxX
	 * @type int
	 * @private
	 */
    maxX: 0,

    /**
	 * The up constraint
	 * 
	 * @property minY
	 * @type int
	 * @type int
	 * @private
	 */
    minY: 0,

    /**
	 * The down constraint
	 * 
	 * @property maxY
	 * @type int
	 * @private
	 */
    maxY: 0,

    /**
	 * The difference between the click position and the source element's
	 * location
	 * 
	 * @property deltaX
	 * @type int
	 * @private
	 */
    deltaX: 0,

    /**
	 * The difference between the click position and the source element's
	 * location
	 * 
	 * @property deltaY
	 * @type int
	 * @private
	 */
    deltaY: 0,

    /**
	 * Maintain offsets when we resetconstraints. Set to true when you want the
	 * position of the element relative to its parent to stay the same when the
	 * page changes
	 * 
	 * @property maintainOffset
	 * @type boolean
	 */
    maintainOffset: false,

    /**
	 * Array of pixel locations the element will snap to if we specified a
	 * horizontal graduation/interval. This array is generated automatically
	 * when you define a tick interval.
	 * 
	 * @property xTicks
	 * @type int[]
	 */
    xTicks: null,

    /**
	 * Array of pixel locations the element will snap to if we specified a
	 * vertical graduation/interval. This array is generated automatically when
	 * you define a tick interval.
	 * 
	 * @property yTicks
	 * @type int[]
	 */
    yTicks: null,

    /**
	 * By default the drag and drop instance will only respond to the primary
	 * button click (left button for a right-handed mouse). Set to true to allow
	 * drag and drop to start with any mouse click that is propogated by the
	 * browser
	 * 
	 * @property primaryButtonOnly
	 * @type boolean
	 */
    primaryButtonOnly: true,

    /**
	 * The availabe property is false until the linked dom element is
	 * accessible.
	 * 
	 * @property available
	 * @type boolean
	 */
    available: false,

    /**
	 * By default, drags can only be initiated if the mousedown occurs in the
	 * region the linked element is. This is done in part to work around a bug
	 * in some browsers that mis-report the mousedown if the previous mouseup
	 * happened outside of the window. This property is set to true if outer
	 * handles are defined.
	 * 
	 * @property hasOuterHandles
	 * @type boolean
	 * @default false
	 */
    hasOuterHandles: false,

    /**
	 * Property that is assigned to a drag and drop object when testing to see
	 * if it is being targeted by another dd object. This property can be used
	 * in intersect mode to help determine the focus of the mouse interaction.
	 * DDM.getBestMatch uses this property first to determine the closest match
	 * in INTERSECT mode when multiple targets are part of the same interaction.
	 * 
	 * @property cursorIsOver
	 * @type boolean
	 */
    cursorIsOver: false,

    /**
	 * Property that is assigned to a drag and drop object when testing to see
	 * if it is being targeted by another dd object. This is a region that
	 * represents the area the draggable element overlaps this target.
	 * DDM.getBestMatch uses this property to compare the size of the overlap to
	 * that of other targets in order to determine the closest match in
	 * INTERSECT mode when multiple targets are part of the same interaction.
	 * 
	 * @property overlap
	 * @type YAHOO.util.Region
	 */
    overlap: null,

    /**
	 * Code that executes immediately before the startDrag event
	 * 
	 * @method b4StartDrag
	 * @private
	 */
    b4StartDrag: function(x, y) { },

    /**
	 * Abstract method called after a drag/drop object is clicked and the drag
	 * or mousedown time thresholds have beeen met.
	 * 
	 * @method startDrag
	 * @param {int}
	 *            X click location
	 * @param {int}
	 *            Y click location
	 */
    startDrag: function(x, y) { /* override this */ },

    /**
	 * Code that executes immediately before the onDrag event
	 * 
	 * @method b4Drag
	 * @private
	 */
    b4Drag: function(e) { },

    /**
	 * Abstract method called during the onMouseMove event while dragging an
	 * object.
	 * 
	 * @method onDrag
	 * @param {Event}
	 *            e the mousemove event
	 */
    onDrag: function(e) { /* override this */ },

    /**
	 * Abstract method called when this element fist begins hovering over
	 * another DragDrop obj
	 * 
	 * @method onDragEnter
	 * @param {Event}
	 *            e the mousemove event
	 * @param {String|DragDrop[]}
	 *            id In POINT mode, the element id this is hovering over. In
	 *            INTERSECT mode, an array of one or more dragdrop items being
	 *            hovered over.
	 */
    onDragEnter: function(e, id) { /* override this */ },

    /**
	 * Code that executes immediately before the onDragOver event
	 * 
	 * @method b4DragOver
	 * @private
	 */
    b4DragOver: function(e) { },

    /**
	 * Abstract method called when this element is hovering over another
	 * DragDrop obj
	 * 
	 * @method onDragOver
	 * @param {Event}
	 *            e the mousemove event
	 * @param {String|DragDrop[]}
	 *            id In POINT mode, the element id this is hovering over. In
	 *            INTERSECT mode, an array of dd items being hovered over.
	 */
    onDragOver: function(e, id) { /* override this */ },

    /**
	 * Code that executes immediately before the onDragOut event
	 * 
	 * @method b4DragOut
	 * @private
	 */
    b4DragOut: function(e) { },

    /**
	 * Abstract method called when we are no longer hovering over an element
	 * 
	 * @method onDragOut
	 * @param {Event}
	 *            e the mousemove event
	 * @param {String|DragDrop[]}
	 *            id In POINT mode, the element id this was hovering over. In
	 *            INTERSECT mode, an array of dd items that the mouse is no
	 *            longer over.
	 */
    onDragOut: function(e, id) { /* override this */ },

    /**
	 * Code that executes immediately before the onDragDrop event
	 * 
	 * @method b4DragDrop
	 * @private
	 */
    b4DragDrop: function(e) { },

    /**
	 * Abstract method called when this item is dropped on another DragDrop obj
	 * 
	 * @method onDragDrop
	 * @param {Event}
	 *            e the mouseup event
	 * @param {String|DragDrop[]}
	 *            id In POINT mode, the element id this was dropped on. In
	 *            INTERSECT mode, an array of dd items this was dropped on.
	 */
    onDragDrop: function(e, id) { /* override this */ },

    /**
	 * Abstract method called when this item is dropped on an area with no drop
	 * target
	 * 
	 * @method onInvalidDrop
	 * @param {Event}
	 *            e the mouseup event
	 */
    onInvalidDrop: function(e) { /* override this */ },

    /**
	 * Code that executes immediately before the endDrag event
	 * 
	 * @method b4EndDrag
	 * @private
	 */
    b4EndDrag: function(e) { },

    /**
	 * Fired when we are done dragging the object
	 * 
	 * @method endDrag
	 * @param {Event}
	 *            e the mouseup event
	 */
    endDrag: function(e) { /* override this */ },

    /**
	 * Code executed immediately before the onMouseDown event
	 * 
	 * @method b4MouseDown
	 * @param {Event}
	 *            e the mousedown event
	 * @private
	 */
    b4MouseDown: function(e) {  },

    /**
	 * Event handler that fires when a drag/drop obj gets a mousedown
	 * 
	 * @method onMouseDown
	 * @param {Event}
	 *            e the mousedown event
	 */
    onMouseDown: function(e) { /* override this */ },

    /**
	 * Event handler that fires when a drag/drop obj gets a mouseup
	 * 
	 * @method onMouseUp
	 * @param {Event}
	 *            e the mouseup event
	 */
    onMouseUp: function(e) { /* override this */ },
   
    /**
	 * Override the onAvailable method to do what is needed after the initial
	 * position was determined.
	 * 
	 * @method onAvailable
	 */
    onAvailable: function () { 
    },

    /**
	 * Returns a reference to the linked element
	 * 
	 * @method getEl
	 * @return {HTMLElement} the html element
	 */
    getEl: function() { 
        if (!this._domRef) {
            this._domRef = Dom.get(this.id); 
        }

        return this._domRef;
    },

    /**
	 * Returns a reference to the actual element to drag. By default this is the
	 * same as the html element, but it can be assigned to another element. An
	 * example of this can be found in YAHOO.util.DDProxy
	 * 
	 * @method getDragEl
	 * @return {HTMLElement} the html element
	 */
    getDragEl: function() {
        return Dom.get(this.dragElId);
    },

    /**
	 * Sets up the DragDrop object. Must be called in the constructor of any
	 * YAHOO.util.DragDrop subclass
	 * 
	 * @method init
	 * @param id
	 *            the id of the linked element
	 * @param {String}
	 *            sGroup the group of related items
	 * @param {object}
	 *            config configuration attributes
	 */
    init: function(id, sGroup, config) {
        this.initTarget(id, sGroup, config);
        Event.on(this._domRef || this.id, "mousedown", 
                        this.handleMouseDown, this, true);

        // Event.on(this.id, "selectstart", Event.preventDefault);
        for (var i in this.events) {
            this.createEvent(i + 'Event');
        }
        
    },

    /**
	 * Initializes Targeting functionality only... the object does not get a
	 * mousedown handler.
	 * 
	 * @method initTarget
	 * @param id
	 *            the id of the linked element
	 * @param {String}
	 *            sGroup the group of related items
	 * @param {object}
	 *            config configuration attributes
	 */
    initTarget: function(id, sGroup, config) {

        // configuration attributes
        this.config = config || {};

        this.events = {};

        // create a local reference to the drag and drop manager
        this.DDM = YAHOO.util.DDM;

        // initialize the groups object
        this.groups = {};

        // assume that we have an element reference instead of an id if the
        // parameter is not a string
        if (typeof id !== "string") {
            this._domRef = id;
            id = Dom.generateId(id);
        }

        // set the id
        this.id = id;

        // add to an interaction group
        this.addToGroup((sGroup) ? sGroup : "default");

        // We don't want to register this as the handle with the manager
        // so we just set the id rather than calling the setter.
        this.handleElId = id;

        Event.onAvailable(id, this.handleOnAvailable, this, true);


        // the linked element is the element that gets dragged by default
        this.setDragElId(id); 

        // by default, clicked anchors will not start drag operations.
        // @TODO what else should be here? Probably form fields.
        this.invalidHandleTypes = { A: "A" };
        this.invalidHandleIds = {};
        this.invalidHandleClasses = [];

        this.applyConfig();
    },

    /**
	 * Applies the configuration parameters that were passed into the
	 * constructor. This is supposed to happen at each level through the
	 * inheritance chain. So a DDProxy implentation will execute apply config on
	 * DDProxy, DD, and DragDrop in order to get all of the parameters that are
	 * available in each object.
	 * 
	 * @method applyConfig
	 */
    applyConfig: function() {
        this.events = {
            mouseDown: true,
            b4MouseDown: true,
            mouseUp: true,
            b4StartDrag: true,
            startDrag: true,
            b4EndDrag: true,
            endDrag: true,
            drag: true,
            b4Drag: true,
            invalidDrop: true,
            b4DragOut: true,
            dragOut: true,
            dragEnter: true,
            b4DragOver: true,
            dragOver: true,
            b4DragDrop: true,
            dragDrop: true
        };
        
        if (this.config.events) {
            for (var i in this.config.events) {
                if (this.config.events[i] === false) {
                    this.events[i] = false;
                }
            }
        }


        // configurable properties:
        // padding, isTarget, maintainOffset, primaryButtonOnly
        this.padding           = this.config.padding || [0, 0, 0, 0];
        this.isTarget          = (this.config.isTarget !== false);
        this.maintainOffset    = (this.config.maintainOffset);
        this.primaryButtonOnly = (this.config.primaryButtonOnly !== false);
        this.dragOnly = ((this.config.dragOnly === true) ? true : false);
        this.useShim = ((this.config.useShim === true) ? true : false);
    },

    /**
	 * Executed when the linked element is available
	 * 
	 * @method handleOnAvailable
	 * @private
	 */
    handleOnAvailable: function() {
        this.available = true;
        this.resetConstraints();
        this.onAvailable();
    },

     /**
		 * Configures the padding for the target zone in px. Effectively expands
		 * (or reduces) the virtual object size for targeting calculations.
		 * Supports css-style shorthand; if only one parameter is passed, all
		 * sides will have that padding, and if only two are passed, the top and
		 * bottom will have the first param, the left and right the second.
		 * 
		 * @method setPadding
		 * @param {int}
		 *            iTop Top pad
		 * @param {int}
		 *            iRight Right pad
		 * @param {int}
		 *            iBot Bot pad
		 * @param {int}
		 *            iLeft Left pad
		 */
    setPadding: function(iTop, iRight, iBot, iLeft) {
        // this.padding = [iLeft, iRight, iTop, iBot];
        if (!iRight && 0 !== iRight) {
            this.padding = [iTop, iTop, iTop, iTop];
        } else if (!iBot && 0 !== iBot) {
            this.padding = [iTop, iRight, iTop, iRight];
        } else {
            this.padding = [iTop, iRight, iBot, iLeft];
        }
    },

    /**
	 * Stores the initial placement of the linked element.
	 * 
	 * @method setInitialPosition
	 * @param {int}
	 *            diffX the X offset, default 0
	 * @param {int}
	 *            diffY the Y offset, default 0
	 * @private
	 */
    setInitPosition: function(diffX, diffY) {
        var el = this.getEl();

        if (!this.DDM.verifyEl(el)) {
            if (el && el.style && (el.style.display == 'none')) {
            } else {
            }
            return;
        }

        var dx = diffX || 0;
        var dy = diffY || 0;

        var p = Dom.getXY( el );

        this.initPageX = p[0] - dx;
        this.initPageY = p[1] - dy;

        this.lastPageX = p[0];
        this.lastPageY = p[1];



        this.setStartPosition(p);
    },

    /**
	 * Sets the start position of the element. This is set when the obj is
	 * initialized, the reset when a drag is started.
	 * 
	 * @method setStartPosition
	 * @param pos
	 *            current position (from previous lookup)
	 * @private
	 */
    setStartPosition: function(pos) {
        var p = pos || Dom.getXY(this.getEl());

        this.deltaSetXY = null;

        this.startPageX = p[0];
        this.startPageY = p[1];
    },

    /**
	 * Add this instance to a group of related drag/drop objects. All instances
	 * belong to at least one group, and can belong to as many groups as needed.
	 * 
	 * @method addToGroup
	 * @param sGroup
	 *            {string} the name of the group
	 */
    addToGroup: function(sGroup) {
        this.groups[sGroup] = true;
        this.DDM.regDragDrop(this, sGroup);
    },

    /**
	 * Remove's this instance from the supplied interaction group
	 * 
	 * @method removeFromGroup
	 * @param {string}
	 *            sGroup The group to drop
	 */
    removeFromGroup: function(sGroup) {
        if (this.groups[sGroup]) {
            delete this.groups[sGroup];
        }

        this.DDM.removeDDFromGroup(this, sGroup);
    },

    /**
	 * Allows you to specify that an element other than the linked element will
	 * be moved with the cursor during a drag
	 * 
	 * @method setDragElId
	 * @param id
	 *            {string} the id of the element that will be used to initiate
	 *            the drag
	 */
    setDragElId: function(id) {
        this.dragElId = id;
    },

    /**
	 * Allows you to specify a child of the linked element that should be used
	 * to initiate the drag operation. An example of this would be if you have a
	 * content div with text and links. Clicking anywhere in the content area
	 * would normally start the drag operation. Use this method to specify that
	 * an element inside of the content div is the element that starts the drag
	 * operation.
	 * 
	 * @method setHandleElId
	 * @param id
	 *            {string} the id of the element that will be used to initiate
	 *            the drag.
	 */
    setHandleElId: function(id) {
        if (typeof id !== "string") {
            id = Dom.generateId(id);
        }
        this.handleElId = id;
        this.DDM.regHandle(this.id, id);
    },

    /**
	 * Allows you to set an element outside of the linked element as a drag
	 * handle
	 * 
	 * @method setOuterHandleElId
	 * @param id
	 *            the id of the element that will be used to initiate the drag
	 */
    setOuterHandleElId: function(id) {
        if (typeof id !== "string") {
            id = Dom.generateId(id);
        }
        Event.on(id, "mousedown", 
                this.handleMouseDown, this, true);
        this.setHandleElId(id);

        this.hasOuterHandles = true;
    },

    /**
	 * Remove all drag and drop hooks for this element
	 * 
	 * @method unreg
	 */
    unreg: function() {
        Event.removeListener(this.id, "mousedown", 
                this.handleMouseDown);
        this._domRef = null;
        this.DDM._remove(this);
    },

    /**
	 * Returns true if this instance is locked, or the drag drop mgr is locked
	 * (meaning that all drag/drop is disabled on the page.)
	 * 
	 * @method isLocked
	 * @return {boolean} true if this obj or all drag/drop is locked, else false
	 */
    isLocked: function() {
        return (this.DDM.isLocked() || this.locked);
    },

    /**
	 * Fired when this object is clicked
	 * 
	 * @method handleMouseDown
	 * @param {Event}
	 *            e
	 * @param {YAHOO.util.DragDrop}
	 *            oDD the clicked dd object (this dd obj)
	 * @private
	 */
    handleMouseDown: function(e, oDD) {

        var button = e.which || e.button;

        if (this.primaryButtonOnly && button > 1) {
            return;
        }

        if (this.isLocked()) {
            return;
        }



        // firing the mousedown events prior to calculating positions
        var b4Return = this.b4MouseDown(e),
        b4Return2 = true;

        if (this.events.b4MouseDown) {
            b4Return2 = this.fireEvent('b4MouseDownEvent', e);
        }
        var mDownReturn = this.onMouseDown(e),
            mDownReturn2 = true;
        if (this.events.mouseDown) {
            if (mDownReturn === false) {
                // Fixes #2528759 - Mousedown function returned false, don't
				// fire the event and cancel everything.
                 mDownReturn2 = false;
            } else {
                mDownReturn2 = this.fireEvent('mouseDownEvent', e);
            }
        }

        if ((b4Return === false) || (mDownReturn === false) || (b4Return2 === false) || (mDownReturn2 === false)) {
            return;
        }

        this.DDM.refreshCache(this.groups);
        // var self = this;
        // setTimeout( function() { self.DDM.refreshCache(self.groups); }, 0);

        // Only process the event if we really clicked within the linked
        // element. The reason we make this check is that in the case that
        // another element was moved between the clicked element and the
        // cursor in the time between the mousedown and mouseup events. When
        // this happens, the element gets the next mousedown event
        // regardless of where on the screen it happened.
        var pt = new YAHOO.util.Point(Event.getPageX(e), Event.getPageY(e));
        if (!this.hasOuterHandles && !this.DDM.isOverTarget(pt, this) )  {
        } else {
            if (this.clickValidator(e)) {


                // set the initial element position
                this.setStartPosition();

                // start tracking mousemove distance and mousedown time to
                // determine when to start the actual drag
                this.DDM.handleMouseDown(e, this);

                // this mousedown is mine
                this.DDM.stopEvent(e);
            } else {


            }
        }
    },

    /**
	 * @method clickValidator
	 * @description Method validates that the clicked element was indeed the
	 *              handle or a valid child of the handle
	 * @param {Event}
	 *            e
	 */
    clickValidator: function(e) {
        var target = YAHOO.util.Event.getTarget(e);
        return ( this.isValidHandleChild(target) &&
                    (this.id == this.handleElId || 
                        this.DDM.handleWasClicked(target, this.id)) );
    },

    /**
	 * Finds the location the element should be placed if we want to move it to
	 * where the mouse location less the click offset would place us.
	 * 
	 * @method getTargetCoord
	 * @param {int}
	 *            iPageX the X coordinate of the click
	 * @param {int}
	 *            iPageY the Y coordinate of the click
	 * @return an object that contains the coordinates (Object.x and Object.y)
	 * @private
	 */
    getTargetCoord: function(iPageX, iPageY) {


        var x = iPageX - this.deltaX;
        var y = iPageY - this.deltaY;

        if (this.constrainX) {
            if (x < this.minX) { x = this.minX; }
            if (x > this.maxX) { x = this.maxX; }
        }

        if (this.constrainY) {
            if (y < this.minY) { y = this.minY; }
            if (y > this.maxY) { y = this.maxY; }
        }

        x = this.getTick(x, this.xTicks);
        y = this.getTick(y, this.yTicks);


        return {x:x, y:y};
    },

    /**
	 * Allows you to specify a tag name that should not start a drag operation
	 * when clicked. This is designed to facilitate embedding links within a
	 * drag handle that do something other than start the drag.
	 * 
	 * @method addInvalidHandleType
	 * @param {string}
	 *            tagName the type of element to exclude
	 */
    addInvalidHandleType: function(tagName) {
        var type = tagName.toUpperCase();
        this.invalidHandleTypes[type] = type;
    },

    /**
	 * Lets you to specify an element id for a child of a drag handle that
	 * should not initiate a drag
	 * 
	 * @method addInvalidHandleId
	 * @param {string}
	 *            id the element id of the element you wish to ignore
	 */
    addInvalidHandleId: function(id) {
        if (typeof id !== "string") {
            id = Dom.generateId(id);
        }
        this.invalidHandleIds[id] = id;
    },


    /**
	 * Lets you specify a css class of elements that will not initiate a drag
	 * 
	 * @method addInvalidHandleClass
	 * @param {string}
	 *            cssClass the class of the elements you wish to ignore
	 */
    addInvalidHandleClass: function(cssClass) {
        this.invalidHandleClasses.push(cssClass);
    },

    /**
	 * Unsets an excluded tag name set by addInvalidHandleType
	 * 
	 * @method removeInvalidHandleType
	 * @param {string}
	 *            tagName the type of element to unexclude
	 */
    removeInvalidHandleType: function(tagName) {
        var type = tagName.toUpperCase();
        // this.invalidHandleTypes[type] = null;
        delete this.invalidHandleTypes[type];
    },
    
    /**
	 * Unsets an invalid handle id
	 * 
	 * @method removeInvalidHandleId
	 * @param {string}
	 *            id the id of the element to re-enable
	 */
    removeInvalidHandleId: function(id) {
        if (typeof id !== "string") {
            id = Dom.generateId(id);
        }
        delete this.invalidHandleIds[id];
    },

    /**
	 * Unsets an invalid css class
	 * 
	 * @method removeInvalidHandleClass
	 * @param {string}
	 *            cssClass the class of the element(s) you wish to re-enable
	 */
    removeInvalidHandleClass: function(cssClass) {
        for (var i=0, len=this.invalidHandleClasses.length; i<len; ++i) {
            if (this.invalidHandleClasses[i] == cssClass) {
                delete this.invalidHandleClasses[i];
            }
        }
    },

    /**
	 * Checks the tag exclusion list to see if this click should be ignored
	 * 
	 * @method isValidHandleChild
	 * @param {HTMLElement}
	 *            node the HTMLElement to evaluate
	 * @return {boolean} true if this is a valid tag type, false if not
	 */
    isValidHandleChild: function(node) {

        var valid = true;
        // var n = (node.nodeName == "#text") ? node.parentNode : node;
        var nodeName;
        try {
            nodeName = node.nodeName.toUpperCase();
        } catch(e) {
            nodeName = node.nodeName;
        }
        valid = valid && !this.invalidHandleTypes[nodeName];
        valid = valid && !this.invalidHandleIds[node.id];

        for (var i=0, len=this.invalidHandleClasses.length; valid && i<len; ++i) {
            valid = !Dom.hasClass(node, this.invalidHandleClasses[i]);
        }


        return valid;

    },

    /**
	 * Create the array of horizontal tick marks if an interval was specified in
	 * setXConstraint().
	 * 
	 * @method setXTicks
	 * @private
	 */
    setXTicks: function(iStartX, iTickSize) {
        this.xTicks = [];
        this.xTickSize = iTickSize;
        
        var tickMap = {};

        for (var i = this.initPageX; i >= this.minX; i = i - iTickSize) {
            if (!tickMap[i]) {
                this.xTicks[this.xTicks.length] = i;
                tickMap[i] = true;
            }
        }

        for (i = this.initPageX; i <= this.maxX; i = i + iTickSize) {
            if (!tickMap[i]) {
                this.xTicks[this.xTicks.length] = i;
                tickMap[i] = true;
            }
        }

        this.xTicks.sort(this.DDM.numericSort) ;
    },

    /**
	 * Create the array of vertical tick marks if an interval was specified in
	 * setYConstraint().
	 * 
	 * @method setYTicks
	 * @private
	 */
    setYTicks: function(iStartY, iTickSize) {
        this.yTicks = [];
        this.yTickSize = iTickSize;

        var tickMap = {};

        for (var i = this.initPageY; i >= this.minY; i = i - iTickSize) {
            if (!tickMap[i]) {
                this.yTicks[this.yTicks.length] = i;
                tickMap[i] = true;
            }
        }

        for (i = this.initPageY; i <= this.maxY; i = i + iTickSize) {
            if (!tickMap[i]) {
                this.yTicks[this.yTicks.length] = i;
                tickMap[i] = true;
            }
        }

        this.yTicks.sort(this.DDM.numericSort) ;
    },

    /**
	 * By default, the element can be dragged any place on the screen. Use this
	 * method to limit the horizontal travel of the element. Pass in 0,0 for the
	 * parameters if you want to lock the drag to the y axis.
	 * 
	 * @method setXConstraint
	 * @param {int}
	 *            iLeft the number of pixels the element can move to the left
	 * @param {int}
	 *            iRight the number of pixels the element can move to the right
	 * @param {int}
	 *            iTickSize optional parameter for specifying that the element
	 *            should move iTickSize pixels at a time.
	 */
    setXConstraint: function(iLeft, iRight, iTickSize) {
        this.leftConstraint = parseInt(iLeft, 10);
        this.rightConstraint = parseInt(iRight, 10);

        this.minX = this.initPageX - this.leftConstraint;
        this.maxX = this.initPageX + this.rightConstraint;
        if (iTickSize) { this.setXTicks(this.initPageX, iTickSize); }

        this.constrainX = true;
    },

    /**
	 * Clears any constraints applied to this instance. Also clears ticks since
	 * they can't exist independent of a constraint at this time.
	 * 
	 * @method clearConstraints
	 */
    clearConstraints: function() {
        this.constrainX = false;
        this.constrainY = false;
        this.clearTicks();
    },

    /**
	 * Clears any tick interval defined for this instance
	 * 
	 * @method clearTicks
	 */
    clearTicks: function() {
        this.xTicks = null;
        this.yTicks = null;
        this.xTickSize = 0;
        this.yTickSize = 0;
    },

    /**
	 * By default, the element can be dragged any place on the screen. Set this
	 * to limit the vertical travel of the element. Pass in 0,0 for the
	 * parameters if you want to lock the drag to the x axis.
	 * 
	 * @method setYConstraint
	 * @param {int}
	 *            iUp the number of pixels the element can move up
	 * @param {int}
	 *            iDown the number of pixels the element can move down
	 * @param {int}
	 *            iTickSize optional parameter for specifying that the element
	 *            should move iTickSize pixels at a time.
	 */
    setYConstraint: function(iUp, iDown, iTickSize) {
        this.topConstraint = parseInt(iUp, 10);
        this.bottomConstraint = parseInt(iDown, 10);

        this.minY = this.initPageY - this.topConstraint;
        this.maxY = this.initPageY + this.bottomConstraint;
        if (iTickSize) { this.setYTicks(this.initPageY, iTickSize); }

        this.constrainY = true;
        
    },

    /**
	 * resetConstraints must be called if you manually reposition a dd element.
	 * 
	 * @method resetConstraints
	 */
    resetConstraints: function() {


        // Maintain offsets if necessary
        if (this.initPageX || this.initPageX === 0) {
            // figure out how much this thing has moved
            var dx = (this.maintainOffset) ? this.lastPageX - this.initPageX : 0;
            var dy = (this.maintainOffset) ? this.lastPageY - this.initPageY : 0;

            this.setInitPosition(dx, dy);

        // This is the first time we have detected the element's position
        } else {
            this.setInitPosition();
        }

        if (this.constrainX) {
            this.setXConstraint( this.leftConstraint, 
                                 this.rightConstraint, 
                                 this.xTickSize        );
        }

        if (this.constrainY) {
            this.setYConstraint( this.topConstraint, 
                                 this.bottomConstraint, 
                                 this.yTickSize         );
        }
    },

    /**
	 * Normally the drag element is moved pixel by pixel, but we can specify
	 * that it move a number of pixels at a time. This method resolves the
	 * location when we have it set up like this.
	 * 
	 * @method getTick
	 * @param {int}
	 *            val where we want to place the object
	 * @param {int[]}
	 *            tickArray sorted array of valid points
	 * @return {int} the closest tick
	 * @private
	 */
    getTick: function(val, tickArray) {

        if (!tickArray) {
            // If tick interval is not defined, it is effectively 1 pixel,
            // so we return the value passed to us.
            return val; 
        } else if (tickArray[0] >= val) {
            // The value is lower than the first tick, so we return the first
            // tick.
            return tickArray[0];
        } else {
            for (var i=0, len=tickArray.length; i<len; ++i) {
                var next = i + 1;
                if (tickArray[next] && tickArray[next] >= val) {
                    var diff1 = val - tickArray[i];
                    var diff2 = tickArray[next] - val;
                    return (diff2 > diff1) ? tickArray[i] : tickArray[next];
                }
            }

            // The value is larger than the last tick, so we return the last
            // tick.
            return tickArray[tickArray.length - 1];
        }
    },

    /**
	 * toString method
	 * 
	 * @method toString
	 * @return {string} string representation of the dd obj
	 */
    toString: function() {
        return ("DragDrop " + this.id);
    }

};
YAHOO.augment(YAHOO.util.DragDrop, YAHOO.util.EventProvider);

/**
 * @event mouseDownEvent
 * @description Provides access to the mousedown event. The mousedown does not
 *              always result in a drag operation.
 * @type YAHOO.util.CustomEvent See <a
 *       href="YAHOO.util.Element.html#addListener">Element.addListener</a> for
 *       more information on listening for this event.
 */

/**
 * @event b4MouseDownEvent
 * @description Provides access to the mousedown event, before the
 *              mouseDownEvent gets fired. Returning false will cancel the drag.
 * @type YAHOO.util.CustomEvent See <a
 *       href="YAHOO.util.Element.html#addListener">Element.addListener</a> for
 *       more information on listening for this event.
 */

/**
 * @event mouseUpEvent
 * @description Fired from inside DragDropMgr when the drag operation is
 *              finished.
 * @type YAHOO.util.CustomEvent See <a
 *       href="YAHOO.util.Element.html#addListener">Element.addListener</a> for
 *       more information on listening for this event.
 */

/**
 * @event b4StartDragEvent
 * @description Fires before the startDragEvent, returning false will cancel the
 *              startDrag Event.
 * @type YAHOO.util.CustomEvent See <a
 *       href="YAHOO.util.Element.html#addListener">Element.addListener</a> for
 *       more information on listening for this event.
 */

/**
 * @event startDragEvent
 * @description Occurs after a mouse down and the drag threshold has been met.
 *              The drag threshold default is either 3 pixels of mouse movement
 *              or 1 full second of holding the mousedown.
 * @type YAHOO.util.CustomEvent See <a
 *       href="YAHOO.util.Element.html#addListener">Element.addListener</a> for
 *       more information on listening for this event.
 */

/**
 * @event b4EndDragEvent
 * @description Fires before the endDragEvent. Returning false will cancel.
 * @type YAHOO.util.CustomEvent See <a
 *       href="YAHOO.util.Element.html#addListener">Element.addListener</a> for
 *       more information on listening for this event.
 */

/**
 * @event endDragEvent
 * @description Fires on the mouseup event after a drag has been initiated
 *              (startDrag fired).
 * @type YAHOO.util.CustomEvent See <a
 *       href="YAHOO.util.Element.html#addListener">Element.addListener</a> for
 *       more information on listening for this event.
 */

/**
 * @event dragEvent
 * @description Occurs every mousemove event while dragging.
 * @type YAHOO.util.CustomEvent See <a
 *       href="YAHOO.util.Element.html#addListener">Element.addListener</a> for
 *       more information on listening for this event.
 */
/**
 * @event b4DragEvent
 * @description Fires before the dragEvent.
 * @type YAHOO.util.CustomEvent See <a
 *       href="YAHOO.util.Element.html#addListener">Element.addListener</a> for
 *       more information on listening for this event.
 */
/**
 * @event invalidDropEvent
 * @description Fires when the dragged objects is dropped in a location that
 *              contains no drop targets.
 * @type YAHOO.util.CustomEvent See <a
 *       href="YAHOO.util.Element.html#addListener">Element.addListener</a> for
 *       more information on listening for this event.
 */
/**
 * @event b4DragOutEvent
 * @description Fires before the dragOutEvent
 * @type YAHOO.util.CustomEvent See <a
 *       href="YAHOO.util.Element.html#addListener">Element.addListener</a> for
 *       more information on listening for this event.
 */
/**
 * @event dragOutEvent
 * @description Fires when a dragged object is no longer over an object that had
 *              the onDragEnter fire.
 * @type YAHOO.util.CustomEvent See <a
 *       href="YAHOO.util.Element.html#addListener">Element.addListener</a> for
 *       more information on listening for this event.
 */
/**
 * @event dragEnterEvent
 * @description Occurs when the dragged object first interacts with another
 *              targettable drag and drop object.
 * @type YAHOO.util.CustomEvent See <a
 *       href="YAHOO.util.Element.html#addListener">Element.addListener</a> for
 *       more information on listening for this event.
 */
/**
 * @event b4DragOverEvent
 * @description Fires before the dragOverEvent.
 * @type YAHOO.util.CustomEvent See <a
 *       href="YAHOO.util.Element.html#addListener">Element.addListener</a> for
 *       more information on listening for this event.
 */
/**
 * @event dragOverEvent
 * @description Fires every mousemove event while over a drag and drop object.
 * @type YAHOO.util.CustomEvent See <a
 *       href="YAHOO.util.Element.html#addListener">Element.addListener</a> for
 *       more information on listening for this event.
 */
/**
 * @event b4DragDropEvent
 * @description Fires before the dragDropEvent
 * @type YAHOO.util.CustomEvent See <a
 *       href="YAHOO.util.Element.html#addListener">Element.addListener</a> for
 *       more information on listening for this event.
 */
/**
 * @event dragDropEvent
 * @description Fires when the dragged objects is dropped on another.
 * @type YAHOO.util.CustomEvent See <a
 *       href="YAHOO.util.Element.html#addListener">Element.addListener</a> for
 *       more information on listening for this event.
 */
})();
/**
 * A DragDrop implementation where the linked element follows the mouse cursor
 * during a drag.
 * 
 * @class DD
 * @extends YAHOO.util.DragDrop
 * @constructor
 * @param {String}
 *            id the id of the linked element
 * @param {String}
 *            sGroup the group of related DragDrop items
 * @param {object}
 *            config an object containing configurable attributes Valid
 *            properties for DD: scroll
 */
YAHOO.util.DD = function(id, sGroup, config) {
    if (id) {
        this.init(id, sGroup, config);
    }
};

YAHOO.extend(YAHOO.util.DD, YAHOO.util.DragDrop, {

    /**
	 * When set to true, the utility automatically tries to scroll the browser
	 * window when a drag and drop element is dragged near the viewport
	 * boundary. Defaults to true.
	 * 
	 * @property scroll
	 * @type boolean
	 */
    scroll: true, 

    /**
	 * Sets the pointer offset to the distance between the linked element's top
	 * left corner and the location the element was clicked
	 * 
	 * @method autoOffset
	 * @param {int}
	 *            iPageX the X coordinate of the click
	 * @param {int}
	 *            iPageY the Y coordinate of the click
	 */
    autoOffset: function(iPageX, iPageY) {
        var x = iPageX - this.startPageX;
        var y = iPageY - this.startPageY;
        this.setDelta(x, y);
    },

    /**
	 * Sets the pointer offset. You can call this directly to force the offset
	 * to be in a particular location (e.g., pass in 0,0 to set it to the center
	 * of the object, as done in YAHOO.widget.Slider)
	 * 
	 * @method setDelta
	 * @param {int}
	 *            iDeltaX the distance from the left
	 * @param {int}
	 *            iDeltaY the distance from the top
	 */
    setDelta: function(iDeltaX, iDeltaY) {
        this.deltaX = iDeltaX;
        this.deltaY = iDeltaY;
    },

    /**
	 * Sets the drag element to the location of the mousedown or click event,
	 * maintaining the cursor location relative to the location on the element
	 * that was clicked. Override this if you want to place the element in a
	 * location other than where the cursor is.
	 * 
	 * @method setDragElPos
	 * @param {int}
	 *            iPageX the X coordinate of the mousedown or drag event
	 * @param {int}
	 *            iPageY the Y coordinate of the mousedown or drag event
	 */
    setDragElPos: function(iPageX, iPageY) {
        // the first time we do this, we are going to check to make sure
        // the element has css positioning

        var el = this.getDragEl();
        this.alignElWithMouse(el, iPageX, iPageY);
    },

    /**
	 * Sets the element to the location of the mousedown or click event,
	 * maintaining the cursor location relative to the location on the element
	 * that was clicked. Override this if you want to place the element in a
	 * location other than where the cursor is.
	 * 
	 * @method alignElWithMouse
	 * @param {HTMLElement}
	 *            el the element to move
	 * @param {int}
	 *            iPageX the X coordinate of the mousedown or drag event
	 * @param {int}
	 *            iPageY the Y coordinate of the mousedown or drag event
	 */
    alignElWithMouse: function(el, iPageX, iPageY) {
        var oCoord = this.getTargetCoord(iPageX, iPageY);

        if (!this.deltaSetXY) {
            var aCoord = [oCoord.x, oCoord.y];
            YAHOO.util.Dom.setXY(el, aCoord);

            var newLeft = parseInt( YAHOO.util.Dom.getStyle(el, "left"), 10 );
            var newTop  = parseInt( YAHOO.util.Dom.getStyle(el, "top" ), 10 );

            this.deltaSetXY = [ newLeft - oCoord.x, newTop - oCoord.y ];
        } else {
            YAHOO.util.Dom.setStyle(el, "left", (oCoord.x + this.deltaSetXY[0]) + "px");
            YAHOO.util.Dom.setStyle(el, "top",  (oCoord.y + this.deltaSetXY[1]) + "px");
        }
        
        this.cachePosition(oCoord.x, oCoord.y);
        var self = this;
        setTimeout(function() {
            self.autoScroll.call(self, oCoord.x, oCoord.y, el.offsetHeight, el.offsetWidth);
        }, 0);
    },

    /**
	 * Saves the most recent position so that we can reset the constraints and
	 * tick marks on-demand. We need to know this so that we can calculate the
	 * number of pixels the element is offset from its original position.
	 * 
	 * @method cachePosition
	 * @param iPageX
	 *            the current x position (optional, this just makes it so we
	 *            don't have to look it up again)
	 * @param iPageY
	 *            the current y position (optional, this just makes it so we
	 *            don't have to look it up again)
	 */
    cachePosition: function(iPageX, iPageY) {
        if (iPageX) {
            this.lastPageX = iPageX;
            this.lastPageY = iPageY;
        } else {
            var aCoord = YAHOO.util.Dom.getXY(this.getEl());
            this.lastPageX = aCoord[0];
            this.lastPageY = aCoord[1];
        }
    },

    /**
	 * Auto-scroll the window if the dragged object has been moved beyond the
	 * visible window boundary.
	 * 
	 * @method autoScroll
	 * @param {int}
	 *            x the drag element's x position
	 * @param {int}
	 *            y the drag element's y position
	 * @param {int}
	 *            h the height of the drag element
	 * @param {int}
	 *            w the width of the drag element
	 * @private
	 */
    autoScroll: function(x, y, h, w) {

        if (this.scroll) {
            // The client height
            var clientH = this.DDM.getClientHeight();

            // The client width
            var clientW = this.DDM.getClientWidth();

            // The amt scrolled down
            var st = this.DDM.getScrollTop();

            // The amt scrolled right
            var sl = this.DDM.getScrollLeft();

            // Location of the bottom of the element
            var bot = h + y;

            // Location of the right of the element
            var right = w + x;

            // The distance from the cursor to the bottom of the visible area,
            // adjusted so that we don't scroll if the cursor is beyond the
            // element drag constraints
            var toBot = (clientH + st - y - this.deltaY);

            // The distance from the cursor to the right of the visible area
            var toRight = (clientW + sl - x - this.deltaX);


            // How close to the edge the cursor must be before we scroll
            // var thresh = (document.all) ? 100 : 40;
            var thresh = 40;

            // How many pixels to scroll per autoscroll op. This helps to reduce
            // clunky scrolling. IE is more sensitive about this ... it needs
			// this
            // value to be higher.
            var scrAmt = (document.all) ? 80 : 30;

            // Scroll down if we are near the bottom of the visible page and the
            // obj extends below the crease
            if ( bot > clientH && toBot < thresh ) { 
                window.scrollTo(sl, st + scrAmt); 
            }

            // Scroll up if the window is scrolled down and the top of the
			// object
            // goes above the top border
            if ( y < st && st > 0 && y - st < thresh ) { 
                window.scrollTo(sl, st - scrAmt); 
            }

            // Scroll right if the obj is beyond the right border and the cursor
			// is
            // near the border.
            if ( right > clientW && toRight < thresh ) { 
                window.scrollTo(sl + scrAmt, st); 
            }

            // Scroll left if the window has been scrolled to the right and the
			// obj
            // extends past the left border
            if ( x < sl && sl > 0 && x - sl < thresh ) { 
                window.scrollTo(sl - scrAmt, st);
            }
        }
    },

    /*
	 * Sets up config options specific to this class. Overrides
	 * YAHOO.util.DragDrop, but all versions of this method through the
	 * inheritance chain are called
	 */
    applyConfig: function() {
        YAHOO.util.DD.superclass.applyConfig.call(this);
        this.scroll = (this.config.scroll !== false);
    },

    /*
	 * Event that fires prior to the onMouseDown event. Overrides
	 * YAHOO.util.DragDrop.
	 */
    b4MouseDown: function(e) {
        this.setStartPosition();
        // this.resetConstraints();
        this.autoOffset(YAHOO.util.Event.getPageX(e), 
                            YAHOO.util.Event.getPageY(e));
    },

    /*
	 * Event that fires prior to the onDrag event. Overrides
	 * YAHOO.util.DragDrop.
	 */
    b4Drag: function(e) {
        this.setDragElPos(YAHOO.util.Event.getPageX(e), 
                            YAHOO.util.Event.getPageY(e));
    },

    toString: function() {
        return ("DD " + this.id);
    }

    // ////////////////////////////////////////////////////////////////////////
    // Debugging ygDragDrop events that can be overridden
    // ////////////////////////////////////////////////////////////////////////
    /*
	 * startDrag: function(x, y) { },
	 * 
	 * onDrag: function(e) { },
	 * 
	 * onDragEnter: function(e, id) { },
	 * 
	 * onDragOver: function(e, id) { },
	 * 
	 * onDragOut: function(e, id) { },
	 * 
	 * onDragDrop: function(e, id) { },
	 * 
	 * endDrag: function(e) { }
	 * 
	 */

/**
 * @event mouseDownEvent
 * @description Provides access to the mousedown event. The mousedown does not
 *              always result in a drag operation.
 * @type YAHOO.util.CustomEvent See <a
 *       href="YAHOO.util.Element.html#addListener">Element.addListener</a> for
 *       more information on listening for this event.
 */

/**
 * @event b4MouseDownEvent
 * @description Provides access to the mousedown event, before the
 *              mouseDownEvent gets fired. Returning false will cancel the drag.
 * @type YAHOO.util.CustomEvent See <a
 *       href="YAHOO.util.Element.html#addListener">Element.addListener</a> for
 *       more information on listening for this event.
 */

/**
 * @event mouseUpEvent
 * @description Fired from inside DragDropMgr when the drag operation is
 *              finished.
 * @type YAHOO.util.CustomEvent See <a
 *       href="YAHOO.util.Element.html#addListener">Element.addListener</a> for
 *       more information on listening for this event.
 */

/**
 * @event b4StartDragEvent
 * @description Fires before the startDragEvent, returning false will cancel the
 *              startDrag Event.
 * @type YAHOO.util.CustomEvent See <a
 *       href="YAHOO.util.Element.html#addListener">Element.addListener</a> for
 *       more information on listening for this event.
 */

/**
 * @event startDragEvent
 * @description Occurs after a mouse down and the drag threshold has been met.
 *              The drag threshold default is either 3 pixels of mouse movement
 *              or 1 full second of holding the mousedown.
 * @type YAHOO.util.CustomEvent See <a
 *       href="YAHOO.util.Element.html#addListener">Element.addListener</a> for
 *       more information on listening for this event.
 */

/**
 * @event b4EndDragEvent
 * @description Fires before the endDragEvent. Returning false will cancel.
 * @type YAHOO.util.CustomEvent See <a
 *       href="YAHOO.util.Element.html#addListener">Element.addListener</a> for
 *       more information on listening for this event.
 */

/**
 * @event endDragEvent
 * @description Fires on the mouseup event after a drag has been initiated
 *              (startDrag fired).
 * @type YAHOO.util.CustomEvent See <a
 *       href="YAHOO.util.Element.html#addListener">Element.addListener</a> for
 *       more information on listening for this event.
 */

/**
 * @event dragEvent
 * @description Occurs every mousemove event while dragging.
 * @type YAHOO.util.CustomEvent See <a
 *       href="YAHOO.util.Element.html#addListener">Element.addListener</a> for
 *       more information on listening for this event.
 */
/**
 * @event b4DragEvent
 * @description Fires before the dragEvent.
 * @type YAHOO.util.CustomEvent See <a
 *       href="YAHOO.util.Element.html#addListener">Element.addListener</a> for
 *       more information on listening for this event.
 */
/**
 * @event invalidDropEvent
 * @description Fires when the dragged objects is dropped in a location that
 *              contains no drop targets.
 * @type YAHOO.util.CustomEvent See <a
 *       href="YAHOO.util.Element.html#addListener">Element.addListener</a> for
 *       more information on listening for this event.
 */
/**
 * @event b4DragOutEvent
 * @description Fires before the dragOutEvent
 * @type YAHOO.util.CustomEvent See <a
 *       href="YAHOO.util.Element.html#addListener">Element.addListener</a> for
 *       more information on listening for this event.
 */
/**
 * @event dragOutEvent
 * @description Fires when a dragged object is no longer over an object that had
 *              the onDragEnter fire.
 * @type YAHOO.util.CustomEvent See <a
 *       href="YAHOO.util.Element.html#addListener">Element.addListener</a> for
 *       more information on listening for this event.
 */
/**
 * @event dragEnterEvent
 * @description Occurs when the dragged object first interacts with another
 *              targettable drag and drop object.
 * @type YAHOO.util.CustomEvent See <a
 *       href="YAHOO.util.Element.html#addListener">Element.addListener</a> for
 *       more information on listening for this event.
 */
/**
 * @event b4DragOverEvent
 * @description Fires before the dragOverEvent.
 * @type YAHOO.util.CustomEvent See <a
 *       href="YAHOO.util.Element.html#addListener">Element.addListener</a> for
 *       more information on listening for this event.
 */
/**
 * @event dragOverEvent
 * @description Fires every mousemove event while over a drag and drop object.
 * @type YAHOO.util.CustomEvent See <a
 *       href="YAHOO.util.Element.html#addListener">Element.addListener</a> for
 *       more information on listening for this event.
 */
/**
 * @event b4DragDropEvent
 * @description Fires before the dragDropEvent
 * @type YAHOO.util.CustomEvent See <a
 *       href="YAHOO.util.Element.html#addListener">Element.addListener</a> for
 *       more information on listening for this event.
 */
/**
 * @event dragDropEvent
 * @description Fires when the dragged objects is dropped on another.
 * @type YAHOO.util.CustomEvent See <a
 *       href="YAHOO.util.Element.html#addListener">Element.addListener</a> for
 *       more information on listening for this event.
 */
});
/**
 * A DragDrop implementation that inserts an empty, bordered div into the
 * document that follows the cursor during drag operations. At the time of the
 * click, the frame div is resized to the dimensions of the linked html element,
 * and moved to the exact location of the linked element.
 * 
 * References to the "frame" element refer to the single proxy element that was
 * created to be dragged in place of all DDProxy elements on the page.
 * 
 * @class DDProxy
 * @extends YAHOO.util.DD
 * @constructor
 * @param {String}
 *            id the id of the linked html element
 * @param {String}
 *            sGroup the group of related DragDrop objects
 * @param {object}
 *            config an object containing configurable attributes Valid
 *            properties for DDProxy in addition to those in DragDrop:
 *            resizeFrame, centerFrame, dragElId
 */
YAHOO.util.DDProxy = function(id, sGroup, config) {
    if (id) {
        this.init(id, sGroup, config);
        this.initFrame(); 
    }
};

/**
 * The default drag frame div id
 * 
 * @property YAHOO.util.DDProxy.dragElId
 * @type String
 * @static
 */
YAHOO.util.DDProxy.dragElId = "ygddfdiv";

YAHOO.extend(YAHOO.util.DDProxy, YAHOO.util.DD, {

    /**
	 * By default we resize the drag frame to be the same size as the element we
	 * want to drag (this is to get the frame effect). We can turn it off if we
	 * want a different behavior.
	 * 
	 * @property resizeFrame
	 * @type boolean
	 */
    resizeFrame: true,

    /**
	 * By default the frame is positioned exactly where the drag element is, so
	 * we use the cursor offset provided by YAHOO.util.DD. Another option that
	 * works only if you do not have constraints on the obj is to have the drag
	 * frame centered around the cursor. Set centerFrame to true for this
	 * effect.
	 * 
	 * @property centerFrame
	 * @type boolean
	 */
    centerFrame: false,

    /**
	 * Creates the proxy element if it does not yet exist
	 * 
	 * @method createFrame
	 */
    createFrame: function() {
        var self=this, body=document.body;

        if (!body || !body.firstChild) {
            setTimeout( function() { self.createFrame(); }, 50 );
            return;
        }

        var div=this.getDragEl(), Dom=YAHOO.util.Dom;

        if (!div) {
            div    = document.createElement("div");
            div.id = this.dragElId;
            var s  = div.style;

            s.position   = "absolute";
            s.visibility = "hidden";
            s.cursor     = "move";
            s.border     = "2px solid #aaa";
            s.zIndex     = 999;
            s.height     = "25px";
            s.width      = "25px";

            var _data = document.createElement('div');
            Dom.setStyle(_data, 'height', '100%');
            Dom.setStyle(_data, 'width', '100%');
            /**
			 * If the proxy element has no background-color, then it is
			 * considered to the "transparent" by Internet Explorer. Since it is
			 * "transparent" then the events pass through it to the iframe
			 * below. So creating a "fake" div inside the proxy element and
			 * giving it a background-color, then setting it to an opacity of 0,
			 * it appears to not be there, however IE still thinks that it is so
			 * the events never pass through.
			 */
            Dom.setStyle(_data, 'background-color', '#ccc');
            Dom.setStyle(_data, 'opacity', '0');
            div.appendChild(_data);

            // appendChild can blow up IE if invoked prior to the window load
			// event
            // while rendering a table. It is possible there are other scenarios
            // that would cause this to happen as well.
            body.insertBefore(div, body.firstChild);
        }
    },

    /**
	 * Initialization for the drag frame element. Must be called in the
	 * constructor of all subclasses
	 * 
	 * @method initFrame
	 */
    initFrame: function() {
        this.createFrame();
    },

    applyConfig: function() {
        YAHOO.util.DDProxy.superclass.applyConfig.call(this);

        this.resizeFrame = (this.config.resizeFrame !== false);
        this.centerFrame = (this.config.centerFrame);
        this.setDragElId(this.config.dragElId || YAHOO.util.DDProxy.dragElId);
    },

    /**
	 * Resizes the drag frame to the dimensions of the clicked object, positions
	 * it over the object, and finally displays it
	 * 
	 * @method showFrame
	 * @param {int}
	 *            iPageX X click position
	 * @param {int}
	 *            iPageY Y click position
	 * @private
	 */
    showFrame: function(iPageX, iPageY) {
        var el = this.getEl();
        var dragEl = this.getDragEl();
        var s = dragEl.style;

        this._resizeProxy();

        if (this.centerFrame) {
            this.setDelta( Math.round(parseInt(s.width,  10)/2), 
                           Math.round(parseInt(s.height, 10)/2) );
        }

        this.setDragElPos(iPageX, iPageY);

        YAHOO.util.Dom.setStyle(dragEl, "visibility", "visible"); 
    },

    /**
	 * The proxy is automatically resized to the dimensions of the linked
	 * element when a drag is initiated, unless resizeFrame is set to false
	 * 
	 * @method _resizeProxy
	 * @private
	 */
    _resizeProxy: function() {
        if (this.resizeFrame) {
            var DOM    = YAHOO.util.Dom;
            var el     = this.getEl();
            var dragEl = this.getDragEl();

            var bt = parseInt( DOM.getStyle(dragEl, "borderTopWidth"    ), 10);
            var br = parseInt( DOM.getStyle(dragEl, "borderRightWidth"  ), 10);
            var bb = parseInt( DOM.getStyle(dragEl, "borderBottomWidth" ), 10);
            var bl = parseInt( DOM.getStyle(dragEl, "borderLeftWidth"   ), 10);

            if (isNaN(bt)) { bt = 0; }
            if (isNaN(br)) { br = 0; }
            if (isNaN(bb)) { bb = 0; }
            if (isNaN(bl)) { bl = 0; }


            var newWidth  = Math.max(0, el.offsetWidth  - br - bl);                                                                                           
            var newHeight = Math.max(0, el.offsetHeight - bt - bb);


            DOM.setStyle( dragEl, "width",  newWidth  + "px" );
            DOM.setStyle( dragEl, "height", newHeight + "px" );
        }
    },

    // overrides YAHOO.util.DragDrop
    b4MouseDown: function(e) {
        this.setStartPosition();
        var x = YAHOO.util.Event.getPageX(e);
        var y = YAHOO.util.Event.getPageY(e);
        this.autoOffset(x, y);

        // This causes the autoscroll code to kick off, which means autoscroll
		// can
        // happen prior to the check for a valid drag handle.
        // this.setDragElPos(x, y);
    },

    // overrides YAHOO.util.DragDrop
    b4StartDrag: function(x, y) {
        // show the drag frame
        this.showFrame(x, y);
    },

    // overrides YAHOO.util.DragDrop
    b4EndDrag: function(e) {
        YAHOO.util.Dom.setStyle(this.getDragEl(), "visibility", "hidden"); 
    },

    // overrides YAHOO.util.DragDrop
    // By default we try to move the element to the last location of the frame.
    // This is so that the default behavior mirrors that of YAHOO.util.DD.
    endDrag: function(e) {
        var DOM = YAHOO.util.Dom;
        var lel = this.getEl();
        var del = this.getDragEl();

        // Show the drag frame briefly so we can get its position
        // del.style.visibility = "";
        DOM.setStyle(del, "visibility", ""); 

        // Hide the linked element before the move to get around a Safari
        // rendering bug.
        // lel.style.visibility = "hidden";
        DOM.setStyle(lel, "visibility", "hidden"); 
        YAHOO.util.DDM.moveToEl(lel, del);
        // del.style.visibility = "hidden";
        DOM.setStyle(del, "visibility", "hidden"); 
        // lel.style.visibility = "";
        DOM.setStyle(lel, "visibility", ""); 
    },

    toString: function() {
        return ("DDProxy " + this.id);
    }
/**
 * @event mouseDownEvent
 * @description Provides access to the mousedown event. The mousedown does not
 *              always result in a drag operation.
 * @type YAHOO.util.CustomEvent See <a
 *       href="YAHOO.util.Element.html#addListener">Element.addListener</a> for
 *       more information on listening for this event.
 */

/**
 * @event b4MouseDownEvent
 * @description Provides access to the mousedown event, before the
 *              mouseDownEvent gets fired. Returning false will cancel the drag.
 * @type YAHOO.util.CustomEvent See <a
 *       href="YAHOO.util.Element.html#addListener">Element.addListener</a> for
 *       more information on listening for this event.
 */

/**
 * @event mouseUpEvent
 * @description Fired from inside DragDropMgr when the drag operation is
 *              finished.
 * @type YAHOO.util.CustomEvent See <a
 *       href="YAHOO.util.Element.html#addListener">Element.addListener</a> for
 *       more information on listening for this event.
 */

/**
 * @event b4StartDragEvent
 * @description Fires before the startDragEvent, returning false will cancel the
 *              startDrag Event.
 * @type YAHOO.util.CustomEvent See <a
 *       href="YAHOO.util.Element.html#addListener">Element.addListener</a> for
 *       more information on listening for this event.
 */

/**
 * @event startDragEvent
 * @description Occurs after a mouse down and the drag threshold has been met.
 *              The drag threshold default is either 3 pixels of mouse movement
 *              or 1 full second of holding the mousedown.
 * @type YAHOO.util.CustomEvent See <a
 *       href="YAHOO.util.Element.html#addListener">Element.addListener</a> for
 *       more information on listening for this event.
 */

/**
 * @event b4EndDragEvent
 * @description Fires before the endDragEvent. Returning false will cancel.
 * @type YAHOO.util.CustomEvent See <a
 *       href="YAHOO.util.Element.html#addListener">Element.addListener</a> for
 *       more information on listening for this event.
 */

/**
 * @event endDragEvent
 * @description Fires on the mouseup event after a drag has been initiated
 *              (startDrag fired).
 * @type YAHOO.util.CustomEvent See <a
 *       href="YAHOO.util.Element.html#addListener">Element.addListener</a> for
 *       more information on listening for this event.
 */

/**
 * @event dragEvent
 * @description Occurs every mousemove event while dragging.
 * @type YAHOO.util.CustomEvent See <a
 *       href="YAHOO.util.Element.html#addListener">Element.addListener</a> for
 *       more information on listening for this event.
 */
/**
 * @event b4DragEvent
 * @description Fires before the dragEvent.
 * @type YAHOO.util.CustomEvent See <a
 *       href="YAHOO.util.Element.html#addListener">Element.addListener</a> for
 *       more information on listening for this event.
 */
/**
 * @event invalidDropEvent
 * @description Fires when the dragged objects is dropped in a location that
 *              contains no drop targets.
 * @type YAHOO.util.CustomEvent See <a
 *       href="YAHOO.util.Element.html#addListener">Element.addListener</a> for
 *       more information on listening for this event.
 */
/**
 * @event b4DragOutEvent
 * @description Fires before the dragOutEvent
 * @type YAHOO.util.CustomEvent See <a
 *       href="YAHOO.util.Element.html#addListener">Element.addListener</a> for
 *       more information on listening for this event.
 */
/**
 * @event dragOutEvent
 * @description Fires when a dragged object is no longer over an object that had
 *              the onDragEnter fire.
 * @type YAHOO.util.CustomEvent See <a
 *       href="YAHOO.util.Element.html#addListener">Element.addListener</a> for
 *       more information on listening for this event.
 */
/**
 * @event dragEnterEvent
 * @description Occurs when the dragged object first interacts with another
 *              targettable drag and drop object.
 * @type YAHOO.util.CustomEvent See <a
 *       href="YAHOO.util.Element.html#addListener">Element.addListener</a> for
 *       more information on listening for this event.
 */
/**
 * @event b4DragOverEvent
 * @description Fires before the dragOverEvent.
 * @type YAHOO.util.CustomEvent See <a
 *       href="YAHOO.util.Element.html#addListener">Element.addListener</a> for
 *       more information on listening for this event.
 */
/**
 * @event dragOverEvent
 * @description Fires every mousemove event while over a drag and drop object.
 * @type YAHOO.util.CustomEvent See <a
 *       href="YAHOO.util.Element.html#addListener">Element.addListener</a> for
 *       more information on listening for this event.
 */
/**
 * @event b4DragDropEvent
 * @description Fires before the dragDropEvent
 * @type YAHOO.util.CustomEvent See <a
 *       href="YAHOO.util.Element.html#addListener">Element.addListener</a> for
 *       more information on listening for this event.
 */
/**
 * @event dragDropEvent
 * @description Fires when the dragged objects is dropped on another.
 * @type YAHOO.util.CustomEvent See <a
 *       href="YAHOO.util.Element.html#addListener">Element.addListener</a> for
 *       more information on listening for this event.
 */

});
/**
 * A DragDrop implementation that does not move, but can be a drop target. You
 * would get the same result by simply omitting implementation for the event
 * callbacks, but this way we reduce the processing cost of the event listener
 * and the callbacks.
 * 
 * @class DDTarget
 * @extends YAHOO.util.DragDrop
 * @constructor
 * @param {String}
 *            id the id of the element that is a drop target
 * @param {String}
 *            sGroup the group of related DragDrop objects
 * @param {object}
 *            config an object containing configurable attributes Valid
 *            properties for DDTarget in addition to those in DragDrop: none
 */
YAHOO.util.DDTarget = function(id, sGroup, config) {
    if (id) {
        this.initTarget(id, sGroup, config);
    }
};

// YAHOO.util.DDTarget.prototype = new YAHOO.util.DragDrop();
YAHOO.extend(YAHOO.util.DDTarget, YAHOO.util.DragDrop, {
    toString: function() {
        return ("DDTarget " + this.id);
    }
});
YAHOO.register("dragdrop", YAHOO.util.DragDropMgr, {version: "2.9.0", build: "2800"});
/*
 * Copyright (c) 2011, Yahoo! Inc. All rights reserved. Code licensed under the
 * BSD License: http://developer.yahoo.com/yui/license.html version: 2.9.0
 */
(function () {

    /**
	 * Config is a utility used within an Object to allow the implementer to
	 * maintain a list of local configuration properties and listen for changes
	 * to those properties dynamically using CustomEvent. The initial values are
	 * also maintained so that the configuration can be reset at any given point
	 * to its initial state.
	 * 
	 * @namespace YAHOO.util
	 * @class Config
	 * @constructor
	 * @param {Object}
	 *            owner The owner Object to which this Config Object belongs
	 */
    YAHOO.util.Config = function (owner) {

        if (owner) {
            this.init(owner);
        }


    };


    var Lang = YAHOO.lang,
        CustomEvent = YAHOO.util.CustomEvent,
        Config = YAHOO.util.Config;


    /**
	 * Constant representing the CustomEvent type for the config changed event.
	 * 
	 * @property YAHOO.util.Config.CONFIG_CHANGED_EVENT
	 * @private
	 * @static
	 * @final
	 */
    Config.CONFIG_CHANGED_EVENT = "configChanged";
    
    /**
	 * Constant representing the boolean type string
	 * 
	 * @property YAHOO.util.Config.BOOLEAN_TYPE
	 * @private
	 * @static
	 * @final
	 */
    Config.BOOLEAN_TYPE = "boolean";
    
    Config.prototype = {
     
        /**
		 * Object reference to the owner of this Config Object
		 * 
		 * @property owner
		 * @type Object
		 */
        owner: null,
        
        /**
		 * Boolean flag that specifies whether a queue is currently being
		 * executed
		 * 
		 * @property queueInProgress
		 * @type Boolean
		 */
        queueInProgress: false,
        
        /**
		 * Maintains the local collection of configuration property objects and
		 * their specified values
		 * 
		 * @property config
		 * @private
		 * @type Object
		 */ 
        config: null,
        
        /**
		 * Maintains the local collection of configuration property objects as
		 * they were initially applied. This object is used when resetting a
		 * property.
		 * 
		 * @property initialConfig
		 * @private
		 * @type Object
		 */ 
        initialConfig: null,
        
        /**
		 * Maintains the local, normalized CustomEvent queue
		 * 
		 * @property eventQueue
		 * @private
		 * @type Object
		 */ 
        eventQueue: null,
        
        /**
		 * Custom Event, notifying subscribers when Config properties are set
		 * (setProperty is called without the silent flag
		 * 
		 * @event configChangedEvent
		 */
        configChangedEvent: null,
    
        /**
		 * Initializes the configuration Object and all of its local members.
		 * 
		 * @method init
		 * @param {Object}
		 *            owner The owner Object to which this Config Object belongs
		 */
        init: function (owner) {
    
            this.owner = owner;
    
            this.configChangedEvent = 
                this.createEvent(Config.CONFIG_CHANGED_EVENT);
    
            this.configChangedEvent.signature = CustomEvent.LIST;
            this.queueInProgress = false;
            this.config = {};
            this.initialConfig = {};
            this.eventQueue = [];
        
        },
        
        /**
		 * Validates that the value passed in is a Boolean.
		 * 
		 * @method checkBoolean
		 * @param {Object}
		 *            val The value to validate
		 * @return {Boolean} true, if the value is valid
		 */ 
        checkBoolean: function (val) {
            return (typeof val == Config.BOOLEAN_TYPE);
        },
        
        /**
		 * Validates that the value passed in is a number.
		 * 
		 * @method checkNumber
		 * @param {Object}
		 *            val The value to validate
		 * @return {Boolean} true, if the value is valid
		 */
        checkNumber: function (val) {
            return (!isNaN(val));
        },
        
        /**
		 * Fires a configuration property event using the specified value.
		 * 
		 * @method fireEvent
		 * @private
		 * @param {String}
		 *            key The configuration property's name
		 * @param {value}
		 *            Object The value of the correct type for the property
		 */ 
        fireEvent: function ( key, value ) {
            var property = this.config[key];
        
            if (property && property.event) {
                property.event.fire(value);
            } 
        },
        
        /**
		 * Adds a property to the Config Object's private config hash.
		 * 
		 * @method addProperty
		 * @param {String}
		 *            key The configuration property's name
		 * @param {Object}
		 *            propertyObject The Object containing all of this
		 *            property's arguments
		 */
        addProperty: function ( key, propertyObject ) {
            key = key.toLowerCase();
        
            this.config[key] = propertyObject;
        
            propertyObject.event = this.createEvent(key, { scope: this.owner });
            propertyObject.event.signature = CustomEvent.LIST;
            
            
            propertyObject.key = key;
        
            if (propertyObject.handler) {
                propertyObject.event.subscribe(propertyObject.handler, 
                    this.owner);
            }
        
            this.setProperty(key, propertyObject.value, true);
            
            if (! propertyObject.suppressEvent) {
                this.queueProperty(key, propertyObject.value);
            }
            
        },
        
        /**
		 * Returns a key-value configuration map of the values currently set in
		 * the Config Object.
		 * 
		 * @method getConfig
		 * @return {Object} The current config, represented in a key-value map
		 */
        getConfig: function () {
        
            var cfg = {},
                currCfg = this.config,
                prop,
                property;
                
            for (prop in currCfg) {
                if (Lang.hasOwnProperty(currCfg, prop)) {
                    property = currCfg[prop];
                    if (property && property.event) {
                        cfg[prop] = property.value;
                    }
                }
            }

            return cfg;
        },
        
        /**
		 * Returns the value of specified property.
		 * 
		 * @method getProperty
		 * @param {String}
		 *            key The name of the property
		 * @return {Object} The value of the specified property
		 */
        getProperty: function (key) {
            var property = this.config[key.toLowerCase()];
            if (property && property.event) {
                return property.value;
            } else {
                return undefined;
            }
        },
        
        /**
		 * Resets the specified property's value to its initial value.
		 * 
		 * @method resetProperty
		 * @param {String}
		 *            key The name of the property
		 * @return {Boolean} True is the property was reset, false if not
		 */
        resetProperty: function (key) {
            key = key.toLowerCase();

            var property = this.config[key];

            if (property && property.event) {
                if (key in this.initialConfig) {
                    this.setProperty(key, this.initialConfig[key]);
                    return true;
                }
            } else {
                return false;
            }
        },
        
        /**
		 * Sets the value of a property. If the silent property is passed as
		 * true, the property's event will not be fired.
		 * 
		 * @method setProperty
		 * @param {String}
		 *            key The name of the property
		 * @param {String}
		 *            value The value to set the property to
		 * @param {Boolean}
		 *            silent Whether the value should be set silently, without
		 *            firing the property event.
		 * @return {Boolean} True, if the set was successful, false if it
		 *         failed.
		 */
        setProperty: function (key, value, silent) {
        
            var property;
        
            key = key.toLowerCase();
        
            if (this.queueInProgress && ! silent) {
                // Currently running through a queue...
                this.queueProperty(key,value);
                return true;
    
            } else {
                property = this.config[key];
                if (property && property.event) {
                    if (property.validator && !property.validator(value)) {
                        return false;
                    } else {
                        property.value = value;
                        if (! silent) {
                            this.fireEvent(key, value);
                            this.configChangedEvent.fire([key, value]);
                        }
                        return true;
                    }
                } else {
                    return false;
                }
            }
        },
        
        /**
		 * Sets the value of a property and queues its event to execute. If the
		 * event is already scheduled to execute, it is moved from its current
		 * position to the end of the queue.
		 * 
		 * @method queueProperty
		 * @param {String}
		 *            key The name of the property
		 * @param {String}
		 *            value The value to set the property to
		 * @return {Boolean} true, if the set was successful, false if it
		 *         failed.
		 */ 
        queueProperty: function (key, value) {
        
            key = key.toLowerCase();
        
            var property = this.config[key],
                foundDuplicate = false,
                iLen,
                queueItem,
                queueItemKey,
                queueItemValue,
                sLen,
                supercedesCheck,
                qLen,
                queueItemCheck,
                queueItemCheckKey,
                queueItemCheckValue,
                i,
                s,
                q;
                                
            if (property && property.event) {
    
                if (!Lang.isUndefined(value) && property.validator && 
                    !property.validator(value)) { // validator
                    return false;
                } else {
        
                    if (!Lang.isUndefined(value)) {
                        property.value = value;
                    } else {
                        value = property.value;
                    }
        
                    foundDuplicate = false;
                    iLen = this.eventQueue.length;
        
                    for (i = 0; i < iLen; i++) {
                        queueItem = this.eventQueue[i];
        
                        if (queueItem) {
                            queueItemKey = queueItem[0];
                            queueItemValue = queueItem[1];

                            if (queueItemKey == key) {
    
                                /*
								 * found a dupe... push to end of queue, null
								 * current item, and break
								 */
    
                                this.eventQueue[i] = null;
    
                                this.eventQueue.push(
                                    [key, (!Lang.isUndefined(value) ? 
                                    value : queueItemValue)]);
    
                                foundDuplicate = true;
                                break;
                            }
                        }
                    }
                    
                    // this is a refire, or a new property in the queue
    
                    if (! foundDuplicate && !Lang.isUndefined(value)) { 
                        this.eventQueue.push([key, value]);
                    }
                }
        
                if (property.supercedes) {

                    sLen = property.supercedes.length;

                    for (s = 0; s < sLen; s++) {

                        supercedesCheck = property.supercedes[s];
                        qLen = this.eventQueue.length;

                        for (q = 0; q < qLen; q++) {
                            queueItemCheck = this.eventQueue[q];

                            if (queueItemCheck) {
                                queueItemCheckKey = queueItemCheck[0];
                                queueItemCheckValue = queueItemCheck[1];

                                if (queueItemCheckKey == 
                                    supercedesCheck.toLowerCase() ) {

                                    this.eventQueue.push([queueItemCheckKey, 
                                        queueItemCheckValue]);

                                    this.eventQueue[q] = null;
                                    break;

                                }
                            }
                        }
                    }
                }


                return true;
            } else {
                return false;
            }
        },
        
        /**
		 * Fires the event for a property using the property's current value.
		 * 
		 * @method refireEvent
		 * @param {String}
		 *            key The name of the property
		 */
        refireEvent: function (key) {
    
            key = key.toLowerCase();
        
            var property = this.config[key];
    
            if (property && property.event && 
    
                !Lang.isUndefined(property.value)) {
    
                if (this.queueInProgress) {
    
                    this.queueProperty(key);
    
                } else {
    
                    this.fireEvent(key, property.value);
    
                }
    
            }
        },
        
        /**
		 * Applies a key-value Object literal to the configuration, replacing
		 * any existing values, and queueing the property events. Although the
		 * values will be set, fireQueue() must be called for their associated
		 * events to execute.
		 * 
		 * @method applyConfig
		 * @param {Object}
		 *            userConfig The configuration Object literal
		 * @param {Boolean}
		 *            init When set to true, the initialConfig will be set to
		 *            the userConfig passed in, so that calling a reset will
		 *            reset the properties to the passed values.
		 */
        applyConfig: function (userConfig, init) {
        
            var sKey,
                oConfig;

            if (init) {
                oConfig = {};
                for (sKey in userConfig) {
                    if (Lang.hasOwnProperty(userConfig, sKey)) {
                        oConfig[sKey.toLowerCase()] = userConfig[sKey];
                    }
                }
                this.initialConfig = oConfig;
            }

            for (sKey in userConfig) {
                if (Lang.hasOwnProperty(userConfig, sKey)) {
                    this.queueProperty(sKey, userConfig[sKey]);
                }
            }
        },
        
        /**
		 * Refires the events for all configuration properties using their
		 * current values.
		 * 
		 * @method refresh
		 */
        refresh: function () {

            var prop;

            for (prop in this.config) {
                if (Lang.hasOwnProperty(this.config, prop)) {
                    this.refireEvent(prop);
                }
            }
        },
        
        /**
		 * Fires the normalized list of queued property change events
		 * 
		 * @method fireQueue
		 */
        fireQueue: function () {
        
            var i, 
                queueItem,
                key,
                value,
                property;
        
            this.queueInProgress = true;
            for (i = 0;i < this.eventQueue.length; i++) {
                queueItem = this.eventQueue[i];
                if (queueItem) {
        
                    key = queueItem[0];
                    value = queueItem[1];
                    property = this.config[key];

                    property.value = value;

                    // Clear out queue entry, to avoid it being
                    // re-added to the queue by any queueProperty/supercedes
                    // calls which are invoked during fireEvent
                    this.eventQueue[i] = null;

                    this.fireEvent(key,value);
                }
            }
            
            this.queueInProgress = false;
            this.eventQueue = [];
        },
        
        /**
		 * Subscribes an external handler to the change event for any given
		 * property.
		 * 
		 * @method subscribeToConfigEvent
		 * @param {String}
		 *            key The property name
		 * @param {Function}
		 *            handler The handler function to use subscribe to the
		 *            property's event
		 * @param {Object}
		 *            obj The Object to use for scoping the event handler (see
		 *            CustomEvent documentation)
		 * @param {Boolean}
		 *            overrideContext Optional. If true, will override "this"
		 *            within the handler to map to the scope Object passed into
		 *            the method.
		 * @return {Boolean} True, if the subscription was successful, otherwise
		 *         false.
		 */ 
        subscribeToConfigEvent: function (key, handler, obj, overrideContext) {
    
            var property = this.config[key.toLowerCase()];
    
            if (property && property.event) {
                if (!Config.alreadySubscribed(property.event, handler, obj)) {
                    property.event.subscribe(handler, obj, overrideContext);
                }
                return true;
            } else {
                return false;
            }
    
        },
        
        /**
		 * Unsubscribes an external handler from the change event for any given
		 * property.
		 * 
		 * @method unsubscribeFromConfigEvent
		 * @param {String}
		 *            key The property name
		 * @param {Function}
		 *            handler The handler function to use subscribe to the
		 *            property's event
		 * @param {Object}
		 *            obj The Object to use for scoping the event handler (see
		 *            CustomEvent documentation)
		 * @return {Boolean} True, if the unsubscription was successful,
		 *         otherwise false.
		 */
        unsubscribeFromConfigEvent: function (key, handler, obj) {
            var property = this.config[key.toLowerCase()];
            if (property && property.event) {
                return property.event.unsubscribe(handler, obj);
            } else {
                return false;
            }
        },
        
        /**
		 * Returns a string representation of the Config object
		 * 
		 * @method toString
		 * @return {String} The Config object in string format.
		 */
        toString: function () {
            var output = "Config";
            if (this.owner) {
                output += " [" + this.owner.toString() + "]";
            }
            return output;
        },
        
        /**
		 * Returns a string representation of the Config object's current
		 * CustomEvent queue
		 * 
		 * @method outputEventQueue
		 * @return {String} The string list of CustomEvents currently queued for
		 *         execution
		 */
        outputEventQueue: function () {

            var output = "",
                queueItem,
                q,
                nQueue = this.eventQueue.length;
              
            for (q = 0; q < nQueue; q++) {
                queueItem = this.eventQueue[q];
                if (queueItem) {
                    output += queueItem[0] + "=" + queueItem[1] + ", ";
                }
            }
            return output;
        },

        /**
		 * Sets all properties to null, unsubscribes all listeners from each
		 * property's change event and all listeners from the
		 * configChangedEvent.
		 * 
		 * @method destroy
		 */
        destroy: function () {

            var oConfig = this.config,
                sProperty,
                oProperty;


            for (sProperty in oConfig) {
            
                if (Lang.hasOwnProperty(oConfig, sProperty)) {

                    oProperty = oConfig[sProperty];

                    oProperty.event.unsubscribeAll();
                    oProperty.event = null;

                }
            
            }
            
            this.configChangedEvent.unsubscribeAll();
            
            this.configChangedEvent = null;
            this.owner = null;
            this.config = null;
            this.initialConfig = null;
            this.eventQueue = null;
        
        }

    };
    
    
    
    /**
	 * Checks to determine if a particular function/Object pair are already
	 * subscribed to the specified CustomEvent
	 * 
	 * @method YAHOO.util.Config.alreadySubscribed
	 * @static
	 * @param {YAHOO.util.CustomEvent}
	 *            evt The CustomEvent for which to check the subscriptions
	 * @param {Function}
	 *            fn The function to look for in the subscribers list
	 * @param {Object}
	 *            obj The execution scope Object for the subscription
	 * @return {Boolean} true, if the function/Object pair is already subscribed
	 *         to the CustomEvent passed in
	 */
    Config.alreadySubscribed = function (evt, fn, obj) {
    
        var nSubscribers = evt.subscribers.length,
            subsc,
            i;

        if (nSubscribers > 0) {
            i = nSubscribers - 1;
            do {
                subsc = evt.subscribers[i];
                if (subsc && subsc.obj == obj && subsc.fn == fn) {
                    return true;
                }
            }
            while (i--);
        }

        return false;

    };

    YAHOO.lang.augmentProto(Config, YAHOO.util.EventProvider);

}());
(function () {

    /**
	 * The Container family of components is designed to enable developers to
	 * create different kinds of content-containing modules on the web. Module
	 * and Overlay are the most basic containers, and they can be used directly
	 * or extended to build custom containers. Also part of the Container family
	 * are four UI controls that extend Module and Overlay: Tooltip, Panel,
	 * Dialog, and SimpleDialog.
	 * 
	 * @module container
	 * @title Container
	 * @requires yahoo, dom, event
	 * @optional dragdrop, animation, button
	 */
    
    /**
	 * Module is a JavaScript representation of the Standard Module Format.
	 * Standard Module Format is a simple standard for markup containers where
	 * child nodes representing the header, body, and footer of the content are
	 * denoted using the CSS classes "hd", "bd", and "ft" respectively. Module
	 * is the base class for all other classes in the YUI Container package.
	 * 
	 * @namespace YAHOO.widget
	 * @class Module
	 * @constructor
	 * @param {String}
	 *            el The element ID representing the Module <em>OR</em>
	 * @param {HTMLElement}
	 *            el The element representing the Module
	 * @param {Object}
	 *            userConfig The configuration Object literal containing the
	 *            configuration that should be set for this module. See
	 *            configuration documentation for more details.
	 */
    YAHOO.widget.Module = function (el, userConfig) {
        if (el) {
            this.init(el, userConfig);
        } else {
        }
    };

    var Dom = YAHOO.util.Dom,
        Config = YAHOO.util.Config,
        Event = YAHOO.util.Event,
        CustomEvent = YAHOO.util.CustomEvent,
        Module = YAHOO.widget.Module,
        UA = YAHOO.env.ua,

        m_oModuleTemplate,
        m_oHeaderTemplate,
        m_oBodyTemplate,
        m_oFooterTemplate,

        /**
		 * Constant representing the name of the Module's events
		 * 
		 * @property EVENT_TYPES
		 * @private
		 * @final
		 * @type Object
		 */
        EVENT_TYPES = {
            "BEFORE_INIT": "beforeInit",
            "INIT": "init",
            "APPEND": "append",
            "BEFORE_RENDER": "beforeRender",
            "RENDER": "render",
            "CHANGE_HEADER": "changeHeader",
            "CHANGE_BODY": "changeBody",
            "CHANGE_FOOTER": "changeFooter",
            "CHANGE_CONTENT": "changeContent",
            "DESTROY": "destroy",
            "BEFORE_SHOW": "beforeShow",
            "SHOW": "show",
            "BEFORE_HIDE": "beforeHide",
            "HIDE": "hide"
        },
            
        /**
		 * Constant representing the Module's configuration properties
		 * 
		 * @property DEFAULT_CONFIG
		 * @private
		 * @final
		 * @type Object
		 */
        DEFAULT_CONFIG = {
        
            "VISIBLE": { 
                key: "visible", 
                value: true, 
                validator: YAHOO.lang.isBoolean 
            },

            "EFFECT": {
                key: "effect",
                suppressEvent: true,
                supercedes: ["visible"]
            },

            "MONITOR_RESIZE": {
                key: "monitorresize",
                value: true
            },

            "APPEND_TO_DOCUMENT_BODY": {
                key: "appendtodocumentbody",
                value: false
            }
        };

    /**
	 * Constant representing the prefix path to use for non-secure images
	 * 
	 * @property YAHOO.widget.Module.IMG_ROOT
	 * @static
	 * @final
	 * @type String
	 */
    Module.IMG_ROOT = null;
    
    /**
	 * Constant representing the prefix path to use for securely served images
	 * 
	 * @property YAHOO.widget.Module.IMG_ROOT_SSL
	 * @static
	 * @final
	 * @type String
	 */
    Module.IMG_ROOT_SSL = null;
    
    /**
	 * Constant for the default CSS class name that represents a Module
	 * 
	 * @property YAHOO.widget.Module.CSS_MODULE
	 * @static
	 * @final
	 * @type String
	 */
    Module.CSS_MODULE = "yui-module";
    
    /**
	 * CSS classname representing the module header. NOTE: The classname is
	 * inserted into the DOM as HTML, and should be escaped by the implementor
	 * if coming from an external source.
	 * 
	 * @property YAHOO.widget.Module.CSS_HEADER
	 * @static
	 * @final
	 * @type String
	 */
    Module.CSS_HEADER = "hd";

    /**
	 * CSS classname representing the module body. NOTE: The classname is
	 * inserted into the DOM as HTML, and should be escaped by the implementor
	 * if coming from an external source.
	 * 
	 * @property YAHOO.widget.Module.CSS_BODY
	 * @static
	 * @final
	 * @type String
	 */
    Module.CSS_BODY = "bd";
    
    /**
	 * CSS classname representing the module footer. NOTE: The classname is
	 * inserted into the DOM as HTML, and should be escaped by the implementor
	 * if coming from an external source.
	 * 
	 * @property YAHOO.widget.Module.CSS_FOOTER
	 * @static
	 * @final
	 * @type String
	 */
    Module.CSS_FOOTER = "ft";
    
    /**
	 * Constant representing the url for the "src" attribute of the iframe used
	 * to monitor changes to the browser's base font size
	 * 
	 * @property YAHOO.widget.Module.RESIZE_MONITOR_SECURE_URL
	 * @static
	 * @final
	 * @type String
	 */
    Module.RESIZE_MONITOR_SECURE_URL = "javascript:false;";

    /**
	 * Constant representing the buffer amount (in pixels) to use when
	 * positioning the text resize monitor offscreen. The resize monitor is
	 * positioned offscreen by an amount eqaul to its offsetHeight + the buffer
	 * value.
	 * 
	 * @property YAHOO.widget.Module.RESIZE_MONITOR_BUFFER
	 * @static
	 * @type Number
	 */
    // Set to 1, to work around pixel offset in IE8, which increases when zoom
	// is used
    Module.RESIZE_MONITOR_BUFFER = 1;

    /**
	 * Singleton CustomEvent fired when the font size is changed in the browser.
	 * Opera's "zoom" functionality currently does not support text size
	 * detection.
	 * 
	 * @event YAHOO.widget.Module.textResizeEvent
	 */
    Module.textResizeEvent = new CustomEvent("textResize");

    /**
	 * Helper utility method, which forces a document level redraw for Opera,
	 * which can help remove repaint irregularities after applying DOM changes.
	 * 
	 * @method YAHOO.widget.Module.forceDocumentRedraw
	 * @static
	 */
    Module.forceDocumentRedraw = function() {
        var docEl = document.documentElement;
        if (docEl) {
            docEl.className += " ";
            docEl.className = YAHOO.lang.trim(docEl.className);
        }
    };

    function createModuleTemplate() {

        if (!m_oModuleTemplate) {
            m_oModuleTemplate = document.createElement("div");
            
            m_oModuleTemplate.innerHTML = ("<div class=\"" + 
                Module.CSS_HEADER + "\"></div>" + "<div class=\"" + 
                Module.CSS_BODY + "\"></div><div class=\"" + 
                Module.CSS_FOOTER + "\"></div>");

            m_oHeaderTemplate = m_oModuleTemplate.firstChild;
            m_oBodyTemplate = m_oHeaderTemplate.nextSibling;
            m_oFooterTemplate = m_oBodyTemplate.nextSibling;
        }

        return m_oModuleTemplate;
    }

    function createHeader() {
        if (!m_oHeaderTemplate) {
            createModuleTemplate();
        }
        return (m_oHeaderTemplate.cloneNode(false));
    }

    function createBody() {
        if (!m_oBodyTemplate) {
            createModuleTemplate();
        }
        return (m_oBodyTemplate.cloneNode(false));
    }

    function createFooter() {
        if (!m_oFooterTemplate) {
            createModuleTemplate();
        }
        return (m_oFooterTemplate.cloneNode(false));
    }

    Module.prototype = {

        /**
		 * The class's constructor function
		 * 
		 * @property contructor
		 * @type Function
		 */
        constructor: Module,
        
        /**
		 * The main module element that contains the header, body, and footer
		 * 
		 * @property element
		 * @type HTMLElement
		 */
        element: null,

        /**
		 * The header element, denoted with CSS class "hd"
		 * 
		 * @property header
		 * @type HTMLElement
		 */
        header: null,

        /**
		 * The body element, denoted with CSS class "bd"
		 * 
		 * @property body
		 * @type HTMLElement
		 */
        body: null,

        /**
		 * The footer element, denoted with CSS class "ft"
		 * 
		 * @property footer
		 * @type HTMLElement
		 */
        footer: null,

        /**
		 * The id of the element
		 * 
		 * @property id
		 * @type String
		 */
        id: null,

        /**
		 * A string representing the root path for all images created by a
		 * Module instance.
		 * 
		 * @deprecated It is recommend that any images for a Module be applied
		 *             via CSS using the "background-image" property.
		 * @property imageRoot
		 * @type String
		 */
        imageRoot: Module.IMG_ROOT,

        /**
		 * Initializes the custom events for Module which are fired
		 * automatically at appropriate times by the Module class.
		 * 
		 * @method initEvents
		 */
        initEvents: function () {

            var SIGNATURE = CustomEvent.LIST;

            /**
			 * CustomEvent fired prior to class initalization.
			 * 
			 * @event beforeInitEvent
			 * @param {class}
			 *            classRef class reference of the initializing class,
			 *            such as this.beforeInitEvent.fire(Module)
			 */
            this.beforeInitEvent = this.createEvent(EVENT_TYPES.BEFORE_INIT);
            this.beforeInitEvent.signature = SIGNATURE;

            /**
			 * CustomEvent fired after class initalization.
			 * 
			 * @event initEvent
			 * @param {class}
			 *            classRef class reference of the initializing class,
			 *            such as this.beforeInitEvent.fire(Module)
			 */  
            this.initEvent = this.createEvent(EVENT_TYPES.INIT);
            this.initEvent.signature = SIGNATURE;

            /**
			 * CustomEvent fired when the Module is appended to the DOM
			 * 
			 * @event appendEvent
			 */
            this.appendEvent = this.createEvent(EVENT_TYPES.APPEND);
            this.appendEvent.signature = SIGNATURE;

            /**
			 * CustomEvent fired before the Module is rendered
			 * 
			 * @event beforeRenderEvent
			 */
            this.beforeRenderEvent = this.createEvent(EVENT_TYPES.BEFORE_RENDER);
            this.beforeRenderEvent.signature = SIGNATURE;
        
            /**
			 * CustomEvent fired after the Module is rendered
			 * 
			 * @event renderEvent
			 */
            this.renderEvent = this.createEvent(EVENT_TYPES.RENDER);
            this.renderEvent.signature = SIGNATURE;
        
            /**
			 * CustomEvent fired when the header content of the Module is
			 * modified
			 * 
			 * @event changeHeaderEvent
			 * @param {String/HTMLElement}
			 *            content String/element representing the new header
			 *            content
			 */
            this.changeHeaderEvent = this.createEvent(EVENT_TYPES.CHANGE_HEADER);
            this.changeHeaderEvent.signature = SIGNATURE;
            
            /**
			 * CustomEvent fired when the body content of the Module is modified
			 * 
			 * @event changeBodyEvent
			 * @param {String/HTMLElement}
			 *            content String/element representing the new body
			 *            content
			 */  
            this.changeBodyEvent = this.createEvent(EVENT_TYPES.CHANGE_BODY);
            this.changeBodyEvent.signature = SIGNATURE;
            
            /**
			 * CustomEvent fired when the footer content of the Module is
			 * modified
			 * 
			 * @event changeFooterEvent
			 * @param {String/HTMLElement}
			 *            content String/element representing the new footer
			 *            content
			 */
            this.changeFooterEvent = this.createEvent(EVENT_TYPES.CHANGE_FOOTER);
            this.changeFooterEvent.signature = SIGNATURE;
        
            /**
			 * CustomEvent fired when the content of the Module is modified
			 * 
			 * @event changeContentEvent
			 */
            this.changeContentEvent = this.createEvent(EVENT_TYPES.CHANGE_CONTENT);
            this.changeContentEvent.signature = SIGNATURE;

            /**
			 * CustomEvent fired when the Module is destroyed
			 * 
			 * @event destroyEvent
			 */
            this.destroyEvent = this.createEvent(EVENT_TYPES.DESTROY);
            this.destroyEvent.signature = SIGNATURE;

            /**
			 * CustomEvent fired before the Module is shown
			 * 
			 * @event beforeShowEvent
			 */
            this.beforeShowEvent = this.createEvent(EVENT_TYPES.BEFORE_SHOW);
            this.beforeShowEvent.signature = SIGNATURE;

            /**
			 * CustomEvent fired after the Module is shown
			 * 
			 * @event showEvent
			 */
            this.showEvent = this.createEvent(EVENT_TYPES.SHOW);
            this.showEvent.signature = SIGNATURE;

            /**
			 * CustomEvent fired before the Module is hidden
			 * 
			 * @event beforeHideEvent
			 */
            this.beforeHideEvent = this.createEvent(EVENT_TYPES.BEFORE_HIDE);
            this.beforeHideEvent.signature = SIGNATURE;

            /**
			 * CustomEvent fired after the Module is hidden
			 * 
			 * @event hideEvent
			 */
            this.hideEvent = this.createEvent(EVENT_TYPES.HIDE);
            this.hideEvent.signature = SIGNATURE;
        }, 

        /**
		 * String identifying whether the current platform is windows or mac.
		 * This property currently only identifies these 2 platforms, and
		 * returns false otherwise.
		 * 
		 * @property platform
		 * @deprecated Use YAHOO.env.ua
		 * @type {String|Boolean}
		 */
        platform: function () {
            var ua = navigator.userAgent.toLowerCase();

            if (ua.indexOf("windows") != -1 || ua.indexOf("win32") != -1) {
                return "windows";
            } else if (ua.indexOf("macintosh") != -1) {
                return "mac";
            } else {
                return false;
            }
        }(),
        
        /**
		 * String representing the user-agent of the browser
		 * 
		 * @deprecated Use YAHOO.env.ua
		 * @property browser
		 * @type {String|Boolean}
		 */
        browser: function () {
            var ua = navigator.userAgent.toLowerCase();
            /*
			 * Check Opera first in case of spoof and check Safari before Gecko
			 * since Safari's user agent string includes "like Gecko"
			 */
            if (ua.indexOf('opera') != -1) { 
                return 'opera';
            } else if (ua.indexOf('msie 7') != -1) {
                return 'ie7';
            } else if (ua.indexOf('msie') != -1) {
                return 'ie';
            } else if (ua.indexOf('safari') != -1) { 
                return 'safari';
            } else if (ua.indexOf('gecko') != -1) {
                return 'gecko';
            } else {
                return false;
            }
        }(),
        
        /**
		 * Boolean representing whether or not the current browsing context is
		 * secure (https)
		 * 
		 * @property isSecure
		 * @type Boolean
		 */
        isSecure: function () {
            if (window.location.href.toLowerCase().indexOf("https") === 0) {
                return true;
            } else {
                return false;
            }
        }(),
        
        /**
		 * Initializes the custom events for Module which are fired
		 * automatically at appropriate times by the Module class.
		 */
        initDefaultConfig: function () {
            // Add properties //
            /**
			 * Specifies whether the Module is visible on the page.
			 * 
			 * @config visible
			 * @type Boolean
			 * @default true
			 */
            this.cfg.addProperty(DEFAULT_CONFIG.VISIBLE.key, {
                handler: this.configVisible, 
                value: DEFAULT_CONFIG.VISIBLE.value, 
                validator: DEFAULT_CONFIG.VISIBLE.validator
            });

            /**
			 * <p>
			 * Object or array of objects representing the ContainerEffect
			 * classes that are active for animating the container.
			 * </p>
			 * <p>
			 * <strong>NOTE:</strong> Although this configuration property is
			 * introduced at the Module level, an out of the box implementation
			 * is not shipped for the Module class so setting the proroperty on
			 * the Module class has no effect. The Overlay class is the first
			 * class to provide out of the box ContainerEffect support.
			 * </p>
			 * 
			 * @config effect
			 * @type Object
			 * @default null
			 */
            this.cfg.addProperty(DEFAULT_CONFIG.EFFECT.key, {
                handler: this.configEffect,
                suppressEvent: DEFAULT_CONFIG.EFFECT.suppressEvent, 
                supercedes: DEFAULT_CONFIG.EFFECT.supercedes
            });

            /**
			 * Specifies whether to create a special proxy iframe to monitor for
			 * user font resizing in the document
			 * 
			 * @config monitorresize
			 * @type Boolean
			 * @default true
			 */
            this.cfg.addProperty(DEFAULT_CONFIG.MONITOR_RESIZE.key, {
                handler: this.configMonitorResize,
                value: DEFAULT_CONFIG.MONITOR_RESIZE.value
            });

            /**
			 * Specifies if the module should be rendered as the first child of
			 * document.body or appended as the last child when render is called
			 * with document.body as the "appendToNode".
			 * <p>
			 * Appending to the body while the DOM is still being constructed
			 * can lead to Operation Aborted errors in IE hence this flag is set
			 * to false by default.
			 * </p>
			 * 
			 * @config appendtodocumentbody
			 * @type Boolean
			 * @default false
			 */
            this.cfg.addProperty(DEFAULT_CONFIG.APPEND_TO_DOCUMENT_BODY.key, {
                value: DEFAULT_CONFIG.APPEND_TO_DOCUMENT_BODY.value
            });
        },

        /**
		 * The Module class's initialization method, which is executed for
		 * Module and all of its subclasses. This method is automatically called
		 * by the constructor, and sets up all DOM references for pre-existing
		 * markup, and creates required markup if it is not already present.
		 * <p>
		 * If the element passed in does not have an id, one will be generated
		 * for it.
		 * </p>
		 * 
		 * @method init
		 * @param {String}
		 *            el The element ID representing the Module <em>OR</em>
		 * @param {HTMLElement}
		 *            el The element representing the Module
		 * @param {Object}
		 *            userConfig The configuration Object literal containing the
		 *            configuration that should be set for this module. See
		 *            configuration documentation for more details.
		 */
        init: function (el, userConfig) {

            var elId, child;

            this.initEvents();
            this.beforeInitEvent.fire(Module);

            /**
			 * The Module's Config object used for monitoring configuration
			 * properties.
			 * 
			 * @property cfg
			 * @type YAHOO.util.Config
			 */
            this.cfg = new Config(this);

            if (this.isSecure) {
                this.imageRoot = Module.IMG_ROOT_SSL;
            }

            if (typeof el == "string") {
                elId = el;
                el = document.getElementById(el);
                if (! el) {
                    el = (createModuleTemplate()).cloneNode(false);
                    el.id = elId;
                }
            }

            this.id = Dom.generateId(el);
            this.element = el;

            child = this.element.firstChild;

            if (child) {
                var fndHd = false, fndBd = false, fndFt = false;
                do {
                    // We're looking for elements
                    if (1 == child.nodeType) {
                        if (!fndHd && Dom.hasClass(child, Module.CSS_HEADER)) {
                            this.header = child;
                            fndHd = true;
                        } else if (!fndBd && Dom.hasClass(child, Module.CSS_BODY)) {
                            this.body = child;
                            fndBd = true;
                        } else if (!fndFt && Dom.hasClass(child, Module.CSS_FOOTER)){
                            this.footer = child;
                            fndFt = true;
                        }
                    }
                } while ((child = child.nextSibling));
            }

            this.initDefaultConfig();

            Dom.addClass(this.element, Module.CSS_MODULE);

            if (userConfig) {
                this.cfg.applyConfig(userConfig, true);
            }

            /*
			 * Subscribe to the fireQueue() method of Config so that any queued
			 * configuration changes are excecuted upon render of the Module
			 */ 

            if (!Config.alreadySubscribed(this.renderEvent, this.cfg.fireQueue, this.cfg)) {
                this.renderEvent.subscribe(this.cfg.fireQueue, this.cfg, true);
            }

            this.initEvent.fire(Module);
        },

        /**
		 * Initialize an empty IFRAME that is placed out of the visible area
		 * that can be used to detect text resize.
		 * 
		 * @method initResizeMonitor
		 */
        initResizeMonitor: function () {

            var isGeckoWin = (UA.gecko && this.platform == "windows");
            if (isGeckoWin) {
                // Help prevent spinning loading icon which
                // started with FireFox 2.0.0.8/Win
                var self = this;
                setTimeout(function(){self._initResizeMonitor();}, 0);
            } else {
                this._initResizeMonitor();
            }
        },

        /**
		 * Create and initialize the text resize monitoring iframe.
		 * 
		 * @protected
		 * @method _initResizeMonitor
		 */
        _initResizeMonitor : function() {

            var oDoc, 
                oIFrame, 
                sHTML;

            function fireTextResize() {
                Module.textResizeEvent.fire();
            }

            if (!UA.opera) {
                oIFrame = Dom.get("_yuiResizeMonitor");

                var supportsCWResize = this._supportsCWResize();

                if (!oIFrame) {
                    oIFrame = document.createElement("iframe");

                    if (this.isSecure && Module.RESIZE_MONITOR_SECURE_URL && UA.ie) {
                        oIFrame.src = Module.RESIZE_MONITOR_SECURE_URL;
                    }

                    if (!supportsCWResize) {
                        // Can't monitor on contentWindow, so fire from inside
						// iframe
                        sHTML = ["<html><head><script ",
                                 "type=\"text/javascript\">",
                                 "window.onresize=function(){window.parent.",
                                 "YAHOO.widget.Module.textResizeEvent.",
                                 "fire();};<",
                                 "\/script></head>",
                                 "<body></body></html>"].join('');

                        oIFrame.src = "data:text/html;charset=utf-8," + encodeURIComponent(sHTML);
                    }

                    oIFrame.id = "_yuiResizeMonitor";
                    oIFrame.title = "Text Resize Monitor";
                    oIFrame.tabIndex = -1;
                    oIFrame.setAttribute("role", "presentation");

                    /*
					 * Need to set "position" property before inserting the
					 * iframe into the document or Safari's status bar will
					 * forever indicate the iframe is loading (See YUILibrary
					 * bug #1723064)
					 */
                    oIFrame.style.position = "absolute";
                    oIFrame.style.visibility = "hidden";

                    var db = document.body,
                        fc = db.firstChild;
                    if (fc) {
                        db.insertBefore(oIFrame, fc);
                    } else {
                        db.appendChild(oIFrame);
                    }

                    // Setting the background color fixes an issue with IE6/IE7,
					// where
                    // elements in the DOM, with -ve margin-top which positioned
					// them
                    // offscreen (so they would be overlapped by the iframe and
					// its -ve top
                    // setting), would have their -ve margin-top ignored, when
					// the iframe
                    // was added.
                    oIFrame.style.backgroundColor = "transparent";

                    oIFrame.style.borderWidth = "0";
                    oIFrame.style.width = "2em";
                    oIFrame.style.height = "2em";
                    oIFrame.style.left = "0";
                    oIFrame.style.top = (-1 * (oIFrame.offsetHeight + Module.RESIZE_MONITOR_BUFFER)) + "px";
                    oIFrame.style.visibility = "visible";

                    /*
					 * Don't open/close the document for Gecko like we used to,
					 * since it leads to duplicate cookies. (See YUILibrary bug
					 * #1721755)
					 */
                    if (UA.webkit) {
                        oDoc = oIFrame.contentWindow.document;
                        oDoc.open();
                        oDoc.close();
                    }
                }

                if (oIFrame && oIFrame.contentWindow) {
                    Module.textResizeEvent.subscribe(this.onDomResize, this, true);

                    if (!Module.textResizeInitialized) {
                        if (supportsCWResize) {
                            if (!Event.on(oIFrame.contentWindow, "resize", fireTextResize)) {
                                /*
								 * This will fail in IE if document.domain has
								 * changed, so we must change the listener to
								 * use the oIFrame element instead
								 */
                                Event.on(oIFrame, "resize", fireTextResize);
                            }
                        }
                        Module.textResizeInitialized = true;
                    }
                    this.resizeMonitor = oIFrame;
                }
            }
        },

        /**
		 * Text resize monitor helper method. Determines if the browser supports
		 * resize events on iframe content windows.
		 * 
		 * @private
		 * @method _supportsCWResize
		 */
        _supportsCWResize : function() {
            /*
			 * Gecko 1.8.0 (FF1.5), 1.8.1.0-5 (FF2) won't fire resize on
			 * contentWindow. Gecko 1.8.1.6+ (FF2.0.0.6+) and all other browsers
			 * will fire resize on contentWindow.
			 * 
			 * We don't want to start sniffing for patch versions, so fire
			 * textResize the same way on all FF2 flavors
			 */
            var bSupported = true;
            if (UA.gecko && UA.gecko <= 1.8) {
                bSupported = false;
            }
            return bSupported;
        },

        /**
		 * Event handler fired when the resize monitor element is resized.
		 * 
		 * @method onDomResize
		 * @param {DOMEvent}
		 *            e The DOM resize event
		 * @param {Object}
		 *            obj The scope object passed to the handler
		 */
        onDomResize: function (e, obj) {

            var nTop = -1 * (this.resizeMonitor.offsetHeight + Module.RESIZE_MONITOR_BUFFER);

            this.resizeMonitor.style.top = nTop + "px";
            this.resizeMonitor.style.left = "0";
        },

        /**
		 * Sets the Module's header content to the markup specified, or appends
		 * the passed element to the header.
		 * 
		 * If no header is present, one will be automatically created. An empty
		 * string can be passed to the method to clear the contents of the
		 * header.
		 * 
		 * @method setHeader
		 * @param {HTML}
		 *            headerContent The markup used to set the header content.
		 *            As a convenience, non HTMLElement objects can also be
		 *            passed into the method, and will be treated as strings,
		 *            with the header innerHTML set to their default toString
		 *            implementations.
		 * 
		 * <p>
		 * NOTE: Markup passed into this method is added to the DOM as HTML, and
		 * should be escaped by the implementor if coming from an external
		 * source.
		 * </p>
		 * 
		 * <em>OR</em>
		 * @param {HTMLElement}
		 *            headerContent The HTMLElement to append to <em>OR</em>
		 * @param {DocumentFragment}
		 *            headerContent The document fragment containing elements
		 *            which are to be added to the header
		 */
        setHeader: function (headerContent) {
            var oHeader = this.header || (this.header = createHeader());

            if (headerContent.nodeName) {
                oHeader.innerHTML = "";
                oHeader.appendChild(headerContent);
            } else {
                oHeader.innerHTML = headerContent;
            }

            if (this._rendered) {
                this._renderHeader();
            }

            this.changeHeaderEvent.fire(headerContent);
            this.changeContentEvent.fire();

        },

        /**
		 * Appends the passed element to the header. If no header is present,
		 * one will be automatically created.
		 * 
		 * @method appendToHeader
		 * @param {HTMLElement |
		 *            DocumentFragment} element The element to append to the
		 *            header. In the case of a document fragment, the children
		 *            of the fragment will be appended to the header.
		 */
        appendToHeader: function (element) {
            var oHeader = this.header || (this.header = createHeader());

            oHeader.appendChild(element);

            this.changeHeaderEvent.fire(element);
            this.changeContentEvent.fire();

        },

        /**
		 * Sets the Module's body content to the HTML specified.
		 * 
		 * If no body is present, one will be automatically created.
		 * 
		 * An empty string can be passed to the method to clear the contents of
		 * the body.
		 * 
		 * @method setBody
		 * @param {HTML}
		 *            bodyContent The HTML used to set the body content As a
		 *            convenience, non HTMLElement objects can also be passed
		 *            into the method, and will be treated as strings, with the
		 *            body innerHTML set to their default toString
		 *            implementations.
		 * 
		 * <p>
		 * NOTE: Markup passed into this method is added to the DOM as HTML, and
		 * should be escaped by the implementor if coming from an external
		 * source.
		 * </p>
		 * 
		 * <em>OR</em>
		 * @param {HTMLElement}
		 *            bodyContent The HTMLElement to add as the first and only
		 *            child of the body element. <em>OR</em>
		 * @param {DocumentFragment}
		 *            bodyContent The document fragment containing elements
		 *            which are to be added to the body
		 */
        setBody: function (bodyContent) {
            var oBody = this.body || (this.body = createBody());

            if (bodyContent.nodeName) {
                oBody.innerHTML = "";
                oBody.appendChild(bodyContent);
            } else {
                oBody.innerHTML = bodyContent;
            }

            if (this._rendered) {
                this._renderBody();
            }

            this.changeBodyEvent.fire(bodyContent);
            this.changeContentEvent.fire();
        },

        /**
		 * Appends the passed element to the body. If no body is present, one
		 * will be automatically created.
		 * 
		 * @method appendToBody
		 * @param {HTMLElement |
		 *            DocumentFragment} element The element to append to the
		 *            body. In the case of a document fragment, the children of
		 *            the fragment will be appended to the body.
		 * 
		 */
        appendToBody: function (element) {
            var oBody = this.body || (this.body = createBody());
        
            oBody.appendChild(element);

            this.changeBodyEvent.fire(element);
            this.changeContentEvent.fire();

        },

        /**
		 * Sets the Module's footer content to the HTML specified, or appends
		 * the passed element to the footer. If no footer is present, one will
		 * be automatically created. An empty string can be passed to the method
		 * to clear the contents of the footer.
		 * 
		 * @method setFooter
		 * @param {HTML}
		 *            footerContent The HTML used to set the footer As a
		 *            convenience, non HTMLElement objects can also be passed
		 *            into the method, and will be treated as strings, with the
		 *            footer innerHTML set to their default toString
		 *            implementations.
		 * 
		 * <p>
		 * NOTE: Markup passed into this method is added to the DOM as HTML, and
		 * should be escaped by the implementor if coming from an external
		 * source.
		 * </p>
		 * 
		 * <em>OR</em>
		 * @param {HTMLElement}
		 *            footerContent The HTMLElement to append to the footer
		 *            <em>OR</em>
		 * @param {DocumentFragment}
		 *            footerContent The document fragment containing elements
		 *            which are to be added to the footer
		 */
        setFooter: function (footerContent) {

            var oFooter = this.footer || (this.footer = createFooter());

            if (footerContent.nodeName) {
                oFooter.innerHTML = "";
                oFooter.appendChild(footerContent);
            } else {
                oFooter.innerHTML = footerContent;
            }

            if (this._rendered) {
                this._renderFooter();
            }

            this.changeFooterEvent.fire(footerContent);
            this.changeContentEvent.fire();
        },

        /**
		 * Appends the passed element to the footer. If no footer is present,
		 * one will be automatically created.
		 * 
		 * @method appendToFooter
		 * @param {HTMLElement |
		 *            DocumentFragment} element The element to append to the
		 *            footer. In the case of a document fragment, the children
		 *            of the fragment will be appended to the footer
		 */
        appendToFooter: function (element) {

            var oFooter = this.footer || (this.footer = createFooter());

            oFooter.appendChild(element);

            this.changeFooterEvent.fire(element);
            this.changeContentEvent.fire();

        },

        /**
		 * Renders the Module by inserting the elements that are not already in
		 * the main Module into their correct places. Optionally appends the
		 * Module to the specified node prior to the render's execution.
		 * <p>
		 * For Modules without existing markup, the appendToNode argument is
		 * REQUIRED. If this argument is ommitted and the current element is not
		 * present in the document, the function will return false, indicating
		 * that the render was a failure.
		 * </p>
		 * <p>
		 * NOTE: As of 2.3.1, if the appendToNode is the document's body element
		 * then the module is rendered as the first child of the body element,
		 * and not appended to it, to avoid Operation Aborted errors in IE when
		 * rendering the module before window's load event is fired. You can use
		 * the appendtodocumentbody configuration property to change this to
		 * append to document.body if required.
		 * </p>
		 * 
		 * @method render
		 * @param {String}
		 *            appendToNode The element id to which the Module should be
		 *            appended to prior to rendering <em>OR</em>
		 * @param {HTMLElement}
		 *            appendToNode The element to which the Module should be
		 *            appended to prior to rendering
		 * @param {HTMLElement}
		 *            moduleElement OPTIONAL. The element that represents the
		 *            actual Standard Module container.
		 * @return {Boolean} Success or failure of the render
		 */
        render: function (appendToNode, moduleElement) {

            var me = this;

            function appendTo(parentNode) {
                if (typeof parentNode == "string") {
                    parentNode = document.getElementById(parentNode);
                }

                if (parentNode) {
                    me._addToParent(parentNode, me.element);
                    me.appendEvent.fire();
                }
            }

            this.beforeRenderEvent.fire();

            if (! moduleElement) {
                moduleElement = this.element;
            }

            if (appendToNode) {
                appendTo(appendToNode);
            } else { 
                // No node was passed in. If the element is not already in the
				// Dom, this fails
                if (! Dom.inDocument(this.element)) {
                    return false;
                }
            }

            this._renderHeader(moduleElement);
            this._renderBody(moduleElement);
            this._renderFooter(moduleElement);

            this._rendered = true;

            this.renderEvent.fire();
            return true;
        },

        /**
		 * Renders the currently set header into it's proper position under the
		 * module element. If the module element is not provided, "this.element"
		 * is used.
		 * 
		 * @method _renderHeader
		 * @protected
		 * @param {HTMLElement}
		 *            moduleElement Optional. A reference to the module element
		 */
        _renderHeader: function(moduleElement){
            moduleElement = moduleElement || this.element;

            // Need to get everything into the DOM if it isn't already
            if (this.header && !Dom.inDocument(this.header)) {
                // There is a header, but it's not in the DOM yet. Need to add
				// it.
                var firstChild = moduleElement.firstChild;
                if (firstChild) {
                    moduleElement.insertBefore(this.header, firstChild);
                } else {
                    moduleElement.appendChild(this.header);
                }
            }
        },

        /**
		 * Renders the currently set body into it's proper position under the
		 * module element. If the module element is not provided, "this.element"
		 * is used.
		 * 
		 * @method _renderBody
		 * @protected
		 * @param {HTMLElement}
		 *            moduleElement Optional. A reference to the module element.
		 */
        _renderBody: function(moduleElement){
            moduleElement = moduleElement || this.element;

            if (this.body && !Dom.inDocument(this.body)) {
                // There is a body, but it's not in the DOM yet. Need to add it.
                if (this.footer && Dom.isAncestor(moduleElement, this.footer)) {
                    moduleElement.insertBefore(this.body, this.footer);
                } else {
                    moduleElement.appendChild(this.body);
                }
            }
        },

        /**
		 * Renders the currently set footer into it's proper position under the
		 * module element. If the module element is not provided, "this.element"
		 * is used.
		 * 
		 * @method _renderFooter
		 * @protected
		 * @param {HTMLElement}
		 *            moduleElement Optional. A reference to the module element
		 */
        _renderFooter: function(moduleElement){
            moduleElement = moduleElement || this.element;

            if (this.footer && !Dom.inDocument(this.footer)) {
                // There is a footer, but it's not in the DOM yet. Need to add
				// it.
                moduleElement.appendChild(this.footer);
            }
        },

        /**
		 * Removes the Module element from the DOM, sets all child elements to
		 * null, and purges the bounding element of event listeners.
		 * 
		 * @method destroy
		 * @param {boolean}
		 *            shallowPurge If true, only the parent element's DOM event
		 *            listeners are purged. If false, or not provided, all
		 *            children are also purged of DOM event listeners. NOTE: The
		 *            flag is a "shallowPurge" flag, as opposed to what may be a
		 *            more intuitive "purgeChildren" flag to maintain backwards
		 *            compatibility with behavior prior to 2.9.0.
		 */
        destroy: function (shallowPurge) {

            var parent,
                purgeChildren = !(shallowPurge);

            if (this.element) {
                Event.purgeElement(this.element, purgeChildren);
                parent = this.element.parentNode;
            }

            if (parent) {
                parent.removeChild(this.element);
            }
        
            this.element = null;
            this.header = null;
            this.body = null;
            this.footer = null;

            Module.textResizeEvent.unsubscribe(this.onDomResize, this);

            this.cfg.destroy();
            this.cfg = null;

            this.destroyEvent.fire();
        },

        /**
		 * Shows the Module element by setting the visible configuration
		 * property to true. Also fires two events: beforeShowEvent prior to the
		 * visibility change, and showEvent after.
		 * 
		 * @method show
		 */
        show: function () {
            this.cfg.setProperty("visible", true);
        },

        /**
		 * Hides the Module element by setting the visible configuration
		 * property to false. Also fires two events: beforeHideEvent prior to
		 * the visibility change, and hideEvent after.
		 * 
		 * @method hide
		 */
        hide: function () {
            this.cfg.setProperty("visible", false);
        },
        
        // BUILT-IN EVENT HANDLERS FOR MODULE //
        /**
		 * Default event handler for changing the visibility property of a
		 * Module. By default, this is achieved by switching the "display" style
		 * between "block" and "none". This method is responsible for firing
		 * showEvent and hideEvent.
		 * 
		 * @param {String}
		 *            type The CustomEvent type (usually the property name)
		 * @param {Object[]}
		 *            args The CustomEvent arguments. For configuration
		 *            handlers, args[0] will equal the newly applied value for
		 *            the property.
		 * @param {Object}
		 *            obj The scope object. For configuration handlers, this
		 *            will usually equal the owner.
		 * @method configVisible
		 */
        configVisible: function (type, args, obj) {
            var visible = args[0];
            if (visible) {
                if(this.beforeShowEvent.fire()) {
                    Dom.setStyle(this.element, "display", "block");
                    this.showEvent.fire();
                }
            } else {
                if (this.beforeHideEvent.fire()) {
                    Dom.setStyle(this.element, "display", "none");
                    this.hideEvent.fire();
                }
            }
        },

        /**
		 * Default event handler for the "effect" configuration property
		 * 
		 * @param {String}
		 *            type The CustomEvent type (usually the property name)
		 * @param {Object[]}
		 *            args The CustomEvent arguments. For configuration
		 *            handlers, args[0] will equal the newly applied value for
		 *            the property.
		 * @param {Object}
		 *            obj The scope object. For configuration handlers, this
		 *            will usually equal the owner.
		 * @method configEffect
		 */
        configEffect: function (type, args, obj) {
            this._cachedEffects = (this.cacheEffects) ? this._createEffects(args[0]) : null;
        },

        /**
		 * If true, ContainerEffects (and Anim instances) are cached when
		 * "effect" is set, and reused. If false, new instances are created each
		 * time the container is hidden or shown, as was the behavior prior to
		 * 2.9.0.
		 * 
		 * @property cacheEffects
		 * @since 2.9.0
		 * @default true
		 * @type boolean
		 */
        cacheEffects : true,

        /**
		 * Creates an array of ContainerEffect instances from the provided
		 * configs
		 * 
		 * @method _createEffects
		 * @param {Array|Object}
		 *            effectCfg An effect configuration or array of effect
		 *            configurations
		 * @return {Array} An array of ContainerEffect instances.
		 * @protected
		 */
        _createEffects: function(effectCfg) {
            var effectInstances = null,
                n, 
                i,
                eff;

            if (effectCfg) {
                if (effectCfg instanceof Array) {
                    effectInstances = [];
                    n = effectCfg.length;
                    for (i = 0; i < n; i++) {
                        eff = effectCfg[i];
                        if (eff.effect) {
                            effectInstances[effectInstances.length] = eff.effect(this, eff.duration);
                        }
                    }
                } else if (effectCfg.effect) {
                    effectInstances = [effectCfg.effect(this, effectCfg.duration)];
                }
            }

            return effectInstances;
        },

        /**
		 * Default event handler for the "monitorresize" configuration property
		 * 
		 * @param {String}
		 *            type The CustomEvent type (usually the property name)
		 * @param {Object[]}
		 *            args The CustomEvent arguments. For configuration
		 *            handlers, args[0] will equal the newly applied value for
		 *            the property.
		 * @param {Object}
		 *            obj The scope object. For configuration handlers, this
		 *            will usually equal the owner.
		 * @method configMonitorResize
		 */
        configMonitorResize: function (type, args, obj) {
            var monitor = args[0];
            if (monitor) {
                this.initResizeMonitor();
            } else {
                Module.textResizeEvent.unsubscribe(this.onDomResize, this, true);
                this.resizeMonitor = null;
            }
        },

        /**
		 * This method is a protected helper, used when constructing the DOM
		 * structure for the module to account for situations which may cause
		 * Operation Aborted errors in IE. It should not be used for general DOM
		 * construction.
		 * <p>
		 * If the parentNode is not document.body, the element is appended as
		 * the last element.
		 * </p>
		 * <p>
		 * If the parentNode is document.body the element is added as the first
		 * child to help prevent Operation Aborted errors in IE.
		 * </p>
		 * 
		 * @param {parentNode}
		 *            The HTML element to which the element will be added
		 * @param {element}
		 *            The HTML element to be added to parentNode's children
		 * @method _addToParent
		 * @protected
		 */
        _addToParent: function(parentNode, element) {
            if (!this.cfg.getProperty("appendtodocumentbody") && parentNode === document.body && parentNode.firstChild) {
                parentNode.insertBefore(element, parentNode.firstChild);
            } else {
                parentNode.appendChild(element);
            }
        },

        /**
		 * Returns a String representation of the Object.
		 * 
		 * @method toString
		 * @return {String} The string representation of the Module
		 */
        toString: function () {
            return "Module " + this.id;
        }
    };

    YAHOO.lang.augmentProto(Module, YAHOO.util.EventProvider);

}());
(function () {

    /**
	 * Overlay is a Module that is absolutely positioned above the page flow. It
	 * has convenience methods for positioning and sizing, as well as options
	 * for controlling zIndex and constraining the Overlay's position to the
	 * current visible viewport. Overlay also contains a dynamicly generated
	 * IFRAME which is placed beneath it for Internet Explorer 6 and 5.x so that
	 * it will be properly rendered above SELECT elements.
	 * 
	 * @namespace YAHOO.widget
	 * @class Overlay
	 * @extends YAHOO.widget.Module
	 * @param {String}
	 *            el The element ID representing the Overlay <em>OR</em>
	 * @param {HTMLElement}
	 *            el The element representing the Overlay
	 * @param {Object}
	 *            userConfig The configuration object literal containing the
	 *            configuration that should be set for this Overlay. See
	 *            configuration documentation for more details.
	 * @constructor
	 */
    YAHOO.widget.Overlay = function (el, userConfig) {
        YAHOO.widget.Overlay.superclass.constructor.call(this, el, userConfig);
    };

    var Lang = YAHOO.lang,
        CustomEvent = YAHOO.util.CustomEvent,
        Module = YAHOO.widget.Module,
        Event = YAHOO.util.Event,
        Dom = YAHOO.util.Dom,
        Config = YAHOO.util.Config,
        UA = YAHOO.env.ua,
        Overlay = YAHOO.widget.Overlay,

        _SUBSCRIBE = "subscribe",
        _UNSUBSCRIBE = "unsubscribe",
        _CONTAINED = "contained",

        m_oIFrameTemplate,

        /**
		 * Constant representing the name of the Overlay's events
		 * 
		 * @property EVENT_TYPES
		 * @private
		 * @final
		 * @type Object
		 */
        EVENT_TYPES = {
            "BEFORE_MOVE": "beforeMove",
            "MOVE": "move"
        },

        /**
		 * Constant representing the Overlay's configuration properties
		 * 
		 * @property DEFAULT_CONFIG
		 * @private
		 * @final
		 * @type Object
		 */
        DEFAULT_CONFIG = {

            "X": { 
                key: "x", 
                validator: Lang.isNumber, 
                suppressEvent: true, 
                supercedes: ["iframe"]
            },

            "Y": { 
                key: "y", 
                validator: Lang.isNumber, 
                suppressEvent: true, 
                supercedes: ["iframe"]
            },

            "XY": { 
                key: "xy", 
                suppressEvent: true, 
                supercedes: ["iframe"] 
            },

            "CONTEXT": { 
                key: "context", 
                suppressEvent: true, 
                supercedes: ["iframe"] 
            },

            "FIXED_CENTER": { 
                key: "fixedcenter", 
                value: false, 
                supercedes: ["iframe", "visible"] 
            },

            "WIDTH": { 
                key: "width",
                suppressEvent: true,
                supercedes: ["context", "fixedcenter", "iframe"]
            }, 

            "HEIGHT": { 
                key: "height", 
                suppressEvent: true, 
                supercedes: ["context", "fixedcenter", "iframe"] 
            },

            "AUTO_FILL_HEIGHT" : {
                key: "autofillheight",
                supercedes: ["height"],
                value:"body"
            },

            "ZINDEX": { 
                key: "zindex", 
                value: null 
            },

            "CONSTRAIN_TO_VIEWPORT": { 
                key: "constraintoviewport", 
                value: false, 
                validator: Lang.isBoolean, 
                supercedes: ["iframe", "x", "y", "xy"]
            }, 

            "IFRAME": { 
                key: "iframe", 
                value: (UA.ie == 6 ? true : false), 
                validator: Lang.isBoolean, 
                supercedes: ["zindex"] 
            },

            "PREVENT_CONTEXT_OVERLAP": {
                key: "preventcontextoverlap",
                value: false,
                validator: Lang.isBoolean,  
                supercedes: ["constraintoviewport"]
            }

        };

    /**
	 * The URL that will be placed in the iframe
	 * 
	 * @property YAHOO.widget.Overlay.IFRAME_SRC
	 * @static
	 * @final
	 * @type String
	 */
    Overlay.IFRAME_SRC = "javascript:false;";

    /**
	 * Number representing how much the iframe shim should be offset from each
	 * side of an Overlay instance, in pixels.
	 * 
	 * @property YAHOO.widget.Overlay.IFRAME_SRC
	 * @default 3
	 * @static
	 * @final
	 * @type Number
	 */
    Overlay.IFRAME_OFFSET = 3;

    /**
	 * Number representing the minimum distance an Overlay instance should be
	 * positioned relative to the boundaries of the browser's viewport, in
	 * pixels.
	 * 
	 * @property YAHOO.widget.Overlay.VIEWPORT_OFFSET
	 * @default 10
	 * @static
	 * @final
	 * @type Number
	 */
    Overlay.VIEWPORT_OFFSET = 10;

    /**
	 * Constant representing the top left corner of an element, used for
	 * configuring the context element alignment
	 * 
	 * @property YAHOO.widget.Overlay.TOP_LEFT
	 * @static
	 * @final
	 * @type String
	 */
    Overlay.TOP_LEFT = "tl";

    /**
	 * Constant representing the top right corner of an element, used for
	 * configuring the context element alignment
	 * 
	 * @property YAHOO.widget.Overlay.TOP_RIGHT
	 * @static
	 * @final
	 * @type String
	 */
    Overlay.TOP_RIGHT = "tr";

    /**
	 * Constant representing the top bottom left corner of an element, used for
	 * configuring the context element alignment
	 * 
	 * @property YAHOO.widget.Overlay.BOTTOM_LEFT
	 * @static
	 * @final
	 * @type String
	 */
    Overlay.BOTTOM_LEFT = "bl";

    /**
	 * Constant representing the bottom right corner of an element, used for
	 * configuring the context element alignment
	 * 
	 * @property YAHOO.widget.Overlay.BOTTOM_RIGHT
	 * @static
	 * @final
	 * @type String
	 */
    Overlay.BOTTOM_RIGHT = "br";

    Overlay.PREVENT_OVERLAP_X = {
        "tltr": true,
        "blbr": true,
        "brbl": true,
        "trtl": true
    };
            
    Overlay.PREVENT_OVERLAP_Y = {
        "trbr": true,
        "tlbl": true,
        "bltl": true,
        "brtr": true
    };

    /**
	 * Constant representing the default CSS class used for an Overlay
	 * 
	 * @property YAHOO.widget.Overlay.CSS_OVERLAY
	 * @static
	 * @final
	 * @type String
	 */
    Overlay.CSS_OVERLAY = "yui-overlay";

    /**
	 * Constant representing the default hidden CSS class used for an Overlay.
	 * This class is applied to the overlay's outer DIV whenever it's hidden.
	 * 
	 * @property YAHOO.widget.Overlay.CSS_HIDDEN
	 * @static
	 * @final
	 * @type String
	 */
    Overlay.CSS_HIDDEN = "yui-overlay-hidden";

    /**
	 * Constant representing the default CSS class used for an Overlay iframe
	 * shim.
	 * 
	 * @property YAHOO.widget.Overlay.CSS_IFRAME
	 * @static
	 * @final
	 * @type String
	 */
    Overlay.CSS_IFRAME = "yui-overlay-iframe";

    /**
	 * Constant representing the names of the standard module elements used in
	 * the overlay.
	 * 
	 * @property YAHOO.widget.Overlay.STD_MOD_RE
	 * @static
	 * @final
	 * @type RegExp
	 */
    Overlay.STD_MOD_RE = /^\s*?(body|footer|header)\s*?$/i;

    /**
	 * A singleton CustomEvent used for reacting to the DOM event for window
	 * scroll
	 * 
	 * @event YAHOO.widget.Overlay.windowScrollEvent
	 */
    Overlay.windowScrollEvent = new CustomEvent("windowScroll");

    /**
	 * A singleton CustomEvent used for reacting to the DOM event for window
	 * resize
	 * 
	 * @event YAHOO.widget.Overlay.windowResizeEvent
	 */
    Overlay.windowResizeEvent = new CustomEvent("windowResize");

    /**
	 * The DOM event handler used to fire the CustomEvent for window scroll
	 * 
	 * @method YAHOO.widget.Overlay.windowScrollHandler
	 * @static
	 * @param {DOMEvent}
	 *            e The DOM scroll event
	 */
    Overlay.windowScrollHandler = function (e) {
        var t = Event.getTarget(e);

        // - Webkit (Safari 2/3) and Opera 9.2x bubble scroll events from
		// elements to window
        // - FF2/3 and IE6/7, Opera 9.5x don't bubble scroll events from
		// elements to window
        // - IE doesn't recognize scroll registered on the document.
        //
        // Also, when document view is scrolled, IE doesn't provide a target,
        // rest of the browsers set target to window.document, apart from opera
        // which sets target to window.
        if (!t || t === window || t === window.document) {
            if (UA.ie) {

                if (! window.scrollEnd) {
                    window.scrollEnd = -1;
                }

                clearTimeout(window.scrollEnd);
        
                window.scrollEnd = setTimeout(function () { 
                    Overlay.windowScrollEvent.fire(); 
                }, 1);
        
            } else {
                Overlay.windowScrollEvent.fire();
            }
        }
    };

    /**
	 * The DOM event handler used to fire the CustomEvent for window resize
	 * 
	 * @method YAHOO.widget.Overlay.windowResizeHandler
	 * @static
	 * @param {DOMEvent}
	 *            e The DOM resize event
	 */
    Overlay.windowResizeHandler = function (e) {

        if (UA.ie) {
            if (! window.resizeEnd) {
                window.resizeEnd = -1;
            }

            clearTimeout(window.resizeEnd);

            window.resizeEnd = setTimeout(function () {
                Overlay.windowResizeEvent.fire(); 
            }, 100);
        } else {
            Overlay.windowResizeEvent.fire();
        }
    };

    /**
	 * A boolean that indicated whether the window resize and scroll events have
	 * already been subscribed to.
	 * 
	 * @property YAHOO.widget.Overlay._initialized
	 * @private
	 * @type Boolean
	 */
    Overlay._initialized = null;

    if (Overlay._initialized === null) {
        Event.on(window, "scroll", Overlay.windowScrollHandler);
        Event.on(window, "resize", Overlay.windowResizeHandler);
        Overlay._initialized = true;
    }

    /**
	 * Internal map of special event types, which are provided by the instance.
	 * It maps the event type to the custom event instance. Contains entries for
	 * the "windowScroll", "windowResize" and "textResize" static container
	 * events.
	 * 
	 * @property YAHOO.widget.Overlay._TRIGGER_MAP
	 * @type Object
	 * @static
	 * @private
	 */
    Overlay._TRIGGER_MAP = {
        "windowScroll" : Overlay.windowScrollEvent,
        "windowResize" : Overlay.windowResizeEvent,
        "textResize"   : Module.textResizeEvent
    };

    YAHOO.extend(Overlay, Module, {

        /**
		 * <p>
		 * Array of default event types which will trigger context alignment for
		 * the Overlay class.
		 * </p>
		 * <p>
		 * The array is empty by default for Overlay, but maybe populated in
		 * future releases, so classes extending Overlay which need to define
		 * their own set of CONTEXT_TRIGGERS should concatenate their super
		 * class's prototype.CONTEXT_TRIGGERS value with their own array of
		 * values.
		 * </p>
		 * <p>
		 * E.g.:
		 * <code>CustomOverlay.prototype.CONTEXT_TRIGGERS = YAHOO.widget.Overlay.prototype.CONTEXT_TRIGGERS.concat(["windowScroll"]);</code>
		 * </p>
		 * 
		 * @property CONTEXT_TRIGGERS
		 * @type Array
		 * @final
		 */
        CONTEXT_TRIGGERS : [],

        /**
		 * The Overlay initialization method, which is executed for Overlay and
		 * all of its subclasses. This method is automatically called by the
		 * constructor, and sets up all DOM references for pre-existing markup,
		 * and creates required markup if it is not already present.
		 * 
		 * @method init
		 * @param {String}
		 *            el The element ID representing the Overlay <em>OR</em>
		 * @param {HTMLElement}
		 *            el The element representing the Overlay
		 * @param {Object}
		 *            userConfig The configuration object literal containing the
		 *            configuration that should be set for this Overlay. See
		 *            configuration documentation for more details.
		 */
        init: function (el, userConfig) {

            /*
			 * Note that we don't pass the user config in here yet because we
			 * only want it executed once, at the lowest subclass level
			 */

            Overlay.superclass.init.call(this, el/* , userConfig */);

            this.beforeInitEvent.fire(Overlay);

            Dom.addClass(this.element, Overlay.CSS_OVERLAY);

            if (userConfig) {
                this.cfg.applyConfig(userConfig, true);
            }

            if (this.platform == "mac" && UA.gecko) {

                if (! Config.alreadySubscribed(this.showEvent,
                    this.showMacGeckoScrollbars, this)) {

                    this.showEvent.subscribe(this.showMacGeckoScrollbars, 
                        this, true);

                }

                if (! Config.alreadySubscribed(this.hideEvent, 
                    this.hideMacGeckoScrollbars, this)) {

                    this.hideEvent.subscribe(this.hideMacGeckoScrollbars, 
                        this, true);

                }
            }

            this.initEvent.fire(Overlay);
        },
        
        /**
		 * Initializes the custom events for Overlay which are fired
		 * automatically at appropriate times by the Overlay class.
		 * 
		 * @method initEvents
		 */
        initEvents: function () {

            Overlay.superclass.initEvents.call(this);

            var SIGNATURE = CustomEvent.LIST;

            /**
			 * CustomEvent fired before the Overlay is moved.
			 * 
			 * @event beforeMoveEvent
			 * @param {Number}
			 *            x x coordinate
			 * @param {Number}
			 *            y y coordinate
			 */
            this.beforeMoveEvent = this.createEvent(EVENT_TYPES.BEFORE_MOVE);
            this.beforeMoveEvent.signature = SIGNATURE;

            /**
			 * CustomEvent fired after the Overlay is moved.
			 * 
			 * @event moveEvent
			 * @param {Number}
			 *            x x coordinate
			 * @param {Number}
			 *            y y coordinate
			 */
            this.moveEvent = this.createEvent(EVENT_TYPES.MOVE);
            this.moveEvent.signature = SIGNATURE;

        },
        
        /**
		 * Initializes the class's configurable properties which can be changed
		 * using the Overlay's Config object (cfg).
		 * 
		 * @method initDefaultConfig
		 */
        initDefaultConfig: function () {
    
            Overlay.superclass.initDefaultConfig.call(this);

            var cfg = this.cfg;

            // Add overlay config properties //
            
            /**
			 * The absolute x-coordinate position of the Overlay
			 * 
			 * @config x
			 * @type Number
			 * @default null
			 */
            cfg.addProperty(DEFAULT_CONFIG.X.key, { 
    
                handler: this.configX, 
                validator: DEFAULT_CONFIG.X.validator, 
                suppressEvent: DEFAULT_CONFIG.X.suppressEvent, 
                supercedes: DEFAULT_CONFIG.X.supercedes
    
            });

            /**
			 * The absolute y-coordinate position of the Overlay
			 * 
			 * @config y
			 * @type Number
			 * @default null
			 */
            cfg.addProperty(DEFAULT_CONFIG.Y.key, {

                handler: this.configY, 
                validator: DEFAULT_CONFIG.Y.validator, 
                suppressEvent: DEFAULT_CONFIG.Y.suppressEvent, 
                supercedes: DEFAULT_CONFIG.Y.supercedes

            });

            /**
			 * An array with the absolute x and y positions of the Overlay
			 * 
			 * @config xy
			 * @type Number[]
			 * @default null
			 */
            cfg.addProperty(DEFAULT_CONFIG.XY.key, {
                handler: this.configXY, 
                suppressEvent: DEFAULT_CONFIG.XY.suppressEvent, 
                supercedes: DEFAULT_CONFIG.XY.supercedes
            });

            /**
			 * <p>
			 * The array of context arguments for context-sensitive positioning.
			 * </p>
			 * 
			 * <p>
			 * The format of the array is:
			 * <code>[contextElementOrId, overlayCorner, contextCorner, arrayOfTriggerEvents (optional), xyOffset (optional)]</code>,
			 * the the 5 array elements described in detail below:
			 * </p>
			 * 
			 * <dl>
			 * <dt>contextElementOrId &#60;String|HTMLElement&#62;</dt>
			 * <dd>A reference to the context element to which the overlay
			 * should be aligned (or it's id).</dd>
			 * <dt>overlayCorner &#60;String&#62;</dt>
			 * <dd>The corner of the overlay which is to be used for alignment.
			 * This corner will be aligned to the corner of the context element
			 * defined by the "contextCorner" entry which follows. Supported
			 * string values are: "tr" (top right), "tl" (top left), "br"
			 * (bottom right), or "bl" (bottom left).</dd>
			 * <dt>contextCorner &#60;String&#62;</dt>
			 * <dd>The corner of the context element which is to be used for
			 * alignment. Supported string values are the same ones listed for
			 * the "overlayCorner" entry above.</dd>
			 * <dt>arrayOfTriggerEvents (optional)
			 * &#60;Array[String|CustomEvent]&#62;</dt>
			 * <dd>
			 * <p>
			 * By default, context alignment is a one time operation, aligning
			 * the Overlay to the context element when context configuration
			 * property is set, or when the <a href="#method_align">align</a>
			 * method is invoked. However, you can use the optional
			 * "arrayOfTriggerEvents" entry to define the list of events which
			 * should force the overlay to re-align itself with the context
			 * element. This is useful in situations where the layout of the
			 * document may change, resulting in the context element's position
			 * being modified.
			 * </p>
			 * <p>
			 * The array can contain either event type strings for events the
			 * instance publishes (e.g. "beforeShow") or CustomEvent instances.
			 * Additionally the following 3 static container event types are
			 * also currently supported :
			 * <code>"windowResize", "windowScroll", "textResize"</code>
			 * (defined in <a href="#property__TRIGGER_MAP">_TRIGGER_MAP</a>
			 * private property).
			 * </p>
			 * </dd>
			 * <dt>xyOffset &#60;Number[]&#62;</dt>
			 * <dd> A 2 element Array specifying the X and Y pixel amounts by
			 * which the Overlay should be offset from the aligned corner. e.g.
			 * [5,0] offsets the Overlay 5 pixels to the left, <em>after</em>
			 * aligning the given context corners. NOTE: If using this property
			 * and no triggers need to be defined, the arrayOfTriggerEvents
			 * property should be set to null to maintain correct array
			 * positions for the arguments. </dd>
			 * </dl>
			 * 
			 * <p>
			 * For example, setting this property to
			 * <code>["img1", "tl", "bl"]</code> will align the Overlay's top
			 * left corner to the bottom left corner of the context element with
			 * id "img1".
			 * </p>
			 * <p>
			 * Setting this property to
			 * <code>["img1", "tl", "bl", null, [0,5]</code> will align the
			 * Overlay's top left corner to the bottom left corner of the
			 * context element with id "img1", and then offset it by 5 pixels on
			 * the Y axis (providing a 5 pixel gap between the bottom of the
			 * context element and top of the overlay).
			 * </p>
			 * <p>
			 * Adding the optional trigger values:
			 * <code>["img1", "tl", "bl", ["beforeShow", "windowResize"], [0,5]]</code>,
			 * will re-align the overlay position, whenever the "beforeShow" or
			 * "windowResize" events are fired.
			 * </p>
			 * 
			 * @config context
			 * @type Array
			 * @default null
			 */
            cfg.addProperty(DEFAULT_CONFIG.CONTEXT.key, {
                handler: this.configContext, 
                suppressEvent: DEFAULT_CONFIG.CONTEXT.suppressEvent, 
                supercedes: DEFAULT_CONFIG.CONTEXT.supercedes
            });

            /**
			 * Determines whether or not the Overlay should be anchored to the
			 * center of the viewport.
			 * 
			 * <p>
			 * This property can be set to:
			 * </p>
			 * 
			 * <dl>
			 * <dt>true</dt>
			 * <dd> To enable fixed center positioning
			 * <p>
			 * When enabled, the overlay will be positioned in the center of
			 * viewport when initially displayed, and will remain in the center
			 * of the viewport whenever the window is scrolled or resized.
			 * </p>
			 * <p>
			 * If the overlay is too big for the viewport, it's top left corner
			 * will be aligned with the top left corner of the viewport.
			 * </p>
			 * </dd>
			 * <dt>false</dt>
			 * <dd> To disable fixed center positioning.
			 * <p>
			 * In this case the overlay can still be centered as a one-off
			 * operation, by invoking the <code>center()</code> method,
			 * however it will not remain centered when the window is
			 * scrolled/resized. </dd>
			 * <dt>"contained"
			 * <dt>
			 * <dd>To enable fixed center positioning, as with the
			 * <code>true</code> option.
			 * <p>
			 * However, unlike setting the property to <code>true</code>,
			 * when the property is set to <code>"contained"</code>, if the
			 * overlay is too big for the viewport, it will not get
			 * automatically centered when the user scrolls or resizes the
			 * window (until the window is large enough to contain the overlay).
			 * This is useful in cases where the Overlay has both header and
			 * footer UI controls which the user may need to access.
			 * </p>
			 * </dd>
			 * </dl>
			 * 
			 * @config fixedcenter
			 * @type Boolean | String
			 * @default false
			 */
            cfg.addProperty(DEFAULT_CONFIG.FIXED_CENTER.key, {
                handler: this.configFixedCenter,
                value: DEFAULT_CONFIG.FIXED_CENTER.value, 
                validator: DEFAULT_CONFIG.FIXED_CENTER.validator, 
                supercedes: DEFAULT_CONFIG.FIXED_CENTER.supercedes
            });
    
            /**
			 * CSS width of the Overlay.
			 * 
			 * @config width
			 * @type String
			 * @default null
			 */
            cfg.addProperty(DEFAULT_CONFIG.WIDTH.key, {
                handler: this.configWidth, 
                suppressEvent: DEFAULT_CONFIG.WIDTH.suppressEvent, 
                supercedes: DEFAULT_CONFIG.WIDTH.supercedes
            });

            /**
			 * CSS height of the Overlay.
			 * 
			 * @config height
			 * @type String
			 * @default null
			 */
            cfg.addProperty(DEFAULT_CONFIG.HEIGHT.key, {
                handler: this.configHeight, 
                suppressEvent: DEFAULT_CONFIG.HEIGHT.suppressEvent, 
                supercedes: DEFAULT_CONFIG.HEIGHT.supercedes
            });

            /**
			 * Standard module element which should auto fill out the height of
			 * the Overlay if the height config property is set. Supported
			 * values are "header", "body", "footer".
			 * 
			 * @config autofillheight
			 * @type String
			 * @default null
			 */
            cfg.addProperty(DEFAULT_CONFIG.AUTO_FILL_HEIGHT.key, {
                handler: this.configAutoFillHeight, 
                value : DEFAULT_CONFIG.AUTO_FILL_HEIGHT.value,
                validator : this._validateAutoFill,
                supercedes: DEFAULT_CONFIG.AUTO_FILL_HEIGHT.supercedes
            });

            /**
			 * CSS z-index of the Overlay.
			 * 
			 * @config zIndex
			 * @type Number
			 * @default null
			 */
            cfg.addProperty(DEFAULT_CONFIG.ZINDEX.key, {
                handler: this.configzIndex,
                value: DEFAULT_CONFIG.ZINDEX.value
            });

            /**
			 * True if the Overlay should be prevented from being positioned out
			 * of the viewport.
			 * 
			 * @config constraintoviewport
			 * @type Boolean
			 * @default false
			 */
            cfg.addProperty(DEFAULT_CONFIG.CONSTRAIN_TO_VIEWPORT.key, {

                handler: this.configConstrainToViewport, 
                value: DEFAULT_CONFIG.CONSTRAIN_TO_VIEWPORT.value, 
                validator: DEFAULT_CONFIG.CONSTRAIN_TO_VIEWPORT.validator, 
                supercedes: DEFAULT_CONFIG.CONSTRAIN_TO_VIEWPORT.supercedes

            });

            /**
			 * @config iframe
			 * @description Boolean indicating whether or not the Overlay should
			 *              have an IFRAME shim; used to prevent SELECT elements
			 *              from poking through an Overlay instance in IE6. When
			 *              set to "true", the iframe shim is created when the
			 *              Overlay instance is intially made visible.
			 * @type Boolean
			 * @default true for IE6 and below, false for all other browsers.
			 */
            cfg.addProperty(DEFAULT_CONFIG.IFRAME.key, {

                handler: this.configIframe, 
                value: DEFAULT_CONFIG.IFRAME.value, 
                validator: DEFAULT_CONFIG.IFRAME.validator, 
                supercedes: DEFAULT_CONFIG.IFRAME.supercedes

            });

            /**
			 * @config preventcontextoverlap
			 * @description Boolean indicating whether or not the Overlay should
			 *              overlap its context element (defined using the
			 *              "context" configuration property) when the
			 *              "constraintoviewport" configuration property is set
			 *              to "true".
			 * @type Boolean
			 * @default false
			 */
            cfg.addProperty(DEFAULT_CONFIG.PREVENT_CONTEXT_OVERLAP.key, {
                value: DEFAULT_CONFIG.PREVENT_CONTEXT_OVERLAP.value, 
                validator: DEFAULT_CONFIG.PREVENT_CONTEXT_OVERLAP.validator, 
                supercedes: DEFAULT_CONFIG.PREVENT_CONTEXT_OVERLAP.supercedes
            });
        },

        /**
		 * Moves the Overlay to the specified position. This function is
		 * identical to calling this.cfg.setProperty("xy", [x,y]);
		 * 
		 * @method moveTo
		 * @param {Number}
		 *            x The Overlay's new x position
		 * @param {Number}
		 *            y The Overlay's new y position
		 */
        moveTo: function (x, y) {
            this.cfg.setProperty("xy", [x, y]);
        },

        /**
		 * Adds a CSS class ("hide-scrollbars") and removes a CSS class
		 * ("show-scrollbars") to the Overlay to fix a bug in Gecko on Mac OS X
		 * (https://bugzilla.mozilla.org/show_bug.cgi?id=187435)
		 * 
		 * @method hideMacGeckoScrollbars
		 */
        hideMacGeckoScrollbars: function () {
            Dom.replaceClass(this.element, "show-scrollbars", "hide-scrollbars");
        },

        /**
		 * Adds a CSS class ("show-scrollbars") and removes a CSS class
		 * ("hide-scrollbars") to the Overlay to fix a bug in Gecko on Mac OS X
		 * (https://bugzilla.mozilla.org/show_bug.cgi?id=187435)
		 * 
		 * @method showMacGeckoScrollbars
		 */
        showMacGeckoScrollbars: function () {
            Dom.replaceClass(this.element, "hide-scrollbars", "show-scrollbars");
        },

        /**
		 * Internal implementation to set the visibility of the overlay in the
		 * DOM.
		 * 
		 * @method _setDomVisibility
		 * @param {boolean}
		 *            visible Whether to show or hide the Overlay's outer
		 *            element
		 * @protected
		 */
        _setDomVisibility : function(show) {
            Dom.setStyle(this.element, "visibility", (show) ? "visible" : "hidden");
            var hiddenClass = Overlay.CSS_HIDDEN;

            if (show) {
                Dom.removeClass(this.element, hiddenClass);
            } else {
                Dom.addClass(this.element, hiddenClass);
            }
        },

        // BEGIN BUILT-IN PROPERTY EVENT HANDLERS //
        /**
		 * The default event handler fired when the "visible" property is
		 * changed. This method is responsible for firing showEvent and
		 * hideEvent.
		 * 
		 * @method configVisible
		 * @param {String}
		 *            type The CustomEvent type (usually the property name)
		 * @param {Object[]}
		 *            args The CustomEvent arguments. For configuration
		 *            handlers, args[0] will equal the newly applied value for
		 *            the property.
		 * @param {Object}
		 *            obj The scope object. For configuration handlers, this
		 *            will usually equal the owner.
		 */
        configVisible: function (type, args, obj) {

            var visible = args[0],
                currentVis = Dom.getStyle(this.element, "visibility"),
                effects = this._cachedEffects || this._createEffects(this.cfg.getProperty("effect")),
                isMacGecko = (this.platform == "mac" && UA.gecko),
                alreadySubscribed = Config.alreadySubscribed,
                ei, e, j, k, h,
                nEffectInstances;

            if (currentVis == "inherit") {
                e = this.element.parentNode;

                while (e.nodeType != 9 && e.nodeType != 11) {
                    currentVis = Dom.getStyle(e, "visibility");

                    if (currentVis != "inherit") {
                        break;
                    }

                    e = e.parentNode;
                }

                if (currentVis == "inherit") {
                    currentVis = "visible";
                }
            }

            if (visible) { // Show

                if (isMacGecko) {
                    this.showMacGeckoScrollbars();
                }

                if (effects) { // Animate in
                    if (visible) { // Animate in if not showing

                         // Fading out is a bit of a hack, but didn't want to
							// risk doing
                         // something broader (e.g a generic
							// this._animatingOut) for 2.9.0

                        if (currentVis != "visible" || currentVis === "" || this._fadingOut) {
                            if (this.beforeShowEvent.fire()) {

                                nEffectInstances = effects.length;

                                for (j = 0; j < nEffectInstances; j++) {
                                    ei = effects[j];
                                    if (j === 0 && !alreadySubscribed(ei.animateInCompleteEvent, this.showEvent.fire, this.showEvent)) {
                                        ei.animateInCompleteEvent.subscribe(this.showEvent.fire, this.showEvent, true);
                                    }
                                    ei.animateIn();
                                }
                            }
                        }
                    }
                } else { // Show
                    if (currentVis != "visible" || currentVis === "") {
                        if (this.beforeShowEvent.fire()) {
                            this._setDomVisibility(true);
                            this.cfg.refireEvent("iframe");
                            this.showEvent.fire();
                        }
                    } else {
                        this._setDomVisibility(true);
                    }
                }
            } else { // Hide

                if (isMacGecko) {
                    this.hideMacGeckoScrollbars();
                }

                if (effects) { // Animate out if showing
                    if (currentVis == "visible" || this._fadingIn) {
                        if (this.beforeHideEvent.fire()) {
                            nEffectInstances = effects.length;
                            for (k = 0; k < nEffectInstances; k++) {
                                h = effects[k];
        
                                if (k === 0 && !alreadySubscribed(h.animateOutCompleteEvent, this.hideEvent.fire, this.hideEvent)) {
                                    h.animateOutCompleteEvent.subscribe(this.hideEvent.fire, this.hideEvent, true);
                                }
                                h.animateOut();
                            }
                        }

                    } else if (currentVis === "") {
                        this._setDomVisibility(false);
                    }

                } else { // Simple hide

                    if (currentVis == "visible" || currentVis === "") {
                        if (this.beforeHideEvent.fire()) {
                            this._setDomVisibility(false);
                            this.hideEvent.fire();
                        }
                    } else {
                        this._setDomVisibility(false);
                    }
                }
            }
        },

        /**
		 * Fixed center event handler used for centering on scroll/resize, but
		 * only if the overlay is visible and, if "fixedcenter" is set to
		 * "contained", only if the overlay fits within the viewport.
		 * 
		 * @method doCenterOnDOMEvent
		 */
        doCenterOnDOMEvent: function () {
            var cfg = this.cfg,
                fc = cfg.getProperty("fixedcenter");

            if (cfg.getProperty("visible")) {
                if (fc && (fc !== _CONTAINED || this.fitsInViewport())) {
                    this.center();
                }
            }
        },

        /**
		 * Determines if the Overlay (including the offset value defined by
		 * Overlay.VIEWPORT_OFFSET) will fit entirely inside the viewport, in
		 * both dimensions - width and height.
		 * 
		 * @method fitsInViewport
		 * @return boolean true if the Overlay will fit, false if not
		 */
        fitsInViewport : function() {
            var nViewportOffset = Overlay.VIEWPORT_OFFSET,
                element = this.element,
                elementWidth = element.offsetWidth,
                elementHeight = element.offsetHeight,
                viewportWidth = Dom.getViewportWidth(),
                viewportHeight = Dom.getViewportHeight();

            return ((elementWidth + nViewportOffset < viewportWidth) && (elementHeight + nViewportOffset < viewportHeight));
        },

        /**
		 * The default event handler fired when the "fixedcenter" property is
		 * changed.
		 * 
		 * @method configFixedCenter
		 * @param {String}
		 *            type The CustomEvent type (usually the property name)
		 * @param {Object[]}
		 *            args The CustomEvent arguments. For configuration
		 *            handlers, args[0] will equal the newly applied value for
		 *            the property.
		 * @param {Object}
		 *            obj The scope object. For configuration handlers, this
		 *            will usually equal the owner.
		 */
        configFixedCenter: function (type, args, obj) {

            var val = args[0],
                alreadySubscribed = Config.alreadySubscribed,
                windowResizeEvent = Overlay.windowResizeEvent,
                windowScrollEvent = Overlay.windowScrollEvent;

            if (val) {
                this.center();

                if (!alreadySubscribed(this.beforeShowEvent, this.center)) {
                    this.beforeShowEvent.subscribe(this.center);
                }

                if (!alreadySubscribed(windowResizeEvent, this.doCenterOnDOMEvent, this)) {
                    windowResizeEvent.subscribe(this.doCenterOnDOMEvent, this, true);
                }

                if (!alreadySubscribed(windowScrollEvent, this.doCenterOnDOMEvent, this)) {
                    windowScrollEvent.subscribe(this.doCenterOnDOMEvent, this, true);
                }

            } else {
                this.beforeShowEvent.unsubscribe(this.center);

                windowResizeEvent.unsubscribe(this.doCenterOnDOMEvent, this);
                windowScrollEvent.unsubscribe(this.doCenterOnDOMEvent, this);
            }
        },

        /**
		 * The default event handler fired when the "height" property is
		 * changed.
		 * 
		 * @method configHeight
		 * @param {String}
		 *            type The CustomEvent type (usually the property name)
		 * @param {Object[]}
		 *            args The CustomEvent arguments. For configuration
		 *            handlers, args[0] will equal the newly applied value for
		 *            the property.
		 * @param {Object}
		 *            obj The scope object. For configuration handlers, this
		 *            will usually equal the owner.
		 */
        configHeight: function (type, args, obj) {

            var height = args[0],
                el = this.element;

            Dom.setStyle(el, "height", height);
            this.cfg.refireEvent("iframe");
        },

        /**
		 * The default event handler fired when the "autofillheight" property is
		 * changed.
		 * 
		 * @method configAutoFillHeight
		 * 
		 * @param {String}
		 *            type The CustomEvent type (usually the property name)
		 * @param {Object[]}
		 *            args The CustomEvent arguments. For configuration
		 *            handlers, args[0] will equal the newly applied value for
		 *            the property.
		 * @param {Object}
		 *            obj The scope object. For configuration handlers, this
		 *            will usually equal the owner.
		 */
        configAutoFillHeight: function (type, args, obj) {
            var fillEl = args[0],
                cfg = this.cfg,
                autoFillHeight = "autofillheight",
                height = "height",
                currEl = cfg.getProperty(autoFillHeight),
                autoFill = this._autoFillOnHeightChange;

            cfg.unsubscribeFromConfigEvent(height, autoFill);
            Module.textResizeEvent.unsubscribe(autoFill);
            this.changeContentEvent.unsubscribe(autoFill);

            if (currEl && fillEl !== currEl && this[currEl]) {
                Dom.setStyle(this[currEl], height, "");
            }

            if (fillEl) {
                fillEl = Lang.trim(fillEl.toLowerCase());

                cfg.subscribeToConfigEvent(height, autoFill, this[fillEl], this);
                Module.textResizeEvent.subscribe(autoFill, this[fillEl], this);
                this.changeContentEvent.subscribe(autoFill, this[fillEl], this);

                cfg.setProperty(autoFillHeight, fillEl, true);
            }
        },

        /**
		 * The default event handler fired when the "width" property is changed.
		 * 
		 * @method configWidth
		 * @param {String}
		 *            type The CustomEvent type (usually the property name)
		 * @param {Object[]}
		 *            args The CustomEvent arguments. For configuration
		 *            handlers, args[0] will equal the newly applied value for
		 *            the property.
		 * @param {Object}
		 *            obj The scope object. For configuration handlers, this
		 *            will usually equal the owner.
		 */
        configWidth: function (type, args, obj) {

            var width = args[0],
                el = this.element;

            Dom.setStyle(el, "width", width);
            this.cfg.refireEvent("iframe");
        },

        /**
		 * The default event handler fired when the "zIndex" property is
		 * changed.
		 * 
		 * @method configzIndex
		 * @param {String}
		 *            type The CustomEvent type (usually the property name)
		 * @param {Object[]}
		 *            args The CustomEvent arguments. For configuration
		 *            handlers, args[0] will equal the newly applied value for
		 *            the property.
		 * @param {Object}
		 *            obj The scope object. For configuration handlers, this
		 *            will usually equal the owner.
		 */
        configzIndex: function (type, args, obj) {

            var zIndex = args[0],
                el = this.element;

            if (! zIndex) {
                zIndex = Dom.getStyle(el, "zIndex");
                if (! zIndex || isNaN(zIndex)) {
                    zIndex = 0;
                }
            }

            if (this.iframe || this.cfg.getProperty("iframe") === true) {
                if (zIndex <= 0) {
                    zIndex = 1;
                }
            }

            Dom.setStyle(el, "zIndex", zIndex);
            this.cfg.setProperty("zIndex", zIndex, true);

            if (this.iframe) {
                this.stackIframe();
            }
        },

        /**
		 * The default event handler fired when the "xy" property is changed.
		 * 
		 * @method configXY
		 * @param {String}
		 *            type The CustomEvent type (usually the property name)
		 * @param {Object[]}
		 *            args The CustomEvent arguments. For configuration
		 *            handlers, args[0] will equal the newly applied value for
		 *            the property.
		 * @param {Object}
		 *            obj The scope object. For configuration handlers, this
		 *            will usually equal the owner.
		 */
        configXY: function (type, args, obj) {

            var pos = args[0],
                x = pos[0],
                y = pos[1];

            this.cfg.setProperty("x", x);
            this.cfg.setProperty("y", y);

            this.beforeMoveEvent.fire([x, y]);

            x = this.cfg.getProperty("x");
            y = this.cfg.getProperty("y");


            this.cfg.refireEvent("iframe");
            this.moveEvent.fire([x, y]);
        },

        /**
		 * The default event handler fired when the "x" property is changed.
		 * 
		 * @method configX
		 * @param {String}
		 *            type The CustomEvent type (usually the property name)
		 * @param {Object[]}
		 *            args The CustomEvent arguments. For configuration
		 *            handlers, args[0] will equal the newly applied value for
		 *            the property.
		 * @param {Object}
		 *            obj The scope object. For configuration handlers, this
		 *            will usually equal the owner.
		 */
        configX: function (type, args, obj) {

            var x = args[0],
                y = this.cfg.getProperty("y");

            this.cfg.setProperty("x", x, true);
            this.cfg.setProperty("y", y, true);

            this.beforeMoveEvent.fire([x, y]);

            x = this.cfg.getProperty("x");
            y = this.cfg.getProperty("y");

            Dom.setX(this.element, x, true);

            this.cfg.setProperty("xy", [x, y], true);

            this.cfg.refireEvent("iframe");
            this.moveEvent.fire([x, y]);
        },

        /**
		 * The default event handler fired when the "y" property is changed.
		 * 
		 * @method configY
		 * @param {String}
		 *            type The CustomEvent type (usually the property name)
		 * @param {Object[]}
		 *            args The CustomEvent arguments. For configuration
		 *            handlers, args[0] will equal the newly applied value for
		 *            the property.
		 * @param {Object}
		 *            obj The scope object. For configuration handlers, this
		 *            will usually equal the owner.
		 */
        configY: function (type, args, obj) {

            var x = this.cfg.getProperty("x"),
                y = args[0];

            this.cfg.setProperty("x", x, true);
            this.cfg.setProperty("y", y, true);

            this.beforeMoveEvent.fire([x, y]);

            x = this.cfg.getProperty("x");
            y = this.cfg.getProperty("y");

            Dom.setY(this.element, y, true);

            this.cfg.setProperty("xy", [x, y], true);

            this.cfg.refireEvent("iframe");
            this.moveEvent.fire([x, y]);
        },
        
        /**
		 * Shows the iframe shim, if it has been enabled.
		 * 
		 * @method showIframe
		 */
        showIframe: function () {

            var oIFrame = this.iframe,
                oParentNode;

            if (oIFrame) {
                oParentNode = this.element.parentNode;

                if (oParentNode != oIFrame.parentNode) {
                    this._addToParent(oParentNode, oIFrame);
                }
                oIFrame.style.display = "block";
            }
        },

        /**
		 * Hides the iframe shim, if it has been enabled.
		 * 
		 * @method hideIframe
		 */
        hideIframe: function () {
            if (this.iframe) {
                this.iframe.style.display = "none";
            }
        },

        /**
		 * Syncronizes the size and position of iframe shim to that of its
		 * corresponding Overlay instance.
		 * 
		 * @method syncIframe
		 */
        syncIframe: function () {

            var oIFrame = this.iframe,
                oElement = this.element,
                nOffset = Overlay.IFRAME_OFFSET,
                nDimensionOffset = (nOffset * 2),
                aXY;

            if (oIFrame) {
                // Size <iframe>
                oIFrame.style.width = (oElement.offsetWidth + nDimensionOffset + "px");
                oIFrame.style.height = (oElement.offsetHeight + nDimensionOffset + "px");

                // Position <iframe>
                aXY = this.cfg.getProperty("xy");

                if (!Lang.isArray(aXY) || (isNaN(aXY[0]) || isNaN(aXY[1]))) {
                    this.syncPosition();
                    aXY = this.cfg.getProperty("xy");
                }
                Dom.setXY(oIFrame, [(aXY[0] - nOffset), (aXY[1] - nOffset)]);
            }
        },

        /**
		 * Sets the zindex of the iframe shim, if it exists, based on the zindex
		 * of the Overlay element. The zindex of the iframe is set to be one
		 * less than the Overlay element's zindex.
		 * 
		 * <p>
		 * NOTE: This method will not bump up the zindex of the Overlay element
		 * to ensure that the iframe shim has a non-negative zindex. If you
		 * require the iframe zindex to be 0 or higher, the zindex of the
		 * Overlay element should be set to a value greater than 0, before this
		 * method is called.
		 * </p>
		 * 
		 * @method stackIframe
		 */
        stackIframe: function () {
            if (this.iframe) {
                var overlayZ = Dom.getStyle(this.element, "zIndex");
                if (!YAHOO.lang.isUndefined(overlayZ) && !isNaN(overlayZ)) {
                    Dom.setStyle(this.iframe, "zIndex", (overlayZ - 1));
                }
            }
        },

        /**
		 * The default event handler fired when the "iframe" property is
		 * changed.
		 * 
		 * @method configIframe
		 * @param {String}
		 *            type The CustomEvent type (usually the property name)
		 * @param {Object[]}
		 *            args The CustomEvent arguments. For configuration
		 *            handlers, args[0] will equal the newly applied value for
		 *            the property.
		 * @param {Object}
		 *            obj The scope object. For configuration handlers, this
		 *            will usually equal the owner.
		 */
        configIframe: function (type, args, obj) {

            var bIFrame = args[0];

            function createIFrame() {

                var oIFrame = this.iframe,
                    oElement = this.element,
                    oParent;

                if (!oIFrame) {
                    if (!m_oIFrameTemplate) {
                        m_oIFrameTemplate = document.createElement("iframe");

                        if (this.isSecure) {
                            m_oIFrameTemplate.src = Overlay.IFRAME_SRC;
                        }

                        /*
						 * Set the opacity of the <iframe> to 0 so that it
						 * doesn't modify the opacity of any transparent
						 * elements that may be on top of it (like a shadow).
						 */
                        if (UA.ie) {
                            m_oIFrameTemplate.style.filter = "alpha(opacity=0)";
                            /*
							 * Need to set the "frameBorder" property to 0
							 * supress the default <iframe> border in IE.
							 * Setting the CSS "border" property alone doesn't
							 * supress it.
							 */
                            m_oIFrameTemplate.frameBorder = 0;
                        }
                        else {
                            m_oIFrameTemplate.style.opacity = "0";
                        }

                        m_oIFrameTemplate.style.position = "absolute";
                        m_oIFrameTemplate.style.border = "none";
                        m_oIFrameTemplate.style.margin = "0";
                        m_oIFrameTemplate.style.padding = "0";
                        m_oIFrameTemplate.style.display = "none";
                        m_oIFrameTemplate.tabIndex = -1;
                        m_oIFrameTemplate.className = Overlay.CSS_IFRAME;
                    }

                    oIFrame = m_oIFrameTemplate.cloneNode(false);
                    oIFrame.id = this.id + "_f";
                    oParent = oElement.parentNode;

                    var parentNode = oParent || document.body;

                    this._addToParent(parentNode, oIFrame);
                    this.iframe = oIFrame;
                }

                /*
				 * Show the <iframe> before positioning it since the "setXY"
				 * method of DOM requires the element be in the document and
				 * visible.
				 */
                this.showIframe();

                /*
				 * Syncronize the size and position of the <iframe> to that of
				 * the Overlay.
				 */
                this.syncIframe();
                this.stackIframe();

                // Add event listeners to update the <iframe> when necessary
                if (!this._hasIframeEventListeners) {
                    this.showEvent.subscribe(this.showIframe);
                    this.hideEvent.subscribe(this.hideIframe);
                    this.changeContentEvent.subscribe(this.syncIframe);

                    this._hasIframeEventListeners = true;
                }
            }

            function onBeforeShow() {
                createIFrame.call(this);
                this.beforeShowEvent.unsubscribe(onBeforeShow);
                this._iframeDeferred = false;
            }

            if (bIFrame) { // <iframe> shim is enabled

                if (this.cfg.getProperty("visible")) {
                    createIFrame.call(this);
                } else {
                    if (!this._iframeDeferred) {
                        this.beforeShowEvent.subscribe(onBeforeShow);
                        this._iframeDeferred = true;
                    }
                }

            } else {    // <iframe> shim is disabled
                this.hideIframe();

                if (this._hasIframeEventListeners) {
                    this.showEvent.unsubscribe(this.showIframe);
                    this.hideEvent.unsubscribe(this.hideIframe);
                    this.changeContentEvent.unsubscribe(this.syncIframe);

                    this._hasIframeEventListeners = false;
                }
            }
        },

        /**
		 * Set's the container's XY value from DOM if not already set.
		 * 
		 * Differs from syncPosition, in that the XY value is only sync'd with
		 * DOM if not already set. The method also refire's the XY config
		 * property event, so any beforeMove, Move event listeners are invoked.
		 * 
		 * @method _primeXYFromDOM
		 * @protected
		 */
        _primeXYFromDOM : function() {
            if (YAHOO.lang.isUndefined(this.cfg.getProperty("xy"))) {
                // Set CFG XY based on DOM XY
                this.syncPosition();
                // Account for XY being set silently in syncPosition (no moveTo
				// fired/called)
                this.cfg.refireEvent("xy");
                this.beforeShowEvent.unsubscribe(this._primeXYFromDOM);
            }
        },

        /**
		 * The default event handler fired when the "constraintoviewport"
		 * property is changed.
		 * 
		 * @method configConstrainToViewport
		 * @param {String}
		 *            type The CustomEvent type (usually the property name)
		 * @param {Object[]}
		 *            args The CustomEvent arguments. For configuration
		 *            handlers, args[0] will equal the newly applied value for
		 *            the property.
		 * @param {Object}
		 *            obj The scope object. For configuration handlers, this
		 *            will usually equal the owner.
		 */
        configConstrainToViewport: function (type, args, obj) {
            var val = args[0];

            if (val) {
                if (! Config.alreadySubscribed(this.beforeMoveEvent, this.enforceConstraints, this)) {
                    this.beforeMoveEvent.subscribe(this.enforceConstraints, this, true);
                }
                if (! Config.alreadySubscribed(this.beforeShowEvent, this._primeXYFromDOM)) {
                    this.beforeShowEvent.subscribe(this._primeXYFromDOM);
                }
            } else {
                this.beforeShowEvent.unsubscribe(this._primeXYFromDOM);
                this.beforeMoveEvent.unsubscribe(this.enforceConstraints, this);
            }
        },

         /**
			 * The default event handler fired when the "context" property is
			 * changed.
			 * 
			 * @method configContext
			 * @param {String}
			 *            type The CustomEvent type (usually the property name)
			 * @param {Object[]}
			 *            args The CustomEvent arguments. For configuration
			 *            handlers, args[0] will equal the newly applied value
			 *            for the property.
			 * @param {Object}
			 *            obj The scope object. For configuration handlers, this
			 *            will usually equal the owner.
			 */
        configContext: function (type, args, obj) {

            var contextArgs = args[0],
                contextEl,
                elementMagnetCorner,
                contextMagnetCorner,
                triggers,
                offset,
                defTriggers = this.CONTEXT_TRIGGERS;

            if (contextArgs) {

                contextEl = contextArgs[0];
                elementMagnetCorner = contextArgs[1];
                contextMagnetCorner = contextArgs[2];
                triggers = contextArgs[3];
                offset = contextArgs[4];

                if (defTriggers && defTriggers.length > 0) {
                    triggers = (triggers || []).concat(defTriggers);
                }

                if (contextEl) {
                    if (typeof contextEl == "string") {
                        this.cfg.setProperty("context", [
                                document.getElementById(contextEl), 
                                elementMagnetCorner,
                                contextMagnetCorner,
                                triggers,
                                offset],
                                true);
                    }

                    if (elementMagnetCorner && contextMagnetCorner) {
                        this.align(elementMagnetCorner, contextMagnetCorner, offset);
                    }

                    if (this._contextTriggers) {
                        // Unsubscribe Old Set
                        this._processTriggers(this._contextTriggers, _UNSUBSCRIBE, this._alignOnTrigger);
                    }

                    if (triggers) {
                        // Subscribe New Set
                        this._processTriggers(triggers, _SUBSCRIBE, this._alignOnTrigger);
                        this._contextTriggers = triggers;
                    }
                }
            }
        },

        /**
		 * Custom Event handler for context alignment triggers. Invokes the
		 * align method
		 * 
		 * @method _alignOnTrigger
		 * @protected
		 * 
		 * @param {String}
		 *            type The event type (not used by the default
		 *            implementation)
		 * @param {Any[]}
		 *            args The array of arguments for the trigger event (not
		 *            used by the default implementation)
		 */
        _alignOnTrigger: function(type, args) {
            this.align();
        },

        /**
		 * Helper method to locate the custom event instance for the event name
		 * string passed in. As a convenience measure, any custom events passed
		 * in are returned.
		 * 
		 * @method _findTriggerCE
		 * @private
		 * 
		 * @param {String|CustomEvent}
		 *            t Either a CustomEvent, or event type (e.g.
		 *            "windowScroll") for which a custom event instance needs to
		 *            be looked up from the Overlay._TRIGGER_MAP.
		 */
        _findTriggerCE : function(t) {
            var tce = null;
            if (t instanceof CustomEvent) {
                tce = t;
            } else if (Overlay._TRIGGER_MAP[t]) {
                tce = Overlay._TRIGGER_MAP[t];
            }
            return tce;
        },

        /**
		 * Utility method that subscribes or unsubscribes the given function
		 * from the list of trigger events provided.
		 * 
		 * @method _processTriggers
		 * @protected
		 * 
		 * @param {Array[String|CustomEvent]}
		 *            triggers An array of either CustomEvents, event type
		 *            strings (e.g. "beforeShow", "windowScroll") to/from which
		 *            the provided function should be subscribed/unsubscribed
		 *            respectively.
		 * 
		 * @param {String}
		 *            mode Either "subscribe" or "unsubscribe", specifying
		 *            whether or not we are subscribing or unsubscribing trigger
		 *            listeners
		 * 
		 * @param {Function}
		 *            fn The function to be subscribed/unsubscribed to/from the
		 *            trigger event. Context is always set to the overlay
		 *            instance, and no additional object argument get passed to
		 *            the subscribed function.
		 */
        _processTriggers : function(triggers, mode, fn) {
            var t, tce;

            for (var i = 0, l = triggers.length; i < l; ++i) {
                t = triggers[i];
                tce = this._findTriggerCE(t);
                if (tce) {
                    tce[mode](fn, this, true);
                } else {
                    this[mode](t, fn);
                }
            }
        },

        // END BUILT-IN PROPERTY EVENT HANDLERS //
        /**
		 * Aligns the Overlay to its context element using the specified corner
		 * points (represented by the constants TOP_LEFT, TOP_RIGHT,
		 * BOTTOM_LEFT, and BOTTOM_RIGHT.
		 * 
		 * @method align
		 * @param {String}
		 *            elementAlign The String representing the corner of the
		 *            Overlay that should be aligned to the context element
		 * @param {String}
		 *            contextAlign The corner of the context element that the
		 *            elementAlign corner should stick to.
		 * @param {Number[]}
		 *            xyOffset Optional. A 2 element array specifying the x and
		 *            y pixel offsets which should be applied after aligning the
		 *            element and context corners. For example, passing in [5,
		 *            -10] for this value, would offset the Overlay by 5 pixels
		 *            along the X axis (horizontally) and -10 pixels along the Y
		 *            axis (vertically) after aligning the specified corners.
		 */
        align: function (elementAlign, contextAlign, xyOffset) {

            var contextArgs = this.cfg.getProperty("context"),
                me = this,
                context,
                element,
                contextRegion;

            function doAlign(v, h) {

                var alignX = null, alignY = null;

                switch (elementAlign) {
    
                    case Overlay.TOP_LEFT:
                        alignX = h;
                        alignY = v;
                        break;
        
                    case Overlay.TOP_RIGHT:
                        alignX = h - element.offsetWidth;
                        alignY = v;
                        break;
        
                    case Overlay.BOTTOM_LEFT:
                        alignX = h;
                        alignY = v - element.offsetHeight;
                        break;
        
                    case Overlay.BOTTOM_RIGHT:
                        alignX = h - element.offsetWidth; 
                        alignY = v - element.offsetHeight;
                        break;
                }

                if (alignX !== null && alignY !== null) {
                    if (xyOffset) {
                        alignX += xyOffset[0];
                        alignY += xyOffset[1];
                    }
                    me.moveTo(alignX, alignY);
                }
            }

            if (contextArgs) {
                context = contextArgs[0];
                element = this.element;
                me = this;

                if (! elementAlign) {
                    elementAlign = contextArgs[1];
                }

                if (! contextAlign) {
                    contextAlign = contextArgs[2];
                }

                if (!xyOffset && contextArgs[4]) {
                    xyOffset = contextArgs[4];
                }

                if (element && context) {
                    contextRegion = Dom.getRegion(context);

                    switch (contextAlign) {
    
                        case Overlay.TOP_LEFT:
                            doAlign(contextRegion.top, contextRegion.left);
                            break;
        
                        case Overlay.TOP_RIGHT:
                            doAlign(contextRegion.top, contextRegion.right);
                            break;
        
                        case Overlay.BOTTOM_LEFT:
                            doAlign(contextRegion.bottom, contextRegion.left);
                            break;
        
                        case Overlay.BOTTOM_RIGHT:
                            doAlign(contextRegion.bottom, contextRegion.right);
                            break;
                    }
                }
            }
        },

        /**
		 * The default event handler executed when the moveEvent is fired, if
		 * the "constraintoviewport" is set to true.
		 * 
		 * @method enforceConstraints
		 * @param {String}
		 *            type The CustomEvent type (usually the property name)
		 * @param {Object[]}
		 *            args The CustomEvent arguments. For configuration
		 *            handlers, args[0] will equal the newly applied value for
		 *            the property.
		 * @param {Object}
		 *            obj The scope object. For configuration handlers, this
		 *            will usually equal the owner.
		 */
        enforceConstraints: function (type, args, obj) {
            var pos = args[0];

            var cXY = this.getConstrainedXY(pos[0], pos[1]);
            this.cfg.setProperty("x", cXY[0], true);
            this.cfg.setProperty("y", cXY[1], true);
            this.cfg.setProperty("xy", cXY, true);
        },

        /**
		 * Shared implementation method for getConstrainedX and getConstrainedY.
		 * 
		 * <p>
		 * Given a coordinate value, returns the calculated coordinate required
		 * to position the Overlay if it is to be constrained to the viewport,
		 * based on the current element size, viewport dimensions, scroll values
		 * and preventoverlap settings
		 * </p>
		 * 
		 * @method _getConstrainedPos
		 * @protected
		 * @param {String}
		 *            pos The coordinate which needs to be constrained, either
		 *            "x" or "y"
		 * @param {Number}
		 *            The coordinate value which needs to be constrained
		 * @return {Number} The constrained coordinate value
		 */
        _getConstrainedPos: function(pos, val) {

            var overlayEl = this.element,

                buffer = Overlay.VIEWPORT_OFFSET,

                x = (pos == "x"),

                overlaySize      = (x) ? overlayEl.offsetWidth : overlayEl.offsetHeight,
                viewportSize     = (x) ? Dom.getViewportWidth() : Dom.getViewportHeight(),
                docScroll        = (x) ? Dom.getDocumentScrollLeft() : Dom.getDocumentScrollTop(),
                overlapPositions = (x) ? Overlay.PREVENT_OVERLAP_X : Overlay.PREVENT_OVERLAP_Y,

                context = this.cfg.getProperty("context"),

                bOverlayFitsInViewport = (overlaySize + buffer < viewportSize),
                bPreventContextOverlap = this.cfg.getProperty("preventcontextoverlap") && context && overlapPositions[(context[1] + context[2])],

                minConstraint = docScroll + buffer,
                maxConstraint = docScroll + viewportSize - overlaySize - buffer,

                constrainedVal = val;

            if (val < minConstraint || val > maxConstraint) {
                if (bPreventContextOverlap) {
                    constrainedVal = this._preventOverlap(pos, context[0], overlaySize, viewportSize, docScroll);
                } else {
                    if (bOverlayFitsInViewport) {
                        if (val < minConstraint) {
                            constrainedVal = minConstraint;
                        } else if (val > maxConstraint) {
                            constrainedVal = maxConstraint;
                        }
                    } else {
                        constrainedVal = minConstraint;
                    }
                }
            }

            return constrainedVal;
        },

        /**
		 * Helper method, used to position the Overlap to prevent overlap with
		 * the context element (used when preventcontextoverlap is enabled)
		 * 
		 * @method _preventOverlap
		 * @protected
		 * @param {String}
		 *            pos The coordinate to prevent overlap for, either "x" or
		 *            "y".
		 * @param {HTMLElement}
		 *            contextEl The context element
		 * @param {Number}
		 *            overlaySize The related overlay dimension value (for "x",
		 *            the width, for "y", the height)
		 * @param {Number}
		 *            viewportSize The related viewport dimension value (for
		 *            "x", the width, for "y", the height)
		 * @param {Object}
		 *            docScroll The related document scroll value (for "x", the
		 *            scrollLeft, for "y", the scrollTop)
		 * 
		 * @return {Number} The new coordinate value which was set to prevent
		 *         overlap
		 */
        _preventOverlap : function(pos, contextEl, overlaySize, viewportSize, docScroll) {
            
            var x = (pos == "x"),

                buffer = Overlay.VIEWPORT_OFFSET,

                overlay = this,

                contextElPos   = ((x) ? Dom.getX(contextEl) : Dom.getY(contextEl)) - docScroll,
                contextElSize  = (x) ? contextEl.offsetWidth : contextEl.offsetHeight,

                minRegionSize = contextElPos - buffer,
                maxRegionSize = (viewportSize - (contextElPos + contextElSize)) - buffer,

                bFlipped = false,

                flip = function () {
                    var flippedVal;

                    if ((overlay.cfg.getProperty(pos) - docScroll) > contextElPos) {
                        flippedVal = (contextElPos - overlaySize);
                    } else {
                        flippedVal = (contextElPos + contextElSize);
                    }

                    overlay.cfg.setProperty(pos, (flippedVal + docScroll), true);

                    return flippedVal;
                },

                setPosition = function () {

                    var displayRegionSize = ((overlay.cfg.getProperty(pos) - docScroll) > contextElPos) ? maxRegionSize : minRegionSize,
                        position;

                    if (overlaySize > displayRegionSize) {
                        if (bFlipped) {
                            /*
							 * All possible positions and values have been
							 * tried, but none were successful, so fall back to
							 * the original size and position.
							 */
                            flip();
                        } else {
                            flip();
                            bFlipped = true;
                            position = setPosition();
                        }
                    }

                    return position;
                };

            setPosition();

            return this.cfg.getProperty(pos);
        },

        /**
		 * Given x coordinate value, returns the calculated x coordinate
		 * required to position the Overlay if it is to be constrained to the
		 * viewport, based on the current element size, viewport dimensions and
		 * scroll values.
		 * 
		 * @param {Number}
		 *            x The X coordinate value to be constrained
		 * @return {Number} The constrained x coordinate
		 */		
        getConstrainedX: function (x) {
            return this._getConstrainedPos("x", x);
        },

        /**
		 * Given y coordinate value, returns the calculated y coordinate
		 * required to position the Overlay if it is to be constrained to the
		 * viewport, based on the current element size, viewport dimensions and
		 * scroll values.
		 * 
		 * @param {Number}
		 *            y The Y coordinate value to be constrained
		 * @return {Number} The constrained y coordinate
		 */		
        getConstrainedY : function (y) {
            return this._getConstrainedPos("y", y);
        },

        /**
		 * Given x, y coordinate values, returns the calculated coordinates
		 * required to position the Overlay if it is to be constrained to the
		 * viewport, based on the current element size, viewport dimensions and
		 * scroll values.
		 * 
		 * @param {Number}
		 *            x The X coordinate value to be constrained
		 * @param {Number}
		 *            y The Y coordinate value to be constrained
		 * @return {Array} The constrained x and y coordinates at index 0 and 1
		 *         respectively;
		 */
        getConstrainedXY: function(x, y) {
            return [this.getConstrainedX(x), this.getConstrainedY(y)];
        },

        /**
		 * Centers the container in the viewport.
		 * 
		 * @method center
		 */
        center: function () {

            var nViewportOffset = Overlay.VIEWPORT_OFFSET,
                elementWidth = this.element.offsetWidth,
                elementHeight = this.element.offsetHeight,
                viewPortWidth = Dom.getViewportWidth(),
                viewPortHeight = Dom.getViewportHeight(),
                x,
                y;

            if (elementWidth < viewPortWidth) {
                x = (viewPortWidth / 2) - (elementWidth / 2) + Dom.getDocumentScrollLeft();
            } else {
                x = nViewportOffset + Dom.getDocumentScrollLeft();
            }

            if (elementHeight < viewPortHeight) {
                y = (viewPortHeight / 2) - (elementHeight / 2) + Dom.getDocumentScrollTop();
            } else {
                y = nViewportOffset + Dom.getDocumentScrollTop();
            }

            this.cfg.setProperty("xy", [parseInt(x, 10), parseInt(y, 10)]);
            this.cfg.refireEvent("iframe");

            if (UA.webkit) {
                this.forceContainerRedraw();
            }
        },

        /**
		 * Synchronizes the Panel's "xy", "x", and "y" properties with the
		 * Panel's position in the DOM. This is primarily used to update
		 * position information during drag & drop.
		 * 
		 * @method syncPosition
		 */
        syncPosition: function () {

            var pos = Dom.getXY(this.element);

            this.cfg.setProperty("x", pos[0], true);
            this.cfg.setProperty("y", pos[1], true);
            this.cfg.setProperty("xy", pos, true);

        },

        /**
		 * Event handler fired when the resize monitor element is resized.
		 * 
		 * @method onDomResize
		 * @param {DOMEvent}
		 *            e The resize DOM event
		 * @param {Object}
		 *            obj The scope object
		 */
        onDomResize: function (e, obj) {

            var me = this;

            Overlay.superclass.onDomResize.call(this, e, obj);

            setTimeout(function () {
                me.syncPosition();
                me.cfg.refireEvent("iframe");
                me.cfg.refireEvent("context");
            }, 0);
        },

        /**
		 * Determines the content box height of the given element (height of the
		 * element, without padding or borders) in pixels.
		 * 
		 * @method _getComputedHeight
		 * @private
		 * @param {HTMLElement}
		 *            el The element for which the content height needs to be
		 *            determined
		 * @return {Number} The content box height of the given element, or null
		 *         if it could not be determined.
		 */
        _getComputedHeight : (function() {

            if (document.defaultView && document.defaultView.getComputedStyle) {
                return function(el) {
                    var height = null;
                    if (el.ownerDocument && el.ownerDocument.defaultView) {
                        var computed = el.ownerDocument.defaultView.getComputedStyle(el, '');
                        if (computed) {
                            height = parseInt(computed.height, 10);
                        }
                    }
                    return (Lang.isNumber(height)) ? height : null;
                };
            } else {
                return function(el) {
                    var height = null;
                    if (el.style.pixelHeight) {
                        height = el.style.pixelHeight;
                    }
                    return (Lang.isNumber(height)) ? height : null;
                };
            }
        })(),

        /**
		 * autofillheight validator. Verifies that the autofill value is either
		 * null or one of the strings : "body", "header" or "footer".
		 * 
		 * @method _validateAutoFillHeight
		 * @protected
		 * @param {String}
		 *            val
		 * @return true, if valid, false otherwise
		 */
        _validateAutoFillHeight : function(val) {
            return (!val) || (Lang.isString(val) && Overlay.STD_MOD_RE.test(val));
        },

        /**
		 * The default custom event handler executed when the overlay's height
		 * is changed, if the autofillheight property has been set.
		 * 
		 * @method _autoFillOnHeightChange
		 * @protected
		 * @param {String}
		 *            type The event type
		 * @param {Array}
		 *            args The array of arguments passed to event subscribers
		 * @param {HTMLElement}
		 *            el The header, body or footer element which is to be
		 *            resized to fill out the containers height
		 */
        _autoFillOnHeightChange : function(type, args, el) {
            var height = this.cfg.getProperty("height");
            if ((height && height !== "auto") || (height === 0)) {
                this.fillHeight(el);
            }
        },

        /**
		 * Returns the sub-pixel height of the el, using getBoundingClientRect,
		 * if available, otherwise returns the offsetHeight
		 * 
		 * @method _getPreciseHeight
		 * @private
		 * @param {HTMLElement}
		 *            el
		 * @return {Float} The sub-pixel height if supported by the browser,
		 *         else the rounded height.
		 */
        _getPreciseHeight : function(el) {
            var height = el.offsetHeight;

            if (el.getBoundingClientRect) {
                var rect = el.getBoundingClientRect();
                height = rect.bottom - rect.top;
            }

            return height;
        },

        /**
		 * <p>
		 * Sets the height on the provided header, body or footer element to
		 * fill out the height of the container. It determines the height of the
		 * containers content box, based on it's configured height value, and
		 * sets the height of the autofillheight element to fill out any space
		 * remaining after the other standard module element heights have been
		 * accounted for.
		 * </p>
		 * <p>
		 * <strong>NOTE:</strong> This method is not designed to work if an
		 * explicit height has not been set on the container, since for an
		 * "auto" height container, the heights of the header/body/footer will
		 * drive the height of the container.
		 * </p>
		 * 
		 * @method fillHeight
		 * @param {HTMLElement}
		 *            el The element which should be resized to fill out the
		 *            height of the container element.
		 */
        fillHeight : function(el) {
            if (el) {
                var container = this.innerElement || this.element,
                    containerEls = [this.header, this.body, this.footer],
                    containerEl,
                    total = 0,
                    filled = 0,
                    remaining = 0,
                    validEl = false;

                for (var i = 0, l = containerEls.length; i < l; i++) {
                    containerEl = containerEls[i];
                    if (containerEl) {
                        if (el !== containerEl) {
                            filled += this._getPreciseHeight(containerEl);
                        } else {
                            validEl = true;
                        }
                    }
                }

                if (validEl) {

                    if (UA.ie || UA.opera) {
                        // Need to set height to 0, to allow height to be
						// reduced
                        Dom.setStyle(el, 'height', 0 + 'px');
                    }

                    total = this._getComputedHeight(container);

                    // Fallback, if we can't get computed value for content
					// height
                    if (total === null) {
                        Dom.addClass(container, "yui-override-padding");
                        total = container.clientHeight; // Content, No Border, 0
														// Padding (set by
														// yui-override-padding)
                        Dom.removeClass(container, "yui-override-padding");
                    }
    
                    remaining = Math.max(total - filled, 0);
    
                    Dom.setStyle(el, "height", remaining + "px");
    
                    // Re-adjust height if required, to account for el padding
					// and border
                    if (el.offsetHeight != remaining) {
                        remaining = Math.max(remaining - (el.offsetHeight - remaining), 0);
                    }
                    Dom.setStyle(el, "height", remaining + "px");
                }
            }
        },

        /**
		 * Places the Overlay on top of all other instances of
		 * YAHOO.widget.Overlay.
		 * 
		 * @method bringToTop
		 */
        bringToTop: function () {

            var aOverlays = [],
                oElement = this.element;

            function compareZIndexDesc(p_oOverlay1, p_oOverlay2) {

                var sZIndex1 = Dom.getStyle(p_oOverlay1, "zIndex"),
                    sZIndex2 = Dom.getStyle(p_oOverlay2, "zIndex"),

                    nZIndex1 = (!sZIndex1 || isNaN(sZIndex1)) ? 0 : parseInt(sZIndex1, 10),
                    nZIndex2 = (!sZIndex2 || isNaN(sZIndex2)) ? 0 : parseInt(sZIndex2, 10);

                if (nZIndex1 > nZIndex2) {
                    return -1;
                } else if (nZIndex1 < nZIndex2) {
                    return 1;
                } else {
                    return 0;
                }
            }

            function isOverlayElement(p_oElement) {

                var isOverlay = Dom.hasClass(p_oElement, Overlay.CSS_OVERLAY),
                    Panel = YAHOO.widget.Panel;

                if (isOverlay && !Dom.isAncestor(oElement, p_oElement)) {
                    if (Panel && Dom.hasClass(p_oElement, Panel.CSS_PANEL)) {
                        aOverlays[aOverlays.length] = p_oElement.parentNode;
                    } else {
                        aOverlays[aOverlays.length] = p_oElement;
                    }
                }
            }

            Dom.getElementsBy(isOverlayElement, "div", document.body);

            aOverlays.sort(compareZIndexDesc);

            var oTopOverlay = aOverlays[0],
                nTopZIndex;

            if (oTopOverlay) {
                nTopZIndex = Dom.getStyle(oTopOverlay, "zIndex");

                if (!isNaN(nTopZIndex)) {
                    var bRequiresBump = false;

                    if (oTopOverlay != oElement) {
                        bRequiresBump = true;
                    } else if (aOverlays.length > 1) {
                        var nNextZIndex = Dom.getStyle(aOverlays[1], "zIndex");
                        // Don't rely on DOM order to stack if 2 overlays are at
						// the same zindex.
                        if (!isNaN(nNextZIndex) && (nTopZIndex == nNextZIndex)) {
                            bRequiresBump = true;
                        }
                    }
                    if (bRequiresBump) {
                        this.cfg.setProperty("zindex", (parseInt(nTopZIndex, 10) + 2));
                    }
                }
            }
        },

        /**
		 * Removes the Overlay element from the DOM and sets all child elements
		 * to null.
		 * 
		 * @method destroy
		 * @param {boolean}
		 *            shallowPurge If true, only the parent element's DOM event
		 *            listeners are purged. If false, or not provided, all
		 *            children are also purged of DOM event listeners. NOTE: The
		 *            flag is a "shallowPurge" flag, as opposed to what may be a
		 *            more intuitive "purgeChildren" flag to maintain backwards
		 *            compatibility with behavior prior to 2.9.0.
		 */
        destroy: function (shallowPurge) {

            if (this.iframe) {
                this.iframe.parentNode.removeChild(this.iframe);
            }

            this.iframe = null;

            Overlay.windowResizeEvent.unsubscribe(
                this.doCenterOnDOMEvent, this);
    
            Overlay.windowScrollEvent.unsubscribe(
                this.doCenterOnDOMEvent, this);

            Module.textResizeEvent.unsubscribe(this._autoFillOnHeightChange);

            if (this._contextTriggers) {
                // Unsubscribe context triggers - to cover context triggers
				// which listen for global
                // events such as windowResize and windowScroll. Easier just to
				// unsubscribe all
                this._processTriggers(this._contextTriggers, _UNSUBSCRIBE, this._alignOnTrigger);
            }

            Overlay.superclass.destroy.call(this, shallowPurge);
        },

        /**
		 * Can be used to force the container to repaint/redraw it's contents.
		 * <p>
		 * By default applies and then removes a 1px bottom margin through the
		 * application/removal of a "yui-force-redraw" class.
		 * </p>
		 * <p>
		 * It is currently used by Overlay to force a repaint for webkit
		 * browsers, when centering.
		 * </p>
		 * 
		 * @method forceContainerRedraw
		 */
        forceContainerRedraw : function() {
            var c = this;
            Dom.addClass(c.element, "yui-force-redraw");
            setTimeout(function() {
                Dom.removeClass(c.element, "yui-force-redraw");
            }, 0);
        },

        /**
		 * Returns a String representation of the object.
		 * 
		 * @method toString
		 * @return {String} The string representation of the Overlay.
		 */
        toString: function () {
            return "Overlay " + this.id;
        }

    });
}());
(function () {

    /**
	 * OverlayManager is used for maintaining the focus status of multiple
	 * Overlays.
	 * 
	 * @namespace YAHOO.widget
	 * @namespace YAHOO.widget
	 * @class OverlayManager
	 * @constructor
	 * @param {Array}
	 *            overlays Optional. A collection of Overlays to register with
	 *            the manager.
	 * @param {Object}
	 *            userConfig The object literal representing the user
	 *            configuration of the OverlayManager
	 */
    YAHOO.widget.OverlayManager = function (userConfig) {
        this.init(userConfig);
    };

    var Overlay = YAHOO.widget.Overlay,
        Event = YAHOO.util.Event,
        Dom = YAHOO.util.Dom,
        Config = YAHOO.util.Config,
        CustomEvent = YAHOO.util.CustomEvent,
        OverlayManager = YAHOO.widget.OverlayManager;

    /**
	 * The CSS class representing a focused Overlay
	 * 
	 * @property OverlayManager.CSS_FOCUSED
	 * @static
	 * @final
	 * @type String
	 */
    OverlayManager.CSS_FOCUSED = "focused";

    OverlayManager.prototype = {

        /**
		 * The class's constructor function
		 * 
		 * @property contructor
		 * @type Function
		 */
        constructor: OverlayManager,

        /**
		 * The array of Overlays that are currently registered
		 * 
		 * @property overlays
		 * @type YAHOO.widget.Overlay[]
		 */
        overlays: null,

        /**
		 * Initializes the default configuration of the OverlayManager
		 * 
		 * @method initDefaultConfig
		 */
        initDefaultConfig: function () {
            /**
			 * The collection of registered Overlays in use by the
			 * OverlayManager
			 * 
			 * @config overlays
			 * @type YAHOO.widget.Overlay[]
			 * @default null
			 */
            this.cfg.addProperty("overlays", { suppressEvent: true } );

            /**
			 * The default DOM event that should be used to focus an Overlay
			 * 
			 * @config focusevent
			 * @type String
			 * @default "mousedown"
			 */
            this.cfg.addProperty("focusevent", { value: "mousedown" } );
        },

        /**
		 * Initializes the OverlayManager
		 * 
		 * @method init
		 * @param {Overlay[]}
		 *            overlays Optional. A collection of Overlays to register
		 *            with the manager.
		 * @param {Object}
		 *            userConfig The object literal representing the user
		 *            configuration of the OverlayManager
		 */
        init: function (userConfig) {

            /**
			 * The OverlayManager's Config object used for monitoring
			 * configuration properties.
			 * 
			 * @property cfg
			 * @type Config
			 */
            this.cfg = new Config(this);

            this.initDefaultConfig();

            if (userConfig) {
                this.cfg.applyConfig(userConfig, true);
            }
            this.cfg.fireQueue();

            /**
			 * The currently activated Overlay
			 * 
			 * @property activeOverlay
			 * @private
			 * @type YAHOO.widget.Overlay
			 */
            var activeOverlay = null;

            /**
			 * Returns the currently focused Overlay
			 * 
			 * @method getActive
			 * @return {Overlay} The currently focused Overlay
			 */
            this.getActive = function () {
                return activeOverlay;
            };

            /**
			 * Focuses the specified Overlay
			 * 
			 * @method focus
			 * @param {Overlay}
			 *            overlay The Overlay to focus
			 * @param {String}
			 *            overlay The id of the Overlay to focus
			 */
            this.focus = function (overlay) {
                var o = this.find(overlay);
                if (o) {
                    o.focus();
                }
            };

            /**
			 * Removes the specified Overlay from the manager
			 * 
			 * @method remove
			 * @param {Overlay}
			 *            overlay The Overlay to remove
			 * @param {String}
			 *            overlay The id of the Overlay to remove
			 */
            this.remove = function (overlay) {

                var o = this.find(overlay), 
                        originalZ;

                if (o) {
                    if (activeOverlay == o) {
                        activeOverlay = null;
                    }

                    var bDestroyed = (o.element === null && o.cfg === null) ? true : false;

                    if (!bDestroyed) {
                        // Set it's zindex so that it's sorted to the end.
                        originalZ = Dom.getStyle(o.element, "zIndex");
                        o.cfg.setProperty("zIndex", -1000, true);
                    }

                    this.overlays.sort(this.compareZIndexDesc);
                    this.overlays = this.overlays.slice(0, (this.overlays.length - 1));

                    o.hideEvent.unsubscribe(o.blur);
                    o.destroyEvent.unsubscribe(this._onOverlayDestroy, o);
                    o.focusEvent.unsubscribe(this._onOverlayFocusHandler, o);
                    o.blurEvent.unsubscribe(this._onOverlayBlurHandler, o);

                    if (!bDestroyed) {
                        Event.removeListener(o.element, this.cfg.getProperty("focusevent"), this._onOverlayElementFocus);
                        o.cfg.setProperty("zIndex", originalZ, true);
                        o.cfg.setProperty("manager", null);
                    }

                    /*
					 * _managed Flag for custom or existing. Don't want to
					 * remove existing
					 */
                    if (o.focusEvent._managed) { o.focusEvent = null; }
                    if (o.blurEvent._managed) { o.blurEvent = null; }

                    if (o.focus._managed) { o.focus = null; }
                    if (o.blur._managed) { o.blur = null; }
                }
            };

            /**
			 * Removes focus from all registered Overlays in the manager
			 * 
			 * @method blurAll
			 */
            this.blurAll = function () {

                var nOverlays = this.overlays.length,
                    i;

                if (nOverlays > 0) {
                    i = nOverlays - 1;
                    do {
                        this.overlays[i].blur();
                    }
                    while(i--);
                }
            };

            /**
			 * Updates the state of the OverlayManager and overlay, as a result
			 * of the overlay being blurred.
			 * 
			 * @method _manageBlur
			 * @param {Overlay}
			 *            overlay The overlay instance which got blurred.
			 * @protected
			 */
            this._manageBlur = function (overlay) {
                var changed = false;
                if (activeOverlay == overlay) {
                    Dom.removeClass(activeOverlay.element, OverlayManager.CSS_FOCUSED);
                    activeOverlay = null;
                    changed = true;
                }
                return changed;
            };

            /**
			 * Updates the state of the OverlayManager and overlay, as a result
			 * of the overlay receiving focus.
			 * 
			 * @method _manageFocus
			 * @param {Overlay}
			 *            overlay The overlay instance which got focus.
			 * @protected
			 */
            this._manageFocus = function(overlay) {
                var changed = false;
                if (activeOverlay != overlay) {
                    if (activeOverlay) {
                        activeOverlay.blur();
                    }
                    activeOverlay = overlay;
                    this.bringToTop(activeOverlay);
                    Dom.addClass(activeOverlay.element, OverlayManager.CSS_FOCUSED);
                    changed = true;
                }
                return changed;
            };

            var overlays = this.cfg.getProperty("overlays");

            if (! this.overlays) {
                this.overlays = [];
            }

            if (overlays) {
                this.register(overlays);
                this.overlays.sort(this.compareZIndexDesc);
            }
        },

        /**
		 * @method _onOverlayElementFocus
		 * @description Event handler for the DOM event that is used to focus
		 *              the Overlay instance as specified by the "focusevent"
		 *              configuration property.
		 * @private
		 * @param {Event}
		 *            p_oEvent Object representing the DOM event object passed
		 *            back by the event utility (Event).
		 */
        _onOverlayElementFocus: function (p_oEvent) {

            var oTarget = Event.getTarget(p_oEvent),
                oClose = this.close;

            if (oClose && (oTarget == oClose || Dom.isAncestor(oClose, oTarget))) {
                this.blur();
            } else {
                this.focus();
            }
        },

        /**
		 * @method _onOverlayDestroy
		 * @description "destroy" event handler for the Overlay.
		 * @private
		 * @param {String}
		 *            p_sType String representing the name of the event that was
		 *            fired.
		 * @param {Array}
		 *            p_aArgs Array of arguments sent when the event was fired.
		 * @param {Overlay}
		 *            p_oOverlay Object representing the overlay that fired the
		 *            event.
		 */
        _onOverlayDestroy: function (p_sType, p_aArgs, p_oOverlay) {
            this.remove(p_oOverlay);
        },

        /**
		 * @method _onOverlayFocusHandler
		 * 
		 * @description focusEvent Handler, used to delegate to _manageFocus
		 *              with the correct arguments.
		 * 
		 * @private
		 * @param {String}
		 *            p_sType String representing the name of the event that was
		 *            fired.
		 * @param {Array}
		 *            p_aArgs Array of arguments sent when the event was fired.
		 * @param {Overlay}
		 *            p_oOverlay Object representing the overlay that fired the
		 *            event.
		 */
        _onOverlayFocusHandler: function(p_sType, p_aArgs, p_oOverlay) {
            this._manageFocus(p_oOverlay);
        },

        /**
		 * @method _onOverlayBlurHandler
		 * @description blurEvent Handler, used to delegate to _manageBlur with
		 *              the correct arguments.
		 * 
		 * @private
		 * @param {String}
		 *            p_sType String representing the name of the event that was
		 *            fired.
		 * @param {Array}
		 *            p_aArgs Array of arguments sent when the event was fired.
		 * @param {Overlay}
		 *            p_oOverlay Object representing the overlay that fired the
		 *            event.
		 */
        _onOverlayBlurHandler: function(p_sType, p_aArgs, p_oOverlay) {
            this._manageBlur(p_oOverlay);
        },

        /**
		 * Subscribes to the Overlay based instance focusEvent, to allow the
		 * OverlayManager to monitor focus state.
		 * 
		 * If the instance already has a focusEvent (e.g. Menu), OverlayManager
		 * will subscribe to the existing focusEvent, however if a focusEvent or
		 * focus method does not exist on the instance, the _bindFocus method
		 * will add them, and the focus method will update the OverlayManager's
		 * state directly.
		 * 
		 * @method _bindFocus
		 * @param {Overlay}
		 *            overlay The overlay for which focus needs to be managed
		 * @protected
		 */
        _bindFocus : function(overlay) {
            var mgr = this;

            if (!overlay.focusEvent) {
                overlay.focusEvent = overlay.createEvent("focus");
                overlay.focusEvent.signature = CustomEvent.LIST;
                overlay.focusEvent._managed = true;
            } else {
                overlay.focusEvent.subscribe(mgr._onOverlayFocusHandler, overlay, mgr);
            }

            if (!overlay.focus) {
                Event.on(overlay.element, mgr.cfg.getProperty("focusevent"), mgr._onOverlayElementFocus, null, overlay);
                overlay.focus = function () {
                    if (mgr._manageFocus(this)) {
                        // For Panel/Dialog
                        if (this.cfg.getProperty("visible") && this.focusFirst) {
                            this.focusFirst();
                        }
                        this.focusEvent.fire();
                    }
                };
                overlay.focus._managed = true;
            }
        },

        /**
		 * Subscribes to the Overlay based instance's blurEvent to allow the
		 * OverlayManager to monitor blur state.
		 * 
		 * If the instance already has a blurEvent (e.g. Menu), OverlayManager
		 * will subscribe to the existing blurEvent, however if a blurEvent or
		 * blur method does not exist on the instance, the _bindBlur method will
		 * add them, and the blur method update the OverlayManager's state
		 * directly.
		 * 
		 * @method _bindBlur
		 * @param {Overlay}
		 *            overlay The overlay for which blur needs to be managed
		 * @protected
		 */
        _bindBlur : function(overlay) {
            var mgr = this;

            if (!overlay.blurEvent) {
                overlay.blurEvent = overlay.createEvent("blur");
                overlay.blurEvent.signature = CustomEvent.LIST;
                overlay.focusEvent._managed = true;
            } else {
                overlay.blurEvent.subscribe(mgr._onOverlayBlurHandler, overlay, mgr);
            }

            if (!overlay.blur) {
                overlay.blur = function () {
                    if (mgr._manageBlur(this)) {
                        this.blurEvent.fire();
                    }
                };
                overlay.blur._managed = true;
            }

            overlay.hideEvent.subscribe(overlay.blur);
        },

        /**
		 * Subscribes to the Overlay based instance's destroyEvent, to allow the
		 * Overlay to be removed for the OverlayManager when destroyed.
		 * 
		 * @method _bindDestroy
		 * @param {Overlay}
		 *            overlay The overlay instance being managed
		 * @protected
		 */
        _bindDestroy : function(overlay) {
            var mgr = this;
            overlay.destroyEvent.subscribe(mgr._onOverlayDestroy, overlay, mgr);
        },

        /**
		 * Ensures the zIndex configuration property on the managed overlay
		 * based instance is set to the computed zIndex value from the DOM (with
		 * "auto" translating to 0).
		 * 
		 * @method _syncZIndex
		 * @param {Overlay}
		 *            overlay The overlay instance being managed
		 * @protected
		 */
        _syncZIndex : function(overlay) {
            var zIndex = Dom.getStyle(overlay.element, "zIndex");
            if (!isNaN(zIndex)) {
                overlay.cfg.setProperty("zIndex", parseInt(zIndex, 10));
            } else {
                overlay.cfg.setProperty("zIndex", 0);
            }
        },

        /**
		 * Registers an Overlay or an array of Overlays with the manager. Upon
		 * registration, the Overlay receives functions for focus and blur,
		 * along with CustomEvents for each.
		 * 
		 * @method register
		 * @param {Overlay}
		 *            overlay An Overlay to register with the manager.
		 * @param {Overlay[]}
		 *            overlay An array of Overlays to register with the manager.
		 * @return {boolean} true if any Overlays are registered.
		 */
        register: function (overlay) {

            var registered = false,
                i,
                n;

            if (overlay instanceof Overlay) {

                overlay.cfg.addProperty("manager", { value: this } );

                this._bindFocus(overlay);
                this._bindBlur(overlay);
                this._bindDestroy(overlay);
                this._syncZIndex(overlay);

                this.overlays.push(overlay);
                this.bringToTop(overlay);

                registered = true;

            } else if (overlay instanceof Array) {

                for (i = 0, n = overlay.length; i < n; i++) {
                    registered = this.register(overlay[i]) || registered;
                }

            }

            return registered;
        },

        /**
		 * Places the specified Overlay instance on top of all other Overlay
		 * instances.
		 * 
		 * @method bringToTop
		 * @param {YAHOO.widget.Overlay}
		 *            p_oOverlay Object representing an Overlay instance.
		 * @param {String}
		 *            p_oOverlay String representing the id of an Overlay
		 *            instance.
		 */        
        bringToTop: function (p_oOverlay) {

            var oOverlay = this.find(p_oOverlay),
                nTopZIndex,
                oTopOverlay,
                aOverlays;

            if (oOverlay) {

                aOverlays = this.overlays;
                aOverlays.sort(this.compareZIndexDesc);

                oTopOverlay = aOverlays[0];

                if (oTopOverlay) {
                    nTopZIndex = Dom.getStyle(oTopOverlay.element, "zIndex");

                    if (!isNaN(nTopZIndex)) {

                        var bRequiresBump = false;

                        if (oTopOverlay !== oOverlay) {
                            bRequiresBump = true;
                        } else if (aOverlays.length > 1) {
                            var nNextZIndex = Dom.getStyle(aOverlays[1].element, "zIndex");
                            // Don't rely on DOM order to stack if 2 overlays
							// are at the same zindex.
                            if (!isNaN(nNextZIndex) && (nTopZIndex == nNextZIndex)) {
                                bRequiresBump = true;
                            }
                        }

                        if (bRequiresBump) {
                            oOverlay.cfg.setProperty("zindex", (parseInt(nTopZIndex, 10) + 2));
                        }
                    }
                    aOverlays.sort(this.compareZIndexDesc);
                }
            }
        },

        /**
		 * Attempts to locate an Overlay by instance or ID.
		 * 
		 * @method find
		 * @param {Overlay}
		 *            overlay An Overlay to locate within the manager
		 * @param {String}
		 *            overlay An Overlay id to locate within the manager
		 * @return {Overlay} The requested Overlay, if found, or null if it
		 *         cannot be located.
		 */
        find: function (overlay) {

            var isInstance = overlay instanceof Overlay,
                overlays = this.overlays,
                n = overlays.length,
                found = null,
                o,
                i;

            if (isInstance || typeof overlay == "string") {
                for (i = n-1; i >= 0; i--) {
                    o = overlays[i];
                    if ((isInstance && (o === overlay)) || (o.id == overlay)) {
                        found = o;
                        break;
                    }
                }
            }

            return found;
        },

        /**
		 * Used for sorting the manager's Overlays by z-index.
		 * 
		 * @method compareZIndexDesc
		 * @private
		 * @return {Number} 0, 1, or -1, depending on where the Overlay should
		 *         fall in the stacking order.
		 */
        compareZIndexDesc: function (o1, o2) {

            var zIndex1 = (o1.cfg) ? o1.cfg.getProperty("zIndex") : null, // Sort
																			// invalid
																			// (destroyed)
                zIndex2 = (o2.cfg) ? o2.cfg.getProperty("zIndex") : null; // objects
																			// at
																			// bottom.

            if (zIndex1 === null && zIndex2 === null) {
                return 0;
            } else if (zIndex1 === null){
                return 1;
            } else if (zIndex2 === null) {
                return -1;
            } else if (zIndex1 > zIndex2) {
                return -1;
            } else if (zIndex1 < zIndex2) {
                return 1;
            } else {
                return 0;
            }
        },

        /**
		 * Shows all Overlays in the manager.
		 * 
		 * @method showAll
		 */
        showAll: function () {
            var overlays = this.overlays,
                n = overlays.length,
                i;

            for (i = n - 1; i >= 0; i--) {
                overlays[i].show();
            }
        },

        /**
		 * Hides all Overlays in the manager.
		 * 
		 * @method hideAll
		 */
        hideAll: function () {
            var overlays = this.overlays,
                n = overlays.length,
                i;

            for (i = n - 1; i >= 0; i--) {
                overlays[i].hide();
            }
        },

        /**
		 * Returns a string representation of the object.
		 * 
		 * @method toString
		 * @return {String} The string representation of the OverlayManager
		 */
        toString: function () {
            return "OverlayManager";
        }
    };
}());
(function () {

    /**
	 * Tooltip is an implementation of Overlay that behaves like an OS tooltip,
	 * displaying when the user mouses over a particular element, and
	 * disappearing on mouse out.
	 * 
	 * @namespace YAHOO.widget
	 * @class Tooltip
	 * @extends YAHOO.widget.Overlay
	 * @constructor
	 * @param {String}
	 *            el The element ID representing the Tooltip <em>OR</em>
	 * @param {HTMLElement}
	 *            el The element representing the Tooltip
	 * @param {Object}
	 *            userConfig The configuration object literal containing the
	 *            configuration that should be set for this Overlay. See
	 *            configuration documentation for more details.
	 */
    YAHOO.widget.Tooltip = function (el, userConfig) {
        YAHOO.widget.Tooltip.superclass.constructor.call(this, el, userConfig);
    };

    var Lang = YAHOO.lang,
        Event = YAHOO.util.Event,
        CustomEvent = YAHOO.util.CustomEvent,
        Dom = YAHOO.util.Dom,
        Tooltip = YAHOO.widget.Tooltip,
        UA = YAHOO.env.ua,
        bIEQuirks = (UA.ie && (UA.ie <= 6 || document.compatMode == "BackCompat")),

        m_oShadowTemplate,

        /**
		 * Constant representing the Tooltip's configuration properties
		 * 
		 * @property DEFAULT_CONFIG
		 * @private
		 * @final
		 * @type Object
		 */
        DEFAULT_CONFIG = {

            "PREVENT_OVERLAP": { 
                key: "preventoverlap", 
                value: true, 
                validator: Lang.isBoolean, 
                supercedes: ["x", "y", "xy"] 
            },

            "SHOW_DELAY": { 
                key: "showdelay", 
                value: 200, 
                validator: Lang.isNumber 
            }, 

            "AUTO_DISMISS_DELAY": { 
                key: "autodismissdelay", 
                value: 5000, 
                validator: Lang.isNumber 
            }, 

            "HIDE_DELAY": { 
                key: "hidedelay", 
                value: 250, 
                validator: Lang.isNumber 
            }, 

            "TEXT": { 
                key: "text", 
                suppressEvent: true 
            }, 

            "CONTAINER": { 
                key: "container"
            },

            "DISABLED": {
                key: "disabled",
                value: false,
                suppressEvent: true
            },

            "XY_OFFSET": {
                key: "xyoffset",
                value: [0, 25],
                suppressEvent: true
            }
        },

        /**
		 * Constant representing the name of the Tooltip's events
		 * 
		 * @property EVENT_TYPES
		 * @private
		 * @final
		 * @type Object
		 */
        EVENT_TYPES = {
            "CONTEXT_MOUSE_OVER": "contextMouseOver",
            "CONTEXT_MOUSE_OUT": "contextMouseOut",
            "CONTEXT_TRIGGER": "contextTrigger"
        };

    /**
	 * Constant representing the Tooltip CSS class
	 * 
	 * @property YAHOO.widget.Tooltip.CSS_TOOLTIP
	 * @static
	 * @final
	 * @type String
	 */
    Tooltip.CSS_TOOLTIP = "yui-tt";

    function restoreOriginalWidth(sOriginalWidth, sForcedWidth) {

        var oConfig = this.cfg,
            sCurrentWidth = oConfig.getProperty("width");

        if (sCurrentWidth == sForcedWidth) {
            oConfig.setProperty("width", sOriginalWidth);
        }
    }

    /*
	 * changeContent event handler that sets a Tooltip instance's "width"
	 * configuration property to the value of its root HTML elements's
	 * offsetWidth if a specific width has not been set.
	 */

    function setWidthToOffsetWidth(p_sType, p_aArgs) {

        if ("_originalWidth" in this) {
            restoreOriginalWidth.call(this, this._originalWidth, this._forcedWidth);
        }

        var oBody = document.body,
            oConfig = this.cfg,
            sOriginalWidth = oConfig.getProperty("width"),
            sNewWidth,
            oClone;

        if ((!sOriginalWidth || sOriginalWidth == "auto") && 
            (oConfig.getProperty("container") != oBody || 
            oConfig.getProperty("x") >= Dom.getViewportWidth() || 
            oConfig.getProperty("y") >= Dom.getViewportHeight())) {

            oClone = this.element.cloneNode(true);
            oClone.style.visibility = "hidden";
            oClone.style.top = "0px";
            oClone.style.left = "0px";

            oBody.appendChild(oClone);

            sNewWidth = (oClone.offsetWidth + "px");

            oBody.removeChild(oClone);
            oClone = null;

            oConfig.setProperty("width", sNewWidth);
            oConfig.refireEvent("xy");

            this._originalWidth = sOriginalWidth || "";
            this._forcedWidth = sNewWidth;
        }
    }

    // "onDOMReady" that renders the ToolTip

    function onDOMReady(p_sType, p_aArgs, p_oObject) {
        this.render(p_oObject);
    }

    // "init" event handler that automatically renders the Tooltip

    function onInit() {
        Event.onDOMReady(onDOMReady, this.cfg.getProperty("container"), this);
    }

    YAHOO.extend(Tooltip, YAHOO.widget.Overlay, { 

        /**
		 * The Tooltip initialization method. This method is automatically
		 * called by the constructor. A Tooltip is automatically rendered by the
		 * init method, and it also is set to be invisible by default, and
		 * constrained to viewport by default as well.
		 * 
		 * @method init
		 * @param {String}
		 *            el The element ID representing the Tooltip <em>OR</em>
		 * @param {HTMLElement}
		 *            el The element representing the Tooltip
		 * @param {Object}
		 *            userConfig The configuration object literal containing the
		 *            configuration that should be set for this Tooltip. See
		 *            configuration documentation for more details.
		 */
        init: function (el, userConfig) {


            Tooltip.superclass.init.call(this, el);

            this.beforeInitEvent.fire(Tooltip);

            Dom.addClass(this.element, Tooltip.CSS_TOOLTIP);

            if (userConfig) {
                this.cfg.applyConfig(userConfig, true);
            }

            this.cfg.queueProperty("visible", false);
            this.cfg.queueProperty("constraintoviewport", true);

            this.setBody("");

            this.subscribe("changeContent", setWidthToOffsetWidth);
            this.subscribe("init", onInit);
            this.subscribe("render", this.onRender);

            this.initEvent.fire(Tooltip);
        },

        /**
		 * Initializes the custom events for Tooltip
		 * 
		 * @method initEvents
		 */
        initEvents: function () {

            Tooltip.superclass.initEvents.call(this);
            var SIGNATURE = CustomEvent.LIST;

            /**
			 * CustomEvent fired when user mouses over a context element.
			 * Returning false from a subscriber to this event will prevent the
			 * tooltip from being displayed for the current context element.
			 * 
			 * @event contextMouseOverEvent
			 * @param {HTMLElement}
			 *            context The context element which the user just moused
			 *            over
			 * @param {DOMEvent}
			 *            e The DOM event object, associated with the mouse over
			 */
            this.contextMouseOverEvent = this.createEvent(EVENT_TYPES.CONTEXT_MOUSE_OVER);
            this.contextMouseOverEvent.signature = SIGNATURE;

            /**
			 * CustomEvent fired when the user mouses out of a context element.
			 * 
			 * @event contextMouseOutEvent
			 * @param {HTMLElement}
			 *            context The context element which the user just moused
			 *            out of
			 * @param {DOMEvent}
			 *            e The DOM event object, associated with the mouse out
			 */
            this.contextMouseOutEvent = this.createEvent(EVENT_TYPES.CONTEXT_MOUSE_OUT);
            this.contextMouseOutEvent.signature = SIGNATURE;

            /**
			 * CustomEvent fired just before the tooltip is displayed for the
			 * current context.
			 * <p>
			 * You can subscribe to this event if you need to set up the text
			 * for the tooltip based on the context element for which it is
			 * about to be displayed.
			 * </p>
			 * <p>
			 * This event differs from the beforeShow event in following
			 * respects:
			 * </p>
			 * <ol>
			 * <li> When moving from one context element to another, if the
			 * tooltip is not hidden (the <code>hidedelay</code> is not
			 * reached), the beforeShow and Show events will not be fired when
			 * the tooltip is displayed for the new context since it is already
			 * visible. However the contextTrigger event is always fired before
			 * displaying the tooltip for a new context. </li>
			 * <li> The trigger event provides access to the context element,
			 * allowing you to set the text of the tooltip based on context
			 * element for which the tooltip is triggered. </li>
			 * </ol>
			 * <p>
			 * It is not possible to prevent the tooltip from being displayed
			 * using this event. You can use the contextMouseOverEvent if you
			 * need to prevent the tooltip from being displayed.
			 * </p>
			 * 
			 * @event contextTriggerEvent
			 * @param {HTMLElement}
			 *            context The context element for which the tooltip is
			 *            triggered
			 */
            this.contextTriggerEvent = this.createEvent(EVENT_TYPES.CONTEXT_TRIGGER);
            this.contextTriggerEvent.signature = SIGNATURE;
        },

        /**
		 * Initializes the class's configurable properties which can be changed
		 * using the Overlay's Config object (cfg).
		 * 
		 * @method initDefaultConfig
		 */
        initDefaultConfig: function () {

            Tooltip.superclass.initDefaultConfig.call(this);

            /**
			 * Specifies whether the Tooltip should be kept from overlapping its
			 * context element.
			 * 
			 * @config preventoverlap
			 * @type Boolean
			 * @default true
			 */
            this.cfg.addProperty(DEFAULT_CONFIG.PREVENT_OVERLAP.key, {
                value: DEFAULT_CONFIG.PREVENT_OVERLAP.value, 
                validator: DEFAULT_CONFIG.PREVENT_OVERLAP.validator, 
                supercedes: DEFAULT_CONFIG.PREVENT_OVERLAP.supercedes
            });

            /**
			 * The number of milliseconds to wait before showing a Tooltip on
			 * mouseover.
			 * 
			 * @config showdelay
			 * @type Number
			 * @default 200
			 */
            this.cfg.addProperty(DEFAULT_CONFIG.SHOW_DELAY.key, {
                handler: this.configShowDelay,
                value: 200, 
                validator: DEFAULT_CONFIG.SHOW_DELAY.validator
            });

            /**
			 * The number of milliseconds to wait before automatically
			 * dismissing a Tooltip after the mouse has been resting on the
			 * context element.
			 * 
			 * @config autodismissdelay
			 * @type Number
			 * @default 5000
			 */
            this.cfg.addProperty(DEFAULT_CONFIG.AUTO_DISMISS_DELAY.key, {
                handler: this.configAutoDismissDelay,
                value: DEFAULT_CONFIG.AUTO_DISMISS_DELAY.value,
                validator: DEFAULT_CONFIG.AUTO_DISMISS_DELAY.validator
            });

            /**
			 * The number of milliseconds to wait before hiding a Tooltip after
			 * mouseout.
			 * 
			 * @config hidedelay
			 * @type Number
			 * @default 250
			 */
            this.cfg.addProperty(DEFAULT_CONFIG.HIDE_DELAY.key, {
                handler: this.configHideDelay,
                value: DEFAULT_CONFIG.HIDE_DELAY.value, 
                validator: DEFAULT_CONFIG.HIDE_DELAY.validator
            });

            /**
			 * Specifies the Tooltip's text. The text is inserted into the DOM
			 * as HTML, and should be escaped by the implementor if coming from
			 * an external source.
			 * 
			 * @config text
			 * @type HTML
			 * @default null
			 */
            this.cfg.addProperty(DEFAULT_CONFIG.TEXT.key, {
                handler: this.configText,
                suppressEvent: DEFAULT_CONFIG.TEXT.suppressEvent
            });

            /**
			 * Specifies the container element that the Tooltip's markup should
			 * be rendered into.
			 * 
			 * @config container
			 * @type HTMLElement/String
			 * @default document.body
			 */
            this.cfg.addProperty(DEFAULT_CONFIG.CONTAINER.key, {
                handler: this.configContainer,
                value: document.body
            });

            /**
			 * Specifies whether or not the tooltip is disabled. Disabled
			 * tooltips will not be displayed. If the tooltip is driven by the
			 * title attribute of the context element, the title attribute will
			 * still be removed for disabled tooltips, to prevent default
			 * tooltip behavior.
			 * 
			 * @config disabled
			 * @type Boolean
			 * @default false
			 */
            this.cfg.addProperty(DEFAULT_CONFIG.DISABLED.key, {
                handler: this.configContainer,
                value: DEFAULT_CONFIG.DISABLED.value,
                supressEvent: DEFAULT_CONFIG.DISABLED.suppressEvent
            });

            /**
			 * Specifies the XY offset from the mouse position, where the
			 * tooltip should be displayed, specified as a 2 element array (e.g.
			 * [10, 20]);
			 * 
			 * @config xyoffset
			 * @type Array
			 * @default [0, 25]
			 */
            this.cfg.addProperty(DEFAULT_CONFIG.XY_OFFSET.key, {
                value: DEFAULT_CONFIG.XY_OFFSET.value.concat(),
                supressEvent: DEFAULT_CONFIG.XY_OFFSET.suppressEvent 
            });

            /**
			 * Specifies the element or elements that the Tooltip should be
			 * anchored to on mouseover.
			 * 
			 * @config context
			 * @type HTMLElement[]/String[]
			 * @default null
			 */ 

            /**
			 * String representing the width of the Tooltip. <em>Please note:
            * </em>
			 * As of version 2.3 if either no value or a value of "auto" is
			 * specified, and the Toolip's "container" configuration property is
			 * set to something other than <code>document.body</code> or its
			 * "context" element resides outside the immediately visible portion
			 * of the document, the width of the Tooltip will be calculated
			 * based on the offsetWidth of its root HTML and set just before it
			 * is made visible. The original value will be restored when the
			 * Tooltip is hidden. This ensures the Tooltip is rendered at a
			 * usable width. For more information see YUILibrary bug #1685496
			 * and YUILibrary bug #1735423.
			 * 
			 * @config width
			 * @type String
			 * @default null
			 */
        
        },
        
        // BEGIN BUILT-IN PROPERTY EVENT HANDLERS //
        
        /**
		 * The default event handler fired when the "text" property is changed.
		 * 
		 * @method configText
		 * @param {String}
		 *            type The CustomEvent type (usually the property name)
		 * @param {Object[]}
		 *            args The CustomEvent arguments. For configuration
		 *            handlers, args[0] will equal the newly applied value for
		 *            the property.
		 * @param {Object}
		 *            obj The scope object. For configuration handlers, this
		 *            will usually equal the owner.
		 */
        configText: function (type, args, obj) {
            var text = args[0];
            if (text) {
                this.setBody(text);
            }
        },
        
        /**
		 * The default event handler fired when the "container" property is
		 * changed.
		 * 
		 * @method configContainer
		 * @param {String}
		 *            type The CustomEvent type (usually the property name)
		 * @param {Object[]}
		 *            args The CustomEvent arguments. For configuration
		 *            handlers, args[0] will equal the newly applied value for
		 *            the property.
		 * @param {Object}
		 *            obj The scope object. For configuration handlers, this
		 *            will usually equal the owner.
		 */
        configContainer: function (type, args, obj) {
            var container = args[0];

            if (typeof container == 'string') {
                this.cfg.setProperty("container", document.getElementById(container), true);
            }
        },
        
        /**
		 * @method _removeEventListeners
		 * @description Removes all of the DOM event handlers from the HTML
		 *              element(s) that trigger the display of the tooltip.
		 * @protected
		 */
        _removeEventListeners: function () {
        
            var aElements = this._context,
                nElements,
                oElement,
                i;

            if (aElements) {
                nElements = aElements.length;
                if (nElements > 0) {
                    i = nElements - 1;
                    do {
                        oElement = aElements[i];
                        Event.removeListener(oElement, "mouseover", this.onContextMouseOver);
                        Event.removeListener(oElement, "mousemove", this.onContextMouseMove);
                        Event.removeListener(oElement, "mouseout", this.onContextMouseOut);
                    }
                    while (i--);
                }
            }
        },
        
        /**
		 * The default event handler fired when the "context" property is
		 * changed.
		 * 
		 * @method configContext
		 * @param {String}
		 *            type The CustomEvent type (usually the property name)
		 * @param {Object[]}
		 *            args The CustomEvent arguments. For configuration
		 *            handlers, args[0] will equal the newly applied value for
		 *            the property.
		 * @param {Object}
		 *            obj The scope object. For configuration handlers, this
		 *            will usually equal the owner.
		 */
        configContext: function (type, args, obj) {

            var context = args[0],
                aElements,
                nElements,
                oElement,
                i;

            if (context) {

                // Normalize parameter into an array
                if (! (context instanceof Array)) {
                    if (typeof context == "string") {
                        this.cfg.setProperty("context", [document.getElementById(context)], true);
                    } else { // Assuming this is an element
                        this.cfg.setProperty("context", [context], true);
                    }
                    context = this.cfg.getProperty("context");
                }

                // Remove any existing mouseover/mouseout listeners
                this._removeEventListeners();

                // Add mouseover/mouseout listeners to context elements
                this._context = context;

                aElements = this._context;

                if (aElements) {
                    nElements = aElements.length;
                    if (nElements > 0) {
                        i = nElements - 1;
                        do {
                            oElement = aElements[i];
                            Event.on(oElement, "mouseover", this.onContextMouseOver, this);
                            Event.on(oElement, "mousemove", this.onContextMouseMove, this);
                            Event.on(oElement, "mouseout", this.onContextMouseOut, this);
                        }
                        while (i--);
                    }
                }
            }
        },

        // END BUILT-IN PROPERTY EVENT HANDLERS //

        // BEGIN BUILT-IN DOM EVENT HANDLERS //

        /**
		 * The default event handler fired when the user moves the mouse while
		 * over the context element.
		 * 
		 * @method onContextMouseMove
		 * @param {DOMEvent}
		 *            e The current DOM event
		 * @param {Object}
		 *            obj The object argument
		 */
        onContextMouseMove: function (e, obj) {
            obj.pageX = Event.getPageX(e);
            obj.pageY = Event.getPageY(e);
        },

        /**
		 * The default event handler fired when the user mouses over the context
		 * element.
		 * 
		 * @method onContextMouseOver
		 * @param {DOMEvent}
		 *            e The current DOM event
		 * @param {Object}
		 *            obj The object argument
		 */
        onContextMouseOver: function (e, obj) {
            var context = this;

            if (context.title) {
                obj._tempTitle = context.title;
                context.title = "";
            }

            // Fire first, to honor disabled set in the listner
            if (obj.fireEvent("contextMouseOver", context, e) !== false && !obj.cfg.getProperty("disabled")) {

                // Stop the tooltip from being hidden (set on last mouseout)
                if (obj.hideProcId) {
                    clearTimeout(obj.hideProcId);
                    obj.hideProcId = null;
                }

                Event.on(context, "mousemove", obj.onContextMouseMove, obj);

                /**
				 * The unique process ID associated with the thread responsible
				 * for showing the Tooltip.
				 * 
				 * @type int
				 */
                obj.showProcId = obj.doShow(e, context);
            }
        },

        /**
		 * The default event handler fired when the user mouses out of the
		 * context element.
		 * 
		 * @method onContextMouseOut
		 * @param {DOMEvent}
		 *            e The current DOM event
		 * @param {Object}
		 *            obj The object argument
		 */
        onContextMouseOut: function (e, obj) {
            var el = this;

            if (obj._tempTitle) {
                el.title = obj._tempTitle;
                obj._tempTitle = null;
            }

            if (obj.showProcId) {
                clearTimeout(obj.showProcId);
                obj.showProcId = null;
            }

            if (obj.hideProcId) {
                clearTimeout(obj.hideProcId);
                obj.hideProcId = null;
            }

            obj.fireEvent("contextMouseOut", el, e);

            obj.hideProcId = setTimeout(function () {
                obj.hide();
            }, obj.cfg.getProperty("hidedelay"));
        },

        // END BUILT-IN DOM EVENT HANDLERS //

        /**
		 * Processes the showing of the Tooltip by setting the timeout delay and
		 * offset of the Tooltip.
		 * 
		 * @method doShow
		 * @param {DOMEvent}
		 *            e The current DOM event
		 * @param {HTMLElement}
		 *            context The current context element
		 * @return {Number} The process ID of the timeout function associated
		 *         with doShow
		 */
        doShow: function (e, context) {

            var offset = this.cfg.getProperty("xyoffset"),
                xOffset = offset[0],
                yOffset = offset[1],
                me = this;

            if (UA.opera && context.tagName && 
                context.tagName.toUpperCase() == "A") {
                yOffset += 12;
            }

            return setTimeout(function () {

                var txt = me.cfg.getProperty("text");

                // title does not over-ride text
                if (me._tempTitle && (txt === "" || YAHOO.lang.isUndefined(txt) || YAHOO.lang.isNull(txt))) {
                    me.setBody(me._tempTitle);
                } else {
                    me.cfg.refireEvent("text");
                }

                me.moveTo(me.pageX + xOffset, me.pageY + yOffset);

                if (me.cfg.getProperty("preventoverlap")) {
                    me.preventOverlap(me.pageX, me.pageY);
                }

                Event.removeListener(context, "mousemove", me.onContextMouseMove);

                me.contextTriggerEvent.fire(context);

                me.show();

                me.hideProcId = me.doHide();

            }, this.cfg.getProperty("showdelay"));
        },

        /**
		 * Sets the timeout for the auto-dismiss delay, which by default is 5
		 * seconds, meaning that a tooltip will automatically dismiss itself
		 * after 5 seconds of being displayed.
		 * 
		 * @method doHide
		 */
        doHide: function () {

            var me = this;


            return setTimeout(function () {

                me.hide();

            }, this.cfg.getProperty("autodismissdelay"));

        },

        /**
		 * Fired when the Tooltip is moved, this event handler is used to
		 * prevent the Tooltip from overlapping with its context element.
		 * 
		 * @method preventOverlay
		 * @param {Number}
		 *            pageX The x coordinate position of the mouse pointer
		 * @param {Number}
		 *            pageY The y coordinate position of the mouse pointer
		 */
        preventOverlap: function (pageX, pageY) {
        
            var height = this.element.offsetHeight,
                mousePoint = new YAHOO.util.Point(pageX, pageY),
                elementRegion = Dom.getRegion(this.element);
        
            elementRegion.top -= 5;
            elementRegion.left -= 5;
            elementRegion.right += 5;
            elementRegion.bottom += 5;
        
        
            if (elementRegion.contains(mousePoint)) {
                this.cfg.setProperty("y", (pageY - height - 5));
            }
        },


        /**
		 * @method onRender
		 * @description "render" event handler for the Tooltip.
		 * @param {String}
		 *            p_sType String representing the name of the event that was
		 *            fired.
		 * @param {Array}
		 *            p_aArgs Array of arguments sent when the event was fired.
		 */
        onRender: function (p_sType, p_aArgs) {
    
            function sizeShadow() {
    
                var oElement = this.element,
                    oShadow = this.underlay;
            
                if (oShadow) {
                    oShadow.style.width = (oElement.offsetWidth + 6) + "px";
                    oShadow.style.height = (oElement.offsetHeight + 1) + "px"; 
                }
            
            }

            function addShadowVisibleClass() {
                Dom.addClass(this.underlay, "yui-tt-shadow-visible");

                if (UA.ie) {
                    this.forceUnderlayRedraw();
                }
            }

            function removeShadowVisibleClass() {
                Dom.removeClass(this.underlay, "yui-tt-shadow-visible");
            }

            function createShadow() {
    
                var oShadow = this.underlay,
                    oElement,
                    Module,
                    nIE,
                    me;
    
                if (!oShadow) {
    
                    oElement = this.element;
                    Module = YAHOO.widget.Module;
                    nIE = UA.ie;
                    me = this;

                    if (!m_oShadowTemplate) {
                        m_oShadowTemplate = document.createElement("div");
                        m_oShadowTemplate.className = "yui-tt-shadow";
                    }

                    oShadow = m_oShadowTemplate.cloneNode(false);

                    oElement.appendChild(oShadow);

                    this.underlay = oShadow;

                    // Backward compatibility, even though it's probably
                    // intended to be "private", it isn't marked as such in the
					// api docs
                    this._shadow = this.underlay;

                    addShadowVisibleClass.call(this);

                    this.subscribe("beforeShow", addShadowVisibleClass);
                    this.subscribe("hide", removeShadowVisibleClass);

                    if (bIEQuirks) {
                        window.setTimeout(function () { 
                            sizeShadow.call(me); 
                        }, 0);
    
                        this.cfg.subscribeToConfigEvent("width", sizeShadow);
                        this.cfg.subscribeToConfigEvent("height", sizeShadow);
                        this.subscribe("changeContent", sizeShadow);

                        Module.textResizeEvent.subscribe(sizeShadow, this, true);
                        this.subscribe("destroy", function () {
                            Module.textResizeEvent.unsubscribe(sizeShadow, this);
                        });
                    }
                }
            }

            function onBeforeShow() {
                createShadow.call(this);
                this.unsubscribe("beforeShow", onBeforeShow);
            }

            if (this.cfg.getProperty("visible")) {
                createShadow.call(this);
            } else {
                this.subscribe("beforeShow", onBeforeShow);
            }
        
        },

        /**
		 * Forces the underlay element to be repainted, through the
		 * application/removal of a yui-force-redraw class to the underlay
		 * element.
		 * 
		 * @method forceUnderlayRedraw
		 */
        forceUnderlayRedraw : function() {
            var tt = this;
            Dom.addClass(tt.underlay, "yui-force-redraw");
            setTimeout(function() {Dom.removeClass(tt.underlay, "yui-force-redraw");}, 0);
        },

        /**
		 * Removes the Tooltip element from the DOM and sets all child elements
		 * to null.
		 * 
		 * @method destroy
		 */
        destroy: function () {
        
            // Remove any existing mouseover/mouseout listeners
            this._removeEventListeners();

            Tooltip.superclass.destroy.call(this);  
        
        },
        
        /**
		 * Returns a string representation of the object.
		 * 
		 * @method toString
		 * @return {String} The string representation of the Tooltip
		 */
        toString: function () {
            return "Tooltip " + this.id;
        }
    
    });

}());
(function () {

    /**
	 * Panel is an implementation of Overlay that behaves like an OS window,
	 * with a draggable header and an optional close icon at the top right.
	 * 
	 * @namespace YAHOO.widget
	 * @class Panel
	 * @extends YAHOO.widget.Overlay
	 * @constructor
	 * @param {String}
	 *            el The element ID representing the Panel <em>OR</em>
	 * @param {HTMLElement}
	 *            el The element representing the Panel
	 * @param {Object}
	 *            userConfig The configuration object literal containing the
	 *            configuration that should be set for this Panel. See
	 *            configuration documentation for more details.
	 */
    YAHOO.widget.Panel = function (el, userConfig) {
        YAHOO.widget.Panel.superclass.constructor.call(this, el, userConfig);
    };

    var _currentModal = null;

    var Lang = YAHOO.lang,
        Util = YAHOO.util,
        Dom = Util.Dom,
        Event = Util.Event,
        CustomEvent = Util.CustomEvent,
        KeyListener = YAHOO.util.KeyListener,
        Config = Util.Config,
        Overlay = YAHOO.widget.Overlay,
        Panel = YAHOO.widget.Panel,
        UA = YAHOO.env.ua,

        bIEQuirks = (UA.ie && (UA.ie <= 6 || document.compatMode == "BackCompat")),

        m_oMaskTemplate,
        m_oUnderlayTemplate,
        m_oCloseIconTemplate,

        /**
		 * Constant representing the name of the Panel's events
		 * 
		 * @property EVENT_TYPES
		 * @private
		 * @final
		 * @type Object
		 */
        EVENT_TYPES = {
            "BEFORE_SHOW_MASK" : "beforeShowMask",
            "BEFORE_HIDE_MASK" : "beforeHideMask",
            "SHOW_MASK": "showMask",
            "HIDE_MASK": "hideMask",
            "DRAG": "drag"
        },

        /**
		 * Constant representing the Panel's configuration properties
		 * 
		 * @property DEFAULT_CONFIG
		 * @private
		 * @final
		 * @type Object
		 */
        DEFAULT_CONFIG = {

            "CLOSE": { 
                key: "close", 
                value: true, 
                validator: Lang.isBoolean, 
                supercedes: ["visible"] 
            },

            "DRAGGABLE": {
                key: "draggable", 
                value: (Util.DD ? true : false), 
                validator: Lang.isBoolean, 
                supercedes: ["visible"]  
            },

            "DRAG_ONLY" : {
                key: "dragonly",
                value: false,
                validator: Lang.isBoolean,
                supercedes: ["draggable"]
            },

            "UNDERLAY": { 
                key: "underlay", 
                value: "shadow", 
                supercedes: ["visible"] 
            },

            "MODAL": { 
                key: "modal", 
                value: false, 
                validator: Lang.isBoolean, 
                supercedes: ["visible", "zindex"]
            },

            "KEY_LISTENERS": {
                key: "keylisteners",
                suppressEvent: true,
                supercedes: ["visible"]
            },

            "STRINGS" : {
                key: "strings",
                supercedes: ["close"],
                validator: Lang.isObject,
                value: {
                    close: "Close"
                }
            }
        };

    /**
	 * Constant representing the default CSS class used for a Panel
	 * 
	 * @property YAHOO.widget.Panel.CSS_PANEL
	 * @static
	 * @final
	 * @type String
	 */
    Panel.CSS_PANEL = "yui-panel";
    
    /**
	 * Constant representing the default CSS class used for a Panel's wrapping
	 * container
	 * 
	 * @property YAHOO.widget.Panel.CSS_PANEL_CONTAINER
	 * @static
	 * @final
	 * @type String
	 */
    Panel.CSS_PANEL_CONTAINER = "yui-panel-container";

    /**
	 * Constant representing the default set of focusable elements on the
	 * pagewhich Modal Panels will prevent access to, when the modal mask is
	 * displayed
	 * 
	 * @property YAHOO.widget.Panel.FOCUSABLE
	 * @static
	 * @type Array
	 */
    Panel.FOCUSABLE = [
        "a",
        "button",
        "select",
        "textarea",
        "input",
        "iframe"
    ];

    // Private CustomEvent listeners

    /*
	 * "beforeRender" event handler that creates an empty header for a Panel
	 * instance if its "draggable" configuration property is set to "true" and
	 * no header has been created.
	 */

    function createHeader(p_sType, p_aArgs) {
        if (!this.header && this.cfg.getProperty("draggable")) {
            this.setHeader("&#160;");
        }
    }

    /*
	 * "hide" event handler that sets a Panel instance's "width" configuration
	 * property back to its original value before "setWidthToOffsetWidth" was
	 * called.
	 */

    function restoreOriginalWidth(p_sType, p_aArgs, p_oObject) {

        var sOriginalWidth = p_oObject[0],
            sNewWidth = p_oObject[1],
            oConfig = this.cfg,
            sCurrentWidth = oConfig.getProperty("width");

        if (sCurrentWidth == sNewWidth) {
            oConfig.setProperty("width", sOriginalWidth);
        }

        this.unsubscribe("hide", restoreOriginalWidth, p_oObject);
    }

    /*
	 * "beforeShow" event handler that sets a Panel instance's "width"
	 * configuration property to the value of its root HTML elements's
	 * offsetWidth
	 */

    function setWidthToOffsetWidth(p_sType, p_aArgs) {

        var oConfig,
            sOriginalWidth,
            sNewWidth;

        if (bIEQuirks) {

            oConfig = this.cfg;
            sOriginalWidth = oConfig.getProperty("width");
            
            if (!sOriginalWidth || sOriginalWidth == "auto") {
    
                sNewWidth = (this.element.offsetWidth + "px");
    
                oConfig.setProperty("width", sNewWidth);

                this.subscribe("hide", restoreOriginalWidth, 
                    [(sOriginalWidth || ""), sNewWidth]);
            
            }
        }
    }

    YAHOO.extend(Panel, Overlay, {

        /**
		 * The Overlay initialization method, which is executed for Overlay and
		 * all of its subclasses. This method is automatically called by the
		 * constructor, and sets up all DOM references for pre-existing markup,
		 * and creates required markup if it is not already present.
		 * 
		 * @method init
		 * @param {String}
		 *            el The element ID representing the Overlay <em>OR</em>
		 * @param {HTMLElement}
		 *            el The element representing the Overlay
		 * @param {Object}
		 *            userConfig The configuration object literal containing the
		 *            configuration that should be set for this Overlay. See
		 *            configuration documentation for more details.
		 */
        init: function (el, userConfig) {
            /*
			 * Note that we don't pass the user config in here yet because we
			 * only want it executed once, at the lowest subclass level
			 */

            Panel.superclass.init.call(this, el/* , userConfig */);

            this.beforeInitEvent.fire(Panel);

            Dom.addClass(this.element, Panel.CSS_PANEL);

            this.buildWrapper();

            if (userConfig) {
                this.cfg.applyConfig(userConfig, true);
            }

            this.subscribe("showMask", this._addFocusHandlers);
            this.subscribe("hideMask", this._removeFocusHandlers);
            this.subscribe("beforeRender", createHeader);

            this.subscribe("render", function() {
                this.setFirstLastFocusable();
                this.subscribe("changeContent", this.setFirstLastFocusable);
            });

            this.subscribe("show", this._focusOnShow);

            this.initEvent.fire(Panel);
        },

        /**
		 * @method _onElementFocus
		 * @private
		 * 
		 * "focus" event handler for a focuable element. Used to automatically
		 * blur the element when it receives focus to ensure that a Panel
		 * instance's modality is not compromised.
		 * 
		 * @param {Event}
		 *            e The DOM event object
		 */
        _onElementFocus : function(e){

            if(_currentModal === this) {

                var target = Event.getTarget(e),
                    doc = document.documentElement,
                    insideDoc = (target !== doc && target !== window);

                // mask and documentElement checks added for IE, which focuses
				// on the mask when it's clicked on, and focuses on
                // the documentElement, when the document scrollbars are clicked
				// on
                if (insideDoc && target !== this.element && target !== this.mask && !Dom.isAncestor(this.element, target)) {
                    try {
                        this._focusFirstModal();
                    } catch(err){
                        // Just in case we fail to focus
                        try {
                            if (insideDoc && target !== document.body) {
                                target.blur();
                            }
                        } catch(err2) { }
                    }
                }
            }
        },

        /**
		 * Focuses on the first element if present, otherwise falls back to the
		 * focus mechanisms used for modality. This method does not try/catch
		 * focus failures. The caller is responsible for catching exceptions,
		 * and taking remedial measures.
		 * 
		 * @method _focusFirstModal
		 */
        _focusFirstModal : function() {
            var el = this.firstElement;
            if (el) {
                el.focus();
            } else {
                if (this._modalFocus) {
                    this._modalFocus.focus();
                } else {
                    this.innerElement.focus();
                }
            }
        },

        /**
		 * @method _addFocusHandlers
		 * @protected
		 * 
		 * "showMask" event handler that adds a "focus" event handler to all
		 * focusable elements in the document to enforce a Panel instance's
		 * modality from being compromised.
		 * 
		 * @param p_sType
		 *            {String} Custom event type
		 * @param p_aArgs
		 *            {Array} Custom event arguments
		 */
        _addFocusHandlers: function(p_sType, p_aArgs) {
            if (!this.firstElement) {
                if (UA.webkit || UA.opera) {
                    if (!this._modalFocus) {
                        this._createHiddenFocusElement();
                    }
                } else {
                    this.innerElement.tabIndex = 0;
                }
            }
            this._setTabLoop(this.firstElement, this.lastElement);
            Event.onFocus(document.documentElement, this._onElementFocus, this, true);
            _currentModal = this;
        },

        /**
		 * Creates a hidden focusable element, used to focus on, to enforce
		 * modality for browsers in which focus cannot be applied to the
		 * container box.
		 * 
		 * @method _createHiddenFocusElement
		 * @private
		 */
        _createHiddenFocusElement : function() {
            var e = document.createElement("button");
            e.style.height = "1px";
            e.style.width = "1px";
            e.style.position = "absolute";
            e.style.left = "-10000em";
            e.style.opacity = 0;
            e.tabIndex = -1;
            this.innerElement.appendChild(e);
            this._modalFocus = e;
        },

        /**
		 * @method _removeFocusHandlers
		 * @protected
		 * 
		 * "hideMask" event handler that removes all "focus" event handlers
		 * added by the "addFocusEventHandlers" method.
		 * 
		 * @param p_sType
		 *            {String} Event type
		 * @param p_aArgs
		 *            {Array} Event Arguments
		 */
        _removeFocusHandlers: function(p_sType, p_aArgs) {
            Event.removeFocusListener(document.documentElement, this._onElementFocus, this);

            if (_currentModal == this) {
                _currentModal = null;
            }
        },

        /**
		 * Focus handler for the show event
		 * 
		 * @method _focusOnShow
		 * @param {String}
		 *            type Event Type
		 * @param {Array}
		 *            args Event arguments
		 * @param {Object}
		 *            obj Additional data
		 */
        _focusOnShow : function(type, args, obj) {

            if (args && args[1]) {
                Event.stopEvent(args[1]);
            }

            if (!this.focusFirst(type, args, obj)) {
                if (this.cfg.getProperty("modal")) {
                    this._focusFirstModal();
                }
            }
        },

        /**
		 * Sets focus to the first element in the Panel.
		 * 
		 * @method focusFirst
		 * @return {Boolean} true, if successfully focused, false otherwise
		 */
        focusFirst: function (type, args, obj) {
            var el = this.firstElement, focused = false;

            if (args && args[1]) {
                Event.stopEvent(args[1]);
            }

            if (el) {
                try {
                    el.focus();
                    focused = true;
                } catch(err) {
                    // Ignore
                }
            }

            return focused;
        },

        /**
		 * Sets focus to the last element in the Panel.
		 * 
		 * @method focusLast
		 * @return {Boolean} true, if successfully focused, false otherwise
		 */
        focusLast: function (type, args, obj) {
            var el = this.lastElement, focused = false;

            if (args && args[1]) {
                Event.stopEvent(args[1]);
            }

            if (el) {
                try {
                    el.focus();
                    focused = true;
                } catch(err) {
                    // Ignore
                }
            }

            return focused;
        },

        /**
		 * Protected internal method for setTabLoop, which can be used by
		 * subclasses to jump in and modify the arguments passed in if required.
		 * 
		 * @method _setTabLoop
		 * @param {HTMLElement}
		 *            firstElement
		 * @param {HTMLElement}
		 *            lastElement
		 * @protected
		 * 
		 */
        _setTabLoop : function(firstElement, lastElement) {
            this.setTabLoop(firstElement, lastElement);
        },

        /**
		 * Sets up a tab, shift-tab loop between the first and last elements
		 * provided. NOTE: Sets up the preventBackTab and preventTabOut
		 * KeyListener instance properties, which are reset everytime this
		 * method is invoked.
		 * 
		 * @method setTabLoop
		 * @param {HTMLElement}
		 *            firstElement
		 * @param {HTMLElement}
		 *            lastElement
		 * 
		 */
        setTabLoop : function(firstElement, lastElement) {

            var backTab = this.preventBackTab, tab = this.preventTabOut,
                showEvent = this.showEvent, hideEvent = this.hideEvent;

            if (backTab) {
                backTab.disable();
                showEvent.unsubscribe(backTab.enable, backTab);
                hideEvent.unsubscribe(backTab.disable, backTab);
                backTab = this.preventBackTab = null;
            }

            if (tab) {
                tab.disable();
                showEvent.unsubscribe(tab.enable, tab);
                hideEvent.unsubscribe(tab.disable,tab);
                tab = this.preventTabOut = null;
            }

            if (firstElement) {
                this.preventBackTab = new KeyListener(firstElement, 
                    {shift:true, keys:9},
                    {fn:this.focusLast, scope:this, correctScope:true}
                );
                backTab = this.preventBackTab;

                showEvent.subscribe(backTab.enable, backTab, true);
                hideEvent.subscribe(backTab.disable,backTab, true);
            }

            if (lastElement) {
                this.preventTabOut = new KeyListener(lastElement, 
                    {shift:false, keys:9}, 
                    {fn:this.focusFirst, scope:this, correctScope:true}
                );
                tab = this.preventTabOut;

                showEvent.subscribe(tab.enable, tab, true);
                hideEvent.subscribe(tab.disable,tab, true);
            }
        },

        /**
		 * Returns an array of the currently focusable items which reside within
		 * Panel. The set of focusable elements the method looks for are defined
		 * in the Panel.FOCUSABLE static property
		 * 
		 * @method getFocusableElements
		 * @param {HTMLElement}
		 *            root element to start from.
		 */
        getFocusableElements : function(root) {

            root = root || this.innerElement;

            var focusable = {}, panel = this;
            for (var i = 0; i < Panel.FOCUSABLE.length; i++) {
                focusable[Panel.FOCUSABLE[i]] = true;
            }

            // Not looking by Tag, since we want elements in DOM order
            
            return Dom.getElementsBy(function(el) { return panel._testIfFocusable(el, focusable); }, null, root);
        },

        /**
		 * This is the test method used by getFocusableElements, to determine
		 * which elements to include in the focusable elements list. Users may
		 * override this to customize behavior.
		 * 
		 * @method _testIfFocusable
		 * @param {Object}
		 *            el The element being tested
		 * @param {Object}
		 *            focusable The hash of known focusable elements, created by
		 *            an array-to-map operation on Panel.FOCUSABLE
		 * @protected
		 */
        _testIfFocusable: function(el, focusable) {
            if (el.focus && el.type !== "hidden" && !el.disabled && focusable[el.tagName.toLowerCase()]) {
                return true;
            }
            return false;
        },

        /**
		 * Sets the firstElement and lastElement instance properties to the
		 * first and last focusable elements in the Panel.
		 * 
		 * @method setFirstLastFocusable
		 */
        setFirstLastFocusable : function() {

            this.firstElement = null;
            this.lastElement = null;

            var elements = this.getFocusableElements();
            this.focusableElements = elements;

            if (elements.length > 0) {
                this.firstElement = elements[0];
                this.lastElement = elements[elements.length - 1];
            }

            if (this.cfg.getProperty("modal")) {
                this._setTabLoop(this.firstElement, this.lastElement);
            }
        },

        /**
		 * Initializes the custom events for Module which are fired
		 * automatically at appropriate times by the Module class.
		 */
        initEvents: function () {
            Panel.superclass.initEvents.call(this);

            var SIGNATURE = CustomEvent.LIST;

            /**
			 * CustomEvent fired after the modality mask is shown
			 * 
			 * @event showMaskEvent
			 */
            this.showMaskEvent = this.createEvent(EVENT_TYPES.SHOW_MASK);
            this.showMaskEvent.signature = SIGNATURE;

            /**
			 * CustomEvent fired before the modality mask is shown. Subscribers
			 * can return false to prevent the mask from being shown
			 * 
			 * @event beforeShowMaskEvent
			 */
            this.beforeShowMaskEvent = this.createEvent(EVENT_TYPES.BEFORE_SHOW_MASK);
            this.beforeShowMaskEvent.signature = SIGNATURE;

            /**
			 * CustomEvent fired after the modality mask is hidden
			 * 
			 * @event hideMaskEvent
			 */
            this.hideMaskEvent = this.createEvent(EVENT_TYPES.HIDE_MASK);
            this.hideMaskEvent.signature = SIGNATURE;

            /**
			 * CustomEvent fired before the modality mask is hidden. Subscribers
			 * can return false to prevent the mask from being hidden
			 * 
			 * @event beforeHideMaskEvent
			 */
            this.beforeHideMaskEvent = this.createEvent(EVENT_TYPES.BEFORE_HIDE_MASK);
            this.beforeHideMaskEvent.signature = SIGNATURE;

            /**
			 * CustomEvent when the Panel is dragged
			 * 
			 * @event dragEvent
			 */
            this.dragEvent = this.createEvent(EVENT_TYPES.DRAG);
            this.dragEvent.signature = SIGNATURE;
        },

        /**
		 * Initializes the class's configurable properties which can be changed
		 * using the Panel's Config object (cfg).
		 * 
		 * @method initDefaultConfig
		 */
        initDefaultConfig: function () {
            Panel.superclass.initDefaultConfig.call(this);

            // Add panel config properties //

            /**
			 * True if the Panel should display a "close" button
			 * 
			 * @config close
			 * @type Boolean
			 * @default true
			 */
            this.cfg.addProperty(DEFAULT_CONFIG.CLOSE.key, { 
                handler: this.configClose, 
                value: DEFAULT_CONFIG.CLOSE.value, 
                validator: DEFAULT_CONFIG.CLOSE.validator, 
                supercedes: DEFAULT_CONFIG.CLOSE.supercedes 
            });

            /**
			 * Boolean specifying if the Panel should be draggable. The default
			 * value is "true" if the Drag and Drop utility is included,
			 * otherwise it is "false." <strong>PLEASE NOTE:</strong> There is
			 * a known issue in IE 6 (Strict Mode and Quirks Mode) and IE 7
			 * (Quirks Mode) where Panels that either don't have a value set for
			 * their "width" configuration property, or their "width"
			 * configuration property is set to "auto" will only be draggable by
			 * placing the mouse on the text of the Panel's header element. To
			 * fix this bug, draggable Panels missing a value for their "width"
			 * configuration property, or whose "width" configuration property
			 * is set to "auto" will have it set to the value of their root HTML
			 * element's offsetWidth before they are made visible. The
			 * calculated width is then removed when the Panel is hidden.
			 * <em>This fix is only applied to draggable Panels in IE 6 
            * (Strict Mode and Quirks Mode) and IE 7 (Quirks Mode)</em>.
			 * For more information on this issue see: YUILibrary bugs #1726972
			 * and #1589210.
			 * 
			 * @config draggable
			 * @type Boolean
			 * @default true
			 */
            this.cfg.addProperty(DEFAULT_CONFIG.DRAGGABLE.key, {
                handler: this.configDraggable,
                value: (Util.DD) ? true : false,
                validator: DEFAULT_CONFIG.DRAGGABLE.validator,
                supercedes: DEFAULT_CONFIG.DRAGGABLE.supercedes
            });

            /**
			 * Boolean specifying if the draggable Panel should be drag only,
			 * not interacting with drop targets on the page.
			 * <p>
			 * When set to true, draggable Panels will not check to see if they
			 * are over drop targets, or fire the DragDrop events required to
			 * support drop target interaction (onDragEnter, onDragOver,
			 * onDragOut, onDragDrop etc.). If the Panel is not designed to be
			 * dropped on any target elements on the page, then this flag can be
			 * set to true to improve performance.
			 * </p>
			 * <p>
			 * When set to false, all drop target related events will be fired.
			 * </p>
			 * <p>
			 * The property is set to false by default to maintain backwards
			 * compatibility but should be set to true if drop target
			 * interaction is not required for the Panel, to improve
			 * performance.
			 * </p>
			 * 
			 * @config dragOnly
			 * @type Boolean
			 * @default false
			 */
            this.cfg.addProperty(DEFAULT_CONFIG.DRAG_ONLY.key, { 
                value: DEFAULT_CONFIG.DRAG_ONLY.value, 
                validator: DEFAULT_CONFIG.DRAG_ONLY.validator, 
                supercedes: DEFAULT_CONFIG.DRAG_ONLY.supercedes 
            });

            /**
			 * Sets the type of underlay to display for the Panel. Valid values
			 * are "shadow," "matte," and "none". <strong>PLEASE NOTE:</strong>
			 * The creation of the underlay element is deferred until the Panel
			 * is initially made visible. For Gecko-based browsers on Mac OS X
			 * the underlay elment is always created as it is used as a shim to
			 * prevent Aqua scrollbars below a Panel instance from poking
			 * through it (See YUILibrary bug #1723530).
			 * 
			 * @config underlay
			 * @type String
			 * @default shadow
			 */
            this.cfg.addProperty(DEFAULT_CONFIG.UNDERLAY.key, { 
                handler: this.configUnderlay, 
                value: DEFAULT_CONFIG.UNDERLAY.value, 
                supercedes: DEFAULT_CONFIG.UNDERLAY.supercedes 
            });
        
            /**
			 * True if the Panel should be displayed in a modal fashion,
			 * automatically creating a transparent mask over the document that
			 * will not be removed until the Panel is dismissed.
			 * 
			 * @config modal
			 * @type Boolean
			 * @default false
			 */
            this.cfg.addProperty(DEFAULT_CONFIG.MODAL.key, { 
                handler: this.configModal, 
                value: DEFAULT_CONFIG.MODAL.value,
                validator: DEFAULT_CONFIG.MODAL.validator, 
                supercedes: DEFAULT_CONFIG.MODAL.supercedes 
            });

            /**
			 * A KeyListener (or array of KeyListeners) that will be enabled
			 * when the Panel is shown, and disabled when the Panel is hidden.
			 * 
			 * @config keylisteners
			 * @type YAHOO.util.KeyListener[]
			 * @default null
			 */
            this.cfg.addProperty(DEFAULT_CONFIG.KEY_LISTENERS.key, { 
                handler: this.configKeyListeners, 
                suppressEvent: DEFAULT_CONFIG.KEY_LISTENERS.suppressEvent, 
                supercedes: DEFAULT_CONFIG.KEY_LISTENERS.supercedes 
            });

            /**
			 * UI Strings used by the Panel. The strings are inserted into the
			 * DOM as HTML, and should be escaped by the implementor if coming
			 * from an external source.
			 * 
			 * @config strings
			 * @type Object
			 * @default An object literal with the properties shown below:
			 *          <dl>
			 *          <dt>close</dt>
			 *          <dd><em>HTML</em> : The markup to use as the label
			 *          for the close icon. Defaults to "Close".</dd>
			 *          </dl>
			 */
            this.cfg.addProperty(DEFAULT_CONFIG.STRINGS.key, { 
                value:DEFAULT_CONFIG.STRINGS.value,
                handler:this.configStrings,
                validator:DEFAULT_CONFIG.STRINGS.validator,
                supercedes:DEFAULT_CONFIG.STRINGS.supercedes
            });
        },

        // BEGIN BUILT-IN PROPERTY EVENT HANDLERS //
        
        /**
		 * The default event handler fired when the "close" property is changed.
		 * The method controls the appending or hiding of the close icon at the
		 * top right of the Panel.
		 * 
		 * @method configClose
		 * @param {String}
		 *            type The CustomEvent type (usually the property name)
		 * @param {Object[]}
		 *            args The CustomEvent arguments. For configuration
		 *            handlers, args[0] will equal the newly applied value for
		 *            the property.
		 * @param {Object}
		 *            obj The scope object. For configuration handlers, this
		 *            will usually equal the owner.
		 */
        configClose: function (type, args, obj) {

            var val = args[0],
                oClose = this.close,
                strings = this.cfg.getProperty("strings"),
                fc;

            if (val) {
                if (!oClose) {

                    if (!m_oCloseIconTemplate) {
                        m_oCloseIconTemplate = document.createElement("a");
                        m_oCloseIconTemplate.className = "container-close";
                        m_oCloseIconTemplate.href = "#";
                    }

                    oClose = m_oCloseIconTemplate.cloneNode(true);

                    fc = this.innerElement.firstChild;

                    if (fc) {
                        this.innerElement.insertBefore(oClose, fc);
                    } else {
                        this.innerElement.appendChild(oClose);
                    }

                    oClose.innerHTML = (strings && strings.close) ? strings.close : "&#160;";

                    Event.on(oClose, "click", this._doClose, this, true);

                    this.close = oClose;

                } else {
                    oClose.style.display = "block";
                }

            } else {
                if (oClose) {
                    oClose.style.display = "none";
                }
            }

        },

        /**
		 * Event handler for the close icon
		 * 
		 * @method _doClose
		 * @protected
		 * 
		 * @param {DOMEvent}
		 *            e
		 */
        _doClose : function (e) {
            Event.preventDefault(e);
            this.hide();
        },

        /**
		 * The default event handler fired when the "draggable" property is
		 * changed.
		 * 
		 * @method configDraggable
		 * @param {String}
		 *            type The CustomEvent type (usually the property name)
		 * @param {Object[]}
		 *            args The CustomEvent arguments. For configuration
		 *            handlers, args[0] will equal the newly applied value for
		 *            the property.
		 * @param {Object}
		 *            obj The scope object. For configuration handlers, this
		 *            will usually equal the owner.
		 */
        configDraggable: function (type, args, obj) {
            var val = args[0];

            if (val) {
                if (!Util.DD) {
                    this.cfg.setProperty("draggable", false);
                    return;
                }

                if (this.header) {
                    Dom.setStyle(this.header, "cursor", "move");
                    this.registerDragDrop();
                }

                this.subscribe("beforeShow", setWidthToOffsetWidth);

            } else {

                if (this.dd) {
                    this.dd.unreg();
                }

                if (this.header) {
                    Dom.setStyle(this.header,"cursor","auto");
                }

                this.unsubscribe("beforeShow", setWidthToOffsetWidth);
            }
        },
      
        /**
		 * The default event handler fired when the "underlay" property is
		 * changed.
		 * 
		 * @method configUnderlay
		 * @param {String}
		 *            type The CustomEvent type (usually the property name)
		 * @param {Object[]}
		 *            args The CustomEvent arguments. For configuration
		 *            handlers, args[0] will equal the newly applied value for
		 *            the property.
		 * @param {Object}
		 *            obj The scope object. For configuration handlers, this
		 *            will usually equal the owner.
		 */
        configUnderlay: function (type, args, obj) {

            var bMacGecko = (this.platform == "mac" && UA.gecko),
                sUnderlay = args[0].toLowerCase(),
                oUnderlay = this.underlay,
                oElement = this.element;

            function createUnderlay() {
                var bNew = false;
                if (!oUnderlay) { // create if not already in DOM

                    if (!m_oUnderlayTemplate) {
                        m_oUnderlayTemplate = document.createElement("div");
                        m_oUnderlayTemplate.className = "underlay";
                    }

                    oUnderlay = m_oUnderlayTemplate.cloneNode(false);
                    this.element.appendChild(oUnderlay);

                    this.underlay = oUnderlay;

                    if (bIEQuirks) {
                        this.sizeUnderlay();
                        this.cfg.subscribeToConfigEvent("width", this.sizeUnderlay);
                        this.cfg.subscribeToConfigEvent("height", this.sizeUnderlay);

                        this.changeContentEvent.subscribe(this.sizeUnderlay);
                        YAHOO.widget.Module.textResizeEvent.subscribe(this.sizeUnderlay, this, true);
                    }

                    if (UA.webkit && UA.webkit < 420) {
                        this.changeContentEvent.subscribe(this.forceUnderlayRedraw);
                    }

                    bNew = true;
                }
            }

            function onBeforeShow() {
                var bNew = createUnderlay.call(this);
                if (!bNew && bIEQuirks) {
                    this.sizeUnderlay();
                }
                this._underlayDeferred = false;
                this.beforeShowEvent.unsubscribe(onBeforeShow);
            }

            function destroyUnderlay() {
                if (this._underlayDeferred) {
                    this.beforeShowEvent.unsubscribe(onBeforeShow);
                    this._underlayDeferred = false;
                }

                if (oUnderlay) {
                    this.cfg.unsubscribeFromConfigEvent("width", this.sizeUnderlay);
                    this.cfg.unsubscribeFromConfigEvent("height",this.sizeUnderlay);
                    this.changeContentEvent.unsubscribe(this.sizeUnderlay);
                    this.changeContentEvent.unsubscribe(this.forceUnderlayRedraw);
                    YAHOO.widget.Module.textResizeEvent.unsubscribe(this.sizeUnderlay, this, true);

                    this.element.removeChild(oUnderlay);

                    this.underlay = null;
                }
            }

            switch (sUnderlay) {
                case "shadow":
                    Dom.removeClass(oElement, "matte");
                    Dom.addClass(oElement, "shadow");
                    break;
                case "matte":
                    if (!bMacGecko) {
                        destroyUnderlay.call(this);
                    }
                    Dom.removeClass(oElement, "shadow");
                    Dom.addClass(oElement, "matte");
                    break;
                default:
                    if (!bMacGecko) {
                        destroyUnderlay.call(this);
                    }
                    Dom.removeClass(oElement, "shadow");
                    Dom.removeClass(oElement, "matte");
                    break;
            }

            if ((sUnderlay == "shadow") || (bMacGecko && !oUnderlay)) {
                if (this.cfg.getProperty("visible")) {
                    var bNew = createUnderlay.call(this);
                    if (!bNew && bIEQuirks) {
                        this.sizeUnderlay();
                    }
                } else {
                    if (!this._underlayDeferred) {
                        this.beforeShowEvent.subscribe(onBeforeShow);
                        this._underlayDeferred = true;
                    }
                }
            }
        },
        
        /**
		 * The default event handler fired when the "modal" property is changed.
		 * This handler subscribes or unsubscribes to the show and hide events
		 * to handle the display or hide of the modality mask.
		 * 
		 * @method configModal
		 * @param {String}
		 *            type The CustomEvent type (usually the property name)
		 * @param {Object[]}
		 *            args The CustomEvent arguments. For configuration
		 *            handlers, args[0] will equal the newly applied value for
		 *            the property.
		 * @param {Object}
		 *            obj The scope object. For configuration handlers, this
		 *            will usually equal the owner.
		 */
        configModal: function (type, args, obj) {

            var modal = args[0];
            if (modal) {
                if (!this._hasModalityEventListeners) {

                    this.subscribe("beforeShow", this.buildMask);
                    this.subscribe("beforeShow", this.bringToTop);
                    this.subscribe("beforeShow", this.showMask);
                    this.subscribe("hide", this.hideMask);

                    Overlay.windowResizeEvent.subscribe(this.sizeMask, 
                        this, true);

                    this._hasModalityEventListeners = true;
                }
            } else {
                if (this._hasModalityEventListeners) {

                    if (this.cfg.getProperty("visible")) {
                        this.hideMask();
                        this.removeMask();
                    }

                    this.unsubscribe("beforeShow", this.buildMask);
                    this.unsubscribe("beforeShow", this.bringToTop);
                    this.unsubscribe("beforeShow", this.showMask);
                    this.unsubscribe("hide", this.hideMask);

                    Overlay.windowResizeEvent.unsubscribe(this.sizeMask, this);

                    this._hasModalityEventListeners = false;
                }
            }
        },

        /**
		 * Removes the modality mask.
		 * 
		 * @method removeMask
		 */
        removeMask: function () {

            var oMask = this.mask,
                oParentNode;

            if (oMask) {
                /*
				 * Hide the mask before destroying it to ensure that DOM event
				 * handlers on focusable elements get removed.
				 */
                this.hideMask();

                oParentNode = oMask.parentNode;
                if (oParentNode) {
                    oParentNode.removeChild(oMask);
                }

                this.mask = null;
            }
        },
        
        /**
		 * The default event handler fired when the "keylisteners" property is
		 * changed.
		 * 
		 * @method configKeyListeners
		 * @param {String}
		 *            type The CustomEvent type (usually the property name)
		 * @param {Object[]}
		 *            args The CustomEvent arguments. For configuration
		 *            handlers, args[0] will equal the newly applied value for
		 *            the property.
		 * @param {Object}
		 *            obj The scope object. For configuration handlers, this
		 *            will usually equal the owner.
		 */
        configKeyListeners: function (type, args, obj) {

            var listeners = args[0],
                listener,
                nListeners,
                i;
        
            if (listeners) {

                if (listeners instanceof Array) {

                    nListeners = listeners.length;

                    for (i = 0; i < nListeners; i++) {

                        listener = listeners[i];
        
                        if (!Config.alreadySubscribed(this.showEvent, 
                            listener.enable, listener)) {

                            this.showEvent.subscribe(listener.enable, 
                                listener, true);

                        }

                        if (!Config.alreadySubscribed(this.hideEvent, 
                            listener.disable, listener)) {

                            this.hideEvent.subscribe(listener.disable, 
                                listener, true);

                            this.destroyEvent.subscribe(listener.disable, 
                                listener, true);
                        }
                    }

                } else {

                    if (!Config.alreadySubscribed(this.showEvent, 
                        listeners.enable, listeners)) {

                        this.showEvent.subscribe(listeners.enable, 
                            listeners, true);
                    }

                    if (!Config.alreadySubscribed(this.hideEvent, 
                        listeners.disable, listeners)) {

                        this.hideEvent.subscribe(listeners.disable, 
                            listeners, true);

                        this.destroyEvent.subscribe(listeners.disable, 
                            listeners, true);

                    }

                }

            }

        },

        /**
		 * The default handler for the "strings" property
		 * 
		 * @method configStrings
		 */
        configStrings : function(type, args, obj) {
            var val = Lang.merge(DEFAULT_CONFIG.STRINGS.value, args[0]);
            this.cfg.setProperty(DEFAULT_CONFIG.STRINGS.key, val, true);
        },

        /**
		 * The default event handler fired when the "height" property is
		 * changed.
		 * 
		 * @method configHeight
		 * @param {String}
		 *            type The CustomEvent type (usually the property name)
		 * @param {Object[]}
		 *            args The CustomEvent arguments. For configuration
		 *            handlers, args[0] will equal the newly applied value for
		 *            the property.
		 * @param {Object}
		 *            obj The scope object. For configuration handlers, this
		 *            will usually equal the owner.
		 */
        configHeight: function (type, args, obj) {
            var height = args[0],
                el = this.innerElement;

            Dom.setStyle(el, "height", height);
            this.cfg.refireEvent("iframe");
        },

        /**
		 * The default custom event handler executed when the Panel's height is
		 * changed, if the autofillheight property has been set.
		 * 
		 * @method _autoFillOnHeightChange
		 * @protected
		 * @param {String}
		 *            type The event type
		 * @param {Array}
		 *            args The array of arguments passed to event subscribers
		 * @param {HTMLElement}
		 *            el The header, body or footer element which is to be
		 *            resized to fill out the containers height
		 */
        _autoFillOnHeightChange : function(type, args, el) {
            Panel.superclass._autoFillOnHeightChange.apply(this, arguments);
            if (bIEQuirks) {
                var panel = this;
                setTimeout(function() {
                    panel.sizeUnderlay();
                },0);
            }
        },

        /**
		 * The default event handler fired when the "width" property is changed.
		 * 
		 * @method configWidth
		 * @param {String}
		 *            type The CustomEvent type (usually the property name)
		 * @param {Object[]}
		 *            args The CustomEvent arguments. For configuration
		 *            handlers, args[0] will equal the newly applied value for
		 *            the property.
		 * @param {Object}
		 *            obj The scope object. For configuration handlers, this
		 *            will usually equal the owner.
		 */
        configWidth: function (type, args, obj) {
    
            var width = args[0],
                el = this.innerElement;
    
            Dom.setStyle(el, "width", width);
            this.cfg.refireEvent("iframe");
    
        },
        
        /**
		 * The default event handler fired when the "zIndex" property is
		 * changed.
		 * 
		 * @method configzIndex
		 * @param {String}
		 *            type The CustomEvent type (usually the property name)
		 * @param {Object[]}
		 *            args The CustomEvent arguments. For configuration
		 *            handlers, args[0] will equal the newly applied value for
		 *            the property.
		 * @param {Object}
		 *            obj The scope object. For configuration handlers, this
		 *            will usually equal the owner.
		 */
        configzIndex: function (type, args, obj) {
            Panel.superclass.configzIndex.call(this, type, args, obj);

            if (this.mask || this.cfg.getProperty("modal") === true) {
                var panelZ = Dom.getStyle(this.element, "zIndex");
                if (!panelZ || isNaN(panelZ)) {
                    panelZ = 0;
                }

                if (panelZ === 0) {
                    // Recursive call to configzindex (which should be stopped
                    // from going further because panelZ should no longer === 0)
                    this.cfg.setProperty("zIndex", 1);
                } else {
                    this.stackMask();
                }
            }
        },

        // END BUILT-IN PROPERTY EVENT HANDLERS //
        /**
		 * Builds the wrapping container around the Panel that is used for
		 * positioning the shadow and matte underlays. The container element is
		 * assigned to a local instance variable called container, and the
		 * element is reinserted inside of it.
		 * 
		 * @method buildWrapper
		 */
        buildWrapper: function () {

            var elementParent = this.element.parentNode,
                originalElement = this.element,
                wrapper = document.createElement("div");

            wrapper.className = Panel.CSS_PANEL_CONTAINER;
            wrapper.id = originalElement.id + "_c";

            if (elementParent) {
                elementParent.insertBefore(wrapper, originalElement);
            }

            wrapper.appendChild(originalElement);

            this.element = wrapper;
            this.innerElement = originalElement;

            Dom.setStyle(this.innerElement, "visibility", "inherit");
        },

        /**
		 * Adjusts the size of the shadow based on the size of the element.
		 * 
		 * @method sizeUnderlay
		 */
        sizeUnderlay: function () {
            var oUnderlay = this.underlay,
                oElement;

            if (oUnderlay) {
                oElement = this.element;
                oUnderlay.style.width = oElement.offsetWidth + "px";
                oUnderlay.style.height = oElement.offsetHeight + "px";
            }
        },

        /**
		 * Registers the Panel's header for drag & drop capability.
		 * 
		 * @method registerDragDrop
		 */
        registerDragDrop: function () {

            var me = this;

            if (this.header) {

                if (!Util.DD) {
                    return;
                }

                var bDragOnly = (this.cfg.getProperty("dragonly") === true);

                /**
				 * The YAHOO.util.DD instance, used to implement the draggable
				 * header for the panel if draggable is enabled
				 * 
				 * @property dd
				 * @type YAHOO.util.DD
				 */
                this.dd = new Util.DD(this.element.id, this.id, {dragOnly: bDragOnly});

                if (!this.header.id) {
                    this.header.id = this.id + "_h";
                }

                this.dd.startDrag = function () {

                    var offsetHeight,
                        offsetWidth,
                        viewPortWidth,
                        viewPortHeight,
                        scrollX,
                        scrollY;

                    if (YAHOO.env.ua.ie == 6) {
                        Dom.addClass(me.element,"drag");
                    }

                    if (me.cfg.getProperty("constraintoviewport")) {

                        var nViewportOffset = Overlay.VIEWPORT_OFFSET;

                        offsetHeight = me.element.offsetHeight;
                        offsetWidth = me.element.offsetWidth;

                        viewPortWidth = Dom.getViewportWidth();
                        viewPortHeight = Dom.getViewportHeight();

                        scrollX = Dom.getDocumentScrollLeft();
                        scrollY = Dom.getDocumentScrollTop();

                        if (offsetHeight + nViewportOffset < viewPortHeight) {
                            this.minY = scrollY + nViewportOffset;
                            this.maxY = scrollY + viewPortHeight - offsetHeight - nViewportOffset;
                        } else {
                            this.minY = scrollY + nViewportOffset;
                            this.maxY = scrollY + nViewportOffset;
                        }

                        if (offsetWidth + nViewportOffset < viewPortWidth) {
                            this.minX = scrollX + nViewportOffset;
                            this.maxX = scrollX + viewPortWidth - offsetWidth - nViewportOffset;
                        } else {
                            this.minX = scrollX + nViewportOffset;
                            this.maxX = scrollX + nViewportOffset;
                        }

                        this.constrainX = true;
                        this.constrainY = true;
                    } else {
                        this.constrainX = false;
                        this.constrainY = false;
                    }

                    me.dragEvent.fire("startDrag", arguments);
                };

                this.dd.onDrag = function () {
                    me.syncPosition();
                    me.cfg.refireEvent("iframe");
                    if (this.platform == "mac" && YAHOO.env.ua.gecko) {
                        this.showMacGeckoScrollbars();
                    }

                    me.dragEvent.fire("onDrag", arguments);
                };

                this.dd.endDrag = function () {

                    if (YAHOO.env.ua.ie == 6) {
                        Dom.removeClass(me.element,"drag");
                    }

                    me.dragEvent.fire("endDrag", arguments);
                    me.moveEvent.fire(me.cfg.getProperty("xy"));

                };

                this.dd.setHandleElId(this.header.id);
                this.dd.addInvalidHandleType("INPUT");
                this.dd.addInvalidHandleType("SELECT");
                this.dd.addInvalidHandleType("TEXTAREA");
            }
        },
        
        /**
		 * Builds the mask that is laid over the document when the Panel is
		 * configured to be modal.
		 * 
		 * @method buildMask
		 */
        buildMask: function () {
            var oMask = this.mask;
            if (!oMask) {
                if (!m_oMaskTemplate) {
                    m_oMaskTemplate = document.createElement("div");
                    m_oMaskTemplate.className = "mask";
                    m_oMaskTemplate.innerHTML = "&#160;";
                }
                oMask = m_oMaskTemplate.cloneNode(true);
                oMask.id = this.id + "_mask";

                document.body.insertBefore(oMask, document.body.firstChild);

                this.mask = oMask;

                if (YAHOO.env.ua.gecko && this.platform == "mac") {
                    Dom.addClass(this.mask, "block-scrollbars");
                }

                // Stack mask based on the element zindex
                this.stackMask();
            }
        },

        /**
		 * Hides the modality mask.
		 * 
		 * @method hideMask
		 */
        hideMask: function () {
            if (this.cfg.getProperty("modal") && this.mask && this.beforeHideMaskEvent.fire()) {
                this.mask.style.display = "none";
                Dom.removeClass(document.body, "masked");
                this.hideMaskEvent.fire();
            }
        },

        /**
		 * Shows the modality mask.
		 * 
		 * @method showMask
		 */
        showMask: function () {
            if (this.cfg.getProperty("modal") && this.mask && this.beforeShowMaskEvent.fire()) {
                Dom.addClass(document.body, "masked");
                this.sizeMask();
                this.mask.style.display = "block";
                this.showMaskEvent.fire();
            }
        },

        /**
		 * Sets the size of the modality mask to cover the entire scrollable
		 * area of the document
		 * 
		 * @method sizeMask
		 */
        sizeMask: function () {
            if (this.mask) {

                // Shrink mask first, so it doesn't affect the document size.
                var mask = this.mask,
                    viewWidth = Dom.getViewportWidth(),
                    viewHeight = Dom.getViewportHeight();

                if (mask.offsetHeight > viewHeight) {
                    mask.style.height = viewHeight + "px";
                }

                if (mask.offsetWidth > viewWidth) {
                    mask.style.width = viewWidth + "px";
                }

                // Then size it to the document
                mask.style.height = Dom.getDocumentHeight() + "px";
                mask.style.width = Dom.getDocumentWidth() + "px";
            }
        },

        /**
		 * Sets the zindex of the mask, if it exists, based on the zindex of the
		 * Panel element. The zindex of the mask is set to be one less than the
		 * Panel element's zindex.
		 * 
		 * <p>
		 * NOTE: This method will not bump up the zindex of the Panel to ensure
		 * that the mask has a non-negative zindex. If you require the mask
		 * zindex to be 0 or higher, the zindex of the Panel should be set to a
		 * value higher than 0, before this method is called.
		 * </p>
		 * 
		 * @method stackMask
		 */
        stackMask: function() {
            if (this.mask) {
                var panelZ = Dom.getStyle(this.element, "zIndex");
                if (!YAHOO.lang.isUndefined(panelZ) && !isNaN(panelZ)) {
                    Dom.setStyle(this.mask, "zIndex", panelZ - 1);
                }
            }
        },

        /**
		 * Renders the Panel by inserting the elements that are not already in
		 * the main Panel into their correct places. Optionally appends the
		 * Panel to the specified node prior to the render's execution. NOTE:
		 * For Panels without existing markup, the appendToNode argument is
		 * REQUIRED. If this argument is ommitted and the current element is not
		 * present in the document, the function will return false, indicating
		 * that the render was a failure.
		 * 
		 * @method render
		 * @param {String}
		 *            appendToNode The element id to which the Module should be
		 *            appended to prior to rendering <em>OR</em>
		 * @param {HTMLElement}
		 *            appendToNode The element to which the Module should be
		 *            appended to prior to rendering
		 * @return {boolean} Success or failure of the render
		 */
        render: function (appendToNode) {
            return Panel.superclass.render.call(this, appendToNode, this.innerElement);
        },

        /**
		 * Renders the currently set header into it's proper position under the
		 * module element. If the module element is not provided,
		 * "this.innerElement" is used.
		 * 
		 * @method _renderHeader
		 * @protected
		 * @param {HTMLElement}
		 *            moduleElement Optional. A reference to the module element
		 */
        _renderHeader: function(moduleElement){
            moduleElement = moduleElement || this.innerElement;
			Panel.superclass._renderHeader.call(this, moduleElement);
        },

        /**
		 * Renders the currently set body into it's proper position under the
		 * module element. If the module element is not provided,
		 * "this.innerElement" is used.
		 * 
		 * @method _renderBody
		 * @protected
		 * @param {HTMLElement}
		 *            moduleElement Optional. A reference to the module element.
		 */
        _renderBody: function(moduleElement){
            moduleElement = moduleElement || this.innerElement;
            Panel.superclass._renderBody.call(this, moduleElement);
        },

        /**
		 * Renders the currently set footer into it's proper position under the
		 * module element. If the module element is not provided,
		 * "this.innerElement" is used.
		 * 
		 * @method _renderFooter
		 * @protected
		 * @param {HTMLElement}
		 *            moduleElement Optional. A reference to the module element
		 */
        _renderFooter: function(moduleElement){
            moduleElement = moduleElement || this.innerElement;
            Panel.superclass._renderFooter.call(this, moduleElement);
        },

        /**
		 * Removes the Panel element from the DOM and sets all child elements to
		 * null.
		 * 
		 * @method destroy
		 * @param {boolean}
		 *            shallowPurge If true, only the parent element's DOM event
		 *            listeners are purged. If false, or not provided, all
		 *            children are also purged of DOM event listeners. NOTE: The
		 *            flag is a "shallowPurge" flag, as opposed to what may be a
		 *            more intuitive "purgeChildren" flag to maintain backwards
		 *            compatibility with behavior prior to 2.9.0.
		 */
        destroy: function (shallowPurge) {
            Overlay.windowResizeEvent.unsubscribe(this.sizeMask, this);
            this.removeMask();
            if (this.close) {
                Event.purgeElement(this.close);
            }
            Panel.superclass.destroy.call(this, shallowPurge);  
        },

        /**
		 * Forces the underlay element to be repainted through the
		 * application/removal of a yui-force-redraw class to the underlay
		 * element.
		 * 
		 * @method forceUnderlayRedraw
		 */
        forceUnderlayRedraw : function () {
            var u = this.underlay;
            Dom.addClass(u, "yui-force-redraw");
            setTimeout(function(){Dom.removeClass(u, "yui-force-redraw");}, 0);
        },

        /**
		 * Returns a String representation of the object.
		 * 
		 * @method toString
		 * @return {String} The string representation of the Panel.
		 */
        toString: function () {
            return "Panel " + this.id;
        }
    
    });

}());
(function () {

    /**
	 * <p>
	 * Dialog is an implementation of Panel that can be used to submit form
	 * data.
	 * </p>
	 * <p>
	 * Built-in functionality for buttons with event handlers is included. If
	 * the optional YUI Button dependancy is included on the page, the buttons
	 * created will be instances of YAHOO.widget.Button, otherwise regular HTML
	 * buttons will be created.
	 * </p>
	 * <p>
	 * Forms can be processed in 3 ways -- via an asynchronous Connection
	 * utility call, a simple form POST or GET, or manually. The YUI Connection
	 * utility should be included if you're using the default "async"
	 * postmethod, but is not required if you're using any of the other
	 * postmethod values.
	 * </p>
	 * 
	 * @namespace YAHOO.widget
	 * @class Dialog
	 * @extends YAHOO.widget.Panel
	 * @constructor
	 * @param {String}
	 *            el The element ID representing the Dialog <em>OR</em>
	 * @param {HTMLElement}
	 *            el The element representing the Dialog
	 * @param {Object}
	 *            userConfig The configuration object literal containing the
	 *            configuration that should be set for this Dialog. See
	 *            configuration documentation for more details.
	 */
    YAHOO.widget.Dialog = function (el, userConfig) {
        YAHOO.widget.Dialog.superclass.constructor.call(this, el, userConfig);
    };

    var Event = YAHOO.util.Event,
        CustomEvent = YAHOO.util.CustomEvent,
        Dom = YAHOO.util.Dom,
        Dialog = YAHOO.widget.Dialog,
        Lang = YAHOO.lang,

        /**
		 * Constant representing the name of the Dialog's events
		 * 
		 * @property EVENT_TYPES
		 * @private
		 * @final
		 * @type Object
		 */
        EVENT_TYPES = {
            "BEFORE_SUBMIT": "beforeSubmit",
            "SUBMIT": "submit",
            "MANUAL_SUBMIT": "manualSubmit",
            "ASYNC_SUBMIT": "asyncSubmit",
            "FORM_SUBMIT": "formSubmit",
            "CANCEL": "cancel"
        },

        /**
		 * Constant representing the Dialog's configuration properties
		 * 
		 * @property DEFAULT_CONFIG
		 * @private
		 * @final
		 * @type Object
		 */
        DEFAULT_CONFIG = {

            "POST_METHOD": { 
                key: "postmethod", 
                value: "async"
            },

            "POST_DATA" : {
                key: "postdata",
                value: null
            },

            "BUTTONS": {
                key: "buttons",
                value: "none",
                supercedes: ["visible"]
            },

            "HIDEAFTERSUBMIT" : {
                key: "hideaftersubmit",
                value: true
            }

        };

    /**
	 * Constant representing the default CSS class used for a Dialog
	 * 
	 * @property YAHOO.widget.Dialog.CSS_DIALOG
	 * @static
	 * @final
	 * @type String
	 */
    Dialog.CSS_DIALOG = "yui-dialog";

    function removeButtonEventHandlers() {

        var aButtons = this._aButtons,
            nButtons,
            oButton,
            i;

        if (Lang.isArray(aButtons)) {
            nButtons = aButtons.length;

            if (nButtons > 0) {
                i = nButtons - 1;
                do {
                    oButton = aButtons[i];

                    if (YAHOO.widget.Button && oButton instanceof YAHOO.widget.Button) {
                        oButton.destroy();
                    }
                    else if (oButton.tagName.toUpperCase() == "BUTTON") {
                        Event.purgeElement(oButton);
                        Event.purgeElement(oButton, false);
                    }
                }
                while (i--);
            }
        }
    }

    YAHOO.extend(Dialog, YAHOO.widget.Panel, { 

        /**
		 * @property form
		 * @description Object reference to the Dialog's
		 *              <code>&#60;form&#62;</code> element.
		 * @default null
		 * @type <a href="http://www.w3.org/TR/2000/WD-DOM-Level-1-20000929/
		 *       level-one-html.html#ID-40002357">HTMLFormElement</a>
		 */
        form: null,
    
        /**
		 * Initializes the class's configurable properties which can be changed
		 * using the Dialog's Config object (cfg).
		 * 
		 * @method initDefaultConfig
		 */
        initDefaultConfig: function () {
            Dialog.superclass.initDefaultConfig.call(this);

            /**
			 * The internally maintained callback object for use with the
			 * Connection utility. The format of the callback object is similar
			 * to Connection Manager's callback object and is simply passed
			 * through to Connection Manager when the async request is made.
			 * 
			 * @property callback
			 * @type Object
			 */
            this.callback = {

                /**
				 * The function to execute upon success of the Connection
				 * submission (when the form does not contain a file input
				 * element).
				 * 
				 * @property callback.success
				 * @type Function
				 */
                success: null,

                /**
				 * The function to execute upon failure of the Connection
				 * submission
				 * 
				 * @property callback.failure
				 * @type Function
				 */
                failure: null,

                /**
				 * <p>
				 * The function to execute upon success of the Connection
				 * submission, when the form contains a file input element.
				 * </p>
				 * <p>
				 * <em>NOTE:</em> Connection manager will not invoke the
				 * success or failure handlers for the file upload use case.
				 * This will be the only callback handler invoked.
				 * </p>
				 * <p>
				 * For more information, see the <a
				 * href="http://developer.yahoo.com/yui/connection/#file">
				 * Connection Manager documenation on file uploads</a>.
				 * </p>
				 * 
				 * @property callback.upload
				 * @type Function
				 */

                /**
				 * The arbitrary argument or arguments to pass to the Connection
				 * callback functions
				 * 
				 * @property callback.argument
				 * @type Object
				 */
                argument: null

            };

            // Add form dialog config properties //
            /**
			 * The method to use for posting the Dialog's form. Possible values
			 * are "async", "form", and "manual".
			 * 
			 * @config postmethod
			 * @type String
			 * @default async
			 */
            this.cfg.addProperty(DEFAULT_CONFIG.POST_METHOD.key, {
                handler: this.configPostMethod, 
                value: DEFAULT_CONFIG.POST_METHOD.value, 
                validator: function (val) {
                    if (val != "form" && val != "async" && val != "none" && 
                        val != "manual") {
                        return false;
                    } else {
                        return true;
                    }
                }
            });

            /**
			 * Any additional post data which needs to be sent when using the <a
			 * href="#config_postmethod">async</a> postmethod for dialog POST
			 * submissions. The format for the post data string is defined by
			 * Connection Manager's <a
			 * href="YAHOO.util.Connect.html#method_asyncRequest">asyncRequest</a>
			 * method.
			 * 
			 * @config postdata
			 * @type String
			 * @default null
			 */
            this.cfg.addProperty(DEFAULT_CONFIG.POST_DATA.key, {
                value: DEFAULT_CONFIG.POST_DATA.value
            });

            /**
			 * This property is used to configure whether or not the dialog
			 * should be automatically hidden after submit.
			 * 
			 * @config hideaftersubmit
			 * @type Boolean
			 * @default true
			 */
            this.cfg.addProperty(DEFAULT_CONFIG.HIDEAFTERSUBMIT.key, {
                value: DEFAULT_CONFIG.HIDEAFTERSUBMIT.value
            });

            /**
			 * Array of object literals, each containing a set of properties
			 * defining a button to be appended into the Dialog's footer.
			 * 
			 * <p>
			 * Each button object in the buttons array can have three
			 * properties:
			 * </p>
			 * <dl>
			 * <dt>text:</dt>
			 * <dd> The text that will display on the face of the button. The
			 * text can include HTML, as long as it is compliant with HTML
			 * Button specifications. The text is added to the DOM as HTML, and
			 * should be escaped by the implementor if coming from an external
			 * source. </dd>
			 * <dt>handler:</dt>
			 * <dd>Can be either:
			 * <ol>
			 * <li>A reference to a function that should fire when the button
			 * is clicked. (In this case scope of this function is always its
			 * Dialog instance.)</li>
			 * 
			 * <li>An object literal representing the code to be executed when
			 * the button is clicked.
			 * 
			 * <p>
			 * Format:
			 * </p>
			 * 
			 * <p>
			 * <code>{
            *       <br>
            *       <strong>fn:</strong> Function, &#47;&#47;
            *       The handler to call when  the event fires.
            *       <br>
            *       <strong>obj:</strong> Object, &#47;&#47; 
            *       An  object to pass back to the handler.
            *       <br>
            *       <strong>scope:</strong> Object &#47;&#47; 
            *       The object to use for the scope of the handler.
            *       <br>
            *       }</code>
			 * </p>
			 * </li>
			 * </ol>
			 * </dd>
			 * <dt>isDefault:</dt>
			 * <dd> An optional boolean value that specifies that a button
			 * should be highlighted and focused by default. </dd>
			 * </dl>
			 * 
			 * <em>NOTE:</em>If the YUI Button Widget is included on the
			 * page, the buttons created will be instances of
			 * YAHOO.widget.Button. Otherwise, HTML Buttons (<code>&#60;BUTTON&#62;</code>)
			 * will be created.
			 * 
			 * @config buttons
			 * @type {Array|String}
			 * @default "none"
			 */
            this.cfg.addProperty(DEFAULT_CONFIG.BUTTONS.key, {
                handler: this.configButtons,
                value: DEFAULT_CONFIG.BUTTONS.value,
                supercedes : DEFAULT_CONFIG.BUTTONS.supercedes
            }); 

        },

        /**
		 * Initializes the custom events for Dialog which are fired
		 * automatically at appropriate times by the Dialog class.
		 * 
		 * @method initEvents
		 */
        initEvents: function () {
            Dialog.superclass.initEvents.call(this);

            var SIGNATURE = CustomEvent.LIST;

            /**
			 * CustomEvent fired prior to submission
			 * 
			 * @event beforeSubmitEvent
			 */ 
            this.beforeSubmitEvent = 
                this.createEvent(EVENT_TYPES.BEFORE_SUBMIT);
            this.beforeSubmitEvent.signature = SIGNATURE;
            
            /**
			 * CustomEvent fired after submission
			 * 
			 * @event submitEvent
			 */
            this.submitEvent = this.createEvent(EVENT_TYPES.SUBMIT);
            this.submitEvent.signature = SIGNATURE;
        
            /**
			 * CustomEvent fired for manual submission, before the generic
			 * submit event is fired
			 * 
			 * @event manualSubmitEvent
			 */
            this.manualSubmitEvent = 
                this.createEvent(EVENT_TYPES.MANUAL_SUBMIT);
            this.manualSubmitEvent.signature = SIGNATURE;

            /**
			 * CustomEvent fired after asynchronous submission, before the
			 * generic submit event is fired
			 * 
			 * @event asyncSubmitEvent
			 * @param {Object}
			 *            conn The connection object, returned by
			 *            YAHOO.util.Connect.asyncRequest
			 */
            this.asyncSubmitEvent = this.createEvent(EVENT_TYPES.ASYNC_SUBMIT);
            this.asyncSubmitEvent.signature = SIGNATURE;

            /**
			 * CustomEvent fired after form-based submission, before the generic
			 * submit event is fired
			 * 
			 * @event formSubmitEvent
			 */
            this.formSubmitEvent = this.createEvent(EVENT_TYPES.FORM_SUBMIT);
            this.formSubmitEvent.signature = SIGNATURE;

            /**
			 * CustomEvent fired after cancel
			 * 
			 * @event cancelEvent
			 */
            this.cancelEvent = this.createEvent(EVENT_TYPES.CANCEL);
            this.cancelEvent.signature = SIGNATURE;
        
        },
        
        /**
		 * The Dialog initialization method, which is executed for Dialog and
		 * all of its subclasses. This method is automatically called by the
		 * constructor, and sets up all DOM references for pre-existing markup,
		 * and creates required markup if it is not already present.
		 * 
		 * @method init
		 * @param {String}
		 *            el The element ID representing the Dialog <em>OR</em>
		 * @param {HTMLElement}
		 *            el The element representing the Dialog
		 * @param {Object}
		 *            userConfig The configuration object literal containing the
		 *            configuration that should be set for this Dialog. See
		 *            configuration documentation for more details.
		 */
        init: function (el, userConfig) {

            /*
			 * Note that we don't pass the user config in here yet because we
			 * only want it executed once, at the lowest subclass level
			 */

            Dialog.superclass.init.call(this, el/* , userConfig */); 

            this.beforeInitEvent.fire(Dialog);

            Dom.addClass(this.element, Dialog.CSS_DIALOG);

            this.cfg.setProperty("visible", false);

            if (userConfig) {
                this.cfg.applyConfig(userConfig, true);
            }

            // this.showEvent.subscribe(this.focusFirst, this, true);
            this.beforeHideEvent.subscribe(this.blurButtons, this, true);

            this.subscribe("changeBody", this.registerForm);

            this.initEvent.fire(Dialog);
        },

        /**
		 * Submits the Dialog's form depending on the value of the "postmethod"
		 * configuration property. <strong>Please note: </strong> As of version
		 * 2.3 this method will automatically handle asyncronous file uploads
		 * should the Dialog instance's form contain
		 * <code>&#60;input type="file"&#62;</code> elements. If a Dialog
		 * instance will be handling asyncronous file uploads, its
		 * <code>callback</code> property will need to be setup with a
		 * <code>upload</code> handler rather than the standard
		 * <code>success</code> and, or <code>failure</code> handlers. For
		 * more information, see the <a href="http://developer.yahoo.com/yui/
		 * connection/#file">Connection Manager documenation on file uploads</a>.
		 * 
		 * @method doSubmit
		 */
        doSubmit: function () {

            var Connect = YAHOO.util.Connect,
                oForm = this.form,
                bUseFileUpload = false,
                bUseSecureFileUpload = false,
                aElements,
                nElements,
                i,
                formAttrs;

            switch (this.cfg.getProperty("postmethod")) {

                case "async":
                    aElements = oForm.elements;
                    nElements = aElements.length;

                    if (nElements > 0) {
                        i = nElements - 1;
                        do {
                            if (aElements[i].type == "file") {
                                bUseFileUpload = true;
                                break;
                            }
                        }
                        while(i--);
                    }

                    if (bUseFileUpload && YAHOO.env.ua.ie && this.isSecure) {
                        bUseSecureFileUpload = true;
                    }

                    formAttrs = this._getFormAttributes(oForm);

                    Connect.setForm(oForm, bUseFileUpload, bUseSecureFileUpload);

                    var postData = this.cfg.getProperty("postdata");
                    var c = Connect.asyncRequest(formAttrs.method, formAttrs.action, this.callback, postData);

                    this.asyncSubmitEvent.fire(c);

                    break;

                case "form":
                    oForm.submit();
                    this.formSubmitEvent.fire();
                    break;

                case "none":
                case "manual":
                    this.manualSubmitEvent.fire();
                    break;
            }
        },

        /**
		 * Retrieves important attributes (currently method and action) from the
		 * form element, accounting for any elements which may have the same
		 * name as the attributes. Defaults to "POST" and "" for method and
		 * action respectively if the attribute cannot be retrieved.
		 * 
		 * @method _getFormAttributes
		 * @protected
		 * @param {HTMLFormElement}
		 *            oForm The HTML Form element from which to retrieve the
		 *            attributes
		 * @return {Object} Object literal, with method and action String
		 *         properties.
		 */
        _getFormAttributes : function(oForm){
            var attrs = {
                method : null,
                action : null
            };

            if (oForm) {
                if (oForm.getAttributeNode) {
                    var action = oForm.getAttributeNode("action");
                    var method = oForm.getAttributeNode("method");

                    if (action) {
                        attrs.action = action.value;
                    }

                    if (method) {
                        attrs.method = method.value;
                    }

                } else {
                    attrs.action = oForm.getAttribute("action");
                    attrs.method = oForm.getAttribute("method");
                }
            }

            attrs.method = (Lang.isString(attrs.method) ? attrs.method : "POST").toUpperCase();
            attrs.action = Lang.isString(attrs.action) ? attrs.action : "";

            return attrs;
        },

        /**
		 * Prepares the Dialog's internal FORM object, creating one if one is
		 * not currently present.
		 * 
		 * @method registerForm
		 */
        registerForm: function() {

            var form = this.element.getElementsByTagName("form")[0];

            if (this.form) {
                if (this.form == form && Dom.isAncestor(this.element, this.form)) {
                    return;
                } else {
                    Event.purgeElement(this.form);
                    this.form = null;
                }
            }

            if (!form) {
                form = document.createElement("form");
                form.name = "frm_" + this.id;
                this.body.appendChild(form);
            }

            if (form) {
                this.form = form;
                Event.on(form, "submit", this._submitHandler, this, true);
            }
        },

        /**
		 * Internal handler for the form submit event
		 * 
		 * @method _submitHandler
		 * @protected
		 * @param {DOMEvent}
		 *            e The DOM Event object
		 */
        _submitHandler : function(e) {
            Event.stopEvent(e);
            this.submit();
            this.form.blur();
        },

        /**
		 * Sets up a tab, shift-tab loop between the first and last elements
		 * provided. NOTE: Sets up the preventBackTab and preventTabOut
		 * KeyListener instance properties, which are reset everytime this
		 * method is invoked.
		 * 
		 * @method setTabLoop
		 * @param {HTMLElement}
		 *            firstElement
		 * @param {HTMLElement}
		 *            lastElement
		 * 
		 */
        setTabLoop : function(firstElement, lastElement) {

            firstElement = firstElement || this.firstButton;
            lastElement = lastElement || this.lastButton;

            Dialog.superclass.setTabLoop.call(this, firstElement, lastElement);
        },

        /**
		 * Protected internal method for setTabLoop, which can be used by
		 * subclasses to jump in and modify the arguments passed in if required.
		 * 
		 * @method _setTabLoop
		 * @param {HTMLElement}
		 *            firstElement
		 * @param {HTMLElement}
		 *            lastElement
		 * @protected
		 */
        _setTabLoop : function(firstElement, lastElement) {
            firstElement = firstElement || this.firstButton;
            lastElement = this.lastButton || lastElement;

            this.setTabLoop(firstElement, lastElement);
        },

        /**
		 * Configures instance properties, pointing to the first and last
		 * focusable elements in the Dialog's form.
		 * 
		 * @method setFirstLastFocusable
		 */
        setFirstLastFocusable : function() {

            Dialog.superclass.setFirstLastFocusable.call(this);

            var i, l, el, elements = this.focusableElements;

            this.firstFormElement = null;
            this.lastFormElement = null;

            if (this.form && elements && elements.length > 0) {
                l = elements.length;

                for (i = 0; i < l; ++i) {
                    el = elements[i];
                    if (this.form === el.form) {
                        this.firstFormElement = el;
                        break;
                    }
                }

                for (i = l-1; i >= 0; --i) {
                    el = elements[i];
                    if (this.form === el.form) {
                        this.lastFormElement = el;
                        break;
                    }
                }
            }
        },

        // BEGIN BUILT-IN PROPERTY EVENT HANDLERS //
        /**
		 * The default event handler fired when the "close" property is changed.
		 * The method controls the appending or hiding of the close icon at the
		 * top right of the Dialog.
		 * 
		 * @method configClose
		 * @param {String}
		 *            type The CustomEvent type (usually the property name)
		 * @param {Object[]}
		 *            args The CustomEvent arguments. For configuration
		 *            handlers, args[0] will equal the newly applied value for
		 *            the property.
		 * @param {Object}
		 *            obj The scope object. For configuration handlers, this
		 *            will usually equal the owner.
		 */
        configClose: function (type, args, obj) {
            Dialog.superclass.configClose.apply(this, arguments);
        },

        /**
		 * Event handler for the close icon
		 * 
		 * @method _doClose
		 * @protected
		 * 
		 * @param {DOMEvent}
		 *            e
		 */
         _doClose : function(e) {
            Event.preventDefault(e);
            this.cancel();
        },

        /**
		 * The default event handler for the "buttons" configuration property
		 * 
		 * @method configButtons
		 * @param {String}
		 *            type The CustomEvent type (usually the property name)
		 * @param {Object[]}
		 *            args The CustomEvent arguments. For configuration
		 *            handlers, args[0] will equal the newly applied value for
		 *            the property.
		 * @param {Object}
		 *            obj The scope object. For configuration handlers, this
		 *            will usually equal the owner.
		 */
        configButtons: function (type, args, obj) {

            var Button = YAHOO.widget.Button,
                aButtons = args[0],
                oInnerElement = this.innerElement,
                oButton,
                oButtonEl,
                oYUIButton,
                nButtons,
                oSpan,
                oFooter,
                i;

            removeButtonEventHandlers.call(this);

            this._aButtons = null;

            if (Lang.isArray(aButtons)) {

                oSpan = document.createElement("span");
                oSpan.className = "button-group";
                nButtons = aButtons.length;

                this._aButtons = [];
                this.defaultHtmlButton = null;

                for (i = 0; i < nButtons; i++) {
                    oButton = aButtons[i];

                    if (Button) {
                        oYUIButton = new Button({ label: oButton.text, type:oButton.type });
                        oYUIButton.appendTo(oSpan);

                        oButtonEl = oYUIButton.get("element");

                        if (oButton.isDefault) {
                            oYUIButton.addClass("default");
                            this.defaultHtmlButton = oButtonEl;
                        }

                        if (Lang.isFunction(oButton.handler)) {

                            oYUIButton.set("onclick", { 
                                fn: oButton.handler, 
                                obj: this, 
                                scope: this 
                            });

                        } else if (Lang.isObject(oButton.handler) && Lang.isFunction(oButton.handler.fn)) {

                            oYUIButton.set("onclick", { 
                                fn: oButton.handler.fn, 
                                obj: ((!Lang.isUndefined(oButton.handler.obj)) ? oButton.handler.obj : this), 
                                scope: (oButton.handler.scope || this) 
                            });

                        }

                        this._aButtons[this._aButtons.length] = oYUIButton;

                    } else {

                        oButtonEl = document.createElement("button");
                        oButtonEl.setAttribute("type", "button");

                        if (oButton.isDefault) {
                            oButtonEl.className = "default";
                            this.defaultHtmlButton = oButtonEl;
                        }

                        oButtonEl.innerHTML = oButton.text;

                        if (Lang.isFunction(oButton.handler)) {
                            Event.on(oButtonEl, "click", oButton.handler, this, true);
                        } else if (Lang.isObject(oButton.handler) && 
                            Lang.isFunction(oButton.handler.fn)) {
    
                            Event.on(oButtonEl, "click", 
                                oButton.handler.fn, 
                                ((!Lang.isUndefined(oButton.handler.obj)) ? oButton.handler.obj : this), 
                                (oButton.handler.scope || this));
                        }

                        oSpan.appendChild(oButtonEl);
                        this._aButtons[this._aButtons.length] = oButtonEl;
                    }

                    oButton.htmlButton = oButtonEl;

                    if (i === 0) {
                        this.firstButton = oButtonEl;
                    }

                    if (i == (nButtons - 1)) {
                        this.lastButton = oButtonEl;
                    }
                }

                this.setFooter(oSpan);

                oFooter = this.footer;

                if (Dom.inDocument(this.element) && !Dom.isAncestor(oInnerElement, oFooter)) {
                    oInnerElement.appendChild(oFooter);
                }

                this.buttonSpan = oSpan;

            } else { // Do cleanup
                oSpan = this.buttonSpan;
                oFooter = this.footer;
                if (oSpan && oFooter) {
                    oFooter.removeChild(oSpan);
                    this.buttonSpan = null;
                    this.firstButton = null;
                    this.lastButton = null;
                    this.defaultHtmlButton = null;
                }
            }

            this.changeContentEvent.fire();
        },

        /**
		 * @method getButtons
		 * @description Returns an array containing each of the Dialog's
		 *              buttons, by default an array of HTML
		 *              <code>&#60;BUTTON&#62;</code> elements. If the
		 *              Dialog's buttons were created using the
		 *              YAHOO.widget.Button class (via the inclusion of the
		 *              optional Button dependency on the page), an array of
		 *              YAHOO.widget.Button instances is returned.
		 * @return {Array}
		 */
        getButtons: function () {
            return this._aButtons || null;
        },

        /**
		 * <p>
		 * Sets focus to the first focusable element in the Dialog's form if
		 * found, else, the default button if found, else the first button
		 * defined via the "buttons" configuration property.
		 * </p>
		 * <p>
		 * This method is invoked when the Dialog is made visible.
		 * </p>
		 * 
		 * @method focusFirst
		 * @return {Boolean} true, if focused. false if not
		 */
        focusFirst: function (type, args, obj) {

            var el = this.firstFormElement, 
                focused = false;

            if (args && args[1]) {
                Event.stopEvent(args[1]);

                // When tabbing here, use firstElement instead of
				// firstFormElement
                if (args[0] === 9 && this.firstElement) {
                    el = this.firstElement;
                }
            }

            if (el) {
                try {
                    el.focus();
                    focused = true;
                } catch(oException) {
                    // Ignore
                }
            } else {
                if (this.defaultHtmlButton) {
                    focused = this.focusDefaultButton();
                } else {
                    focused = this.focusFirstButton();
                }
            }
            return focused;
        },

        /**
		 * Sets focus to the last element in the Dialog's form or the last
		 * button defined via the "buttons" configuration property.
		 * 
		 * @method focusLast
		 * @return {Boolean} true, if focused. false if not
		 */
        focusLast: function (type, args, obj) {

            var aButtons = this.cfg.getProperty("buttons"),
                el = this.lastFormElement,
                focused = false;

            if (args && args[1]) {
                Event.stopEvent(args[1]);

                // When tabbing here, use lastElement instead of lastFormElement
                if (args[0] === 9 && this.lastElement) {
                    el = this.lastElement;
                }
            }

            if (aButtons && Lang.isArray(aButtons)) {
                focused = this.focusLastButton();
            } else {
                if (el) {
                    try {
                        el.focus();
                        focused = true;
                    } catch(oException) {
                        // Ignore
                    }
                }
            }

            return focused;
        },

        /**
		 * Helper method to normalize button references. It either returns the
		 * YUI Button instance for the given element if found, or the passes
		 * back the HTMLElement reference if a corresponding YUI Button
		 * reference is not found or YAHOO.widget.Button does not exist on the
		 * page.
		 * 
		 * @method _getButton
		 * @private
		 * @param {HTMLElement}
		 *            button
		 * @return {YAHOO.widget.Button|HTMLElement}
		 */
        _getButton : function(button) {
            var Button = YAHOO.widget.Button;

            // If we have an HTML button and YUI Button is on the page,
            // get the YUI Button reference if available.
            if (Button && button && button.nodeName && button.id) {
                button = Button.getButton(button.id) || button;
            }

            return button;
        },

        /**
		 * Sets the focus to the button that is designated as the default via
		 * the "buttons" configuration property. By default, this method is
		 * called when the Dialog is made visible.
		 * 
		 * @method focusDefaultButton
		 * @return {Boolean} true if focused, false if not
		 */
        focusDefaultButton: function () {
            var button = this._getButton(this.defaultHtmlButton), 
                         focused = false;
            
            if (button) {
                /*
				 * Place the call to the "focus" method inside a try/catch block
				 * to prevent IE from throwing JavaScript errors if the element
				 * is disabled or hidden.
				 */
                try {
                    button.focus();
                    focused = true;
                } catch(oException) {
                }
            }
            return focused;
        },

        /**
		 * Blurs all the buttons defined via the "buttons" configuration
		 * property.
		 * 
		 * @method blurButtons
		 */
        blurButtons: function () {
            
            var aButtons = this.cfg.getProperty("buttons"),
                nButtons,
                oButton,
                oElement,
                i;

            if (aButtons && Lang.isArray(aButtons)) {
                nButtons = aButtons.length;
                if (nButtons > 0) {
                    i = (nButtons - 1);
                    do {
                        oButton = aButtons[i];
                        if (oButton) {
                            oElement = this._getButton(oButton.htmlButton);
                            if (oElement) {
                                /*
								 * Place the call to the "blur" method inside a
								 * try/catch block to prevent IE from throwing
								 * JavaScript errors if the element is disabled
								 * or hidden.
								 */
                                try {
                                    oElement.blur();
                                } catch(oException) {
                                    // ignore
                                }
                            }
                        }
                    } while(i--);
                }
            }
        },

        /**
		 * Sets the focus to the first button created via the "buttons"
		 * configuration property.
		 * 
		 * @method focusFirstButton
		 * @return {Boolean} true, if focused. false if not
		 */
        focusFirstButton: function () {

            var aButtons = this.cfg.getProperty("buttons"),
                oButton,
                oElement,
                focused = false;

            if (aButtons && Lang.isArray(aButtons)) {
                oButton = aButtons[0];
                if (oButton) {
                    oElement = this._getButton(oButton.htmlButton);
                    if (oElement) {
                        /*
						 * Place the call to the "focus" method inside a
						 * try/catch block to prevent IE from throwing
						 * JavaScript errors if the element is disabled or
						 * hidden.
						 */
                        try {
                            oElement.focus();
                            focused = true;
                        } catch(oException) {
                            // ignore
                        }
                    }
                }
            }

            return focused;
        },

        /**
		 * Sets the focus to the last button created via the "buttons"
		 * configuration property.
		 * 
		 * @method focusLastButton
		 * @return {Boolean} true, if focused. false if not
		 */
        focusLastButton: function () {

            var aButtons = this.cfg.getProperty("buttons"),
                nButtons,
                oButton,
                oElement, 
                focused = false;

            if (aButtons && Lang.isArray(aButtons)) {
                nButtons = aButtons.length;
                if (nButtons > 0) {
                    oButton = aButtons[(nButtons - 1)];

                    if (oButton) {
                        oElement = this._getButton(oButton.htmlButton);
                        if (oElement) {
                            /*
							 * Place the call to the "focus" method inside a
							 * try/catch block to prevent IE from throwing
							 * JavaScript errors if the element is disabled or
							 * hidden.
							 */
        
                            try {
                                oElement.focus();
                                focused = true;
                            } catch(oException) {
                                // Ignore
                            }
                        }
                    }
                }
            }

            return focused;
        },

        /**
		 * The default event handler for the "postmethod" configuration property
		 * 
		 * @method configPostMethod
		 * @param {String}
		 *            type The CustomEvent type (usually the property name)
		 * @param {Object[]}
		 *            args The CustomEvent arguments. For configuration
		 *            handlers, args[0] will equal the newly applied value for
		 *            the property.
		 * @param {Object}
		 *            obj The scope object. For configuration handlers, this
		 *            will usually equal the owner.
		 */
        configPostMethod: function (type, args, obj) {
            this.registerForm();
        },

        // END BUILT-IN PROPERTY EVENT HANDLERS //
        
        /**
		 * Built-in function hook for writing a validation function that will be
		 * checked for a "true" value prior to a submit. This function, as
		 * implemented by default, always returns true, so it should be
		 * overridden if validation is necessary.
		 * 
		 * @method validate
		 */
        validate: function () {
            return true;
        },

        /**
		 * Executes a submit of the Dialog if validation is successful. By
		 * default the Dialog is hidden after submission, but you can set the
		 * "hideaftersubmit" configuration property to false, to prevent the
		 * Dialog from being hidden.
		 * 
		 * @method submit
		 */
        submit: function () {
            if (this.validate()) {
                if (this.beforeSubmitEvent.fire()) {
                    this.doSubmit();
                    this.submitEvent.fire();
    
                    if (this.cfg.getProperty("hideaftersubmit")) {
                        this.hide();
                    }
    
                    return true;
                } else {
                    return false;
                }
            } else {
                return false;
            }
        },

        /**
		 * Executes the cancel of the Dialog followed by a hide.
		 * 
		 * @method cancel
		 */
        cancel: function () {
            this.cancelEvent.fire();
            this.hide();
        },
        
        /**
		 * Returns a JSON-compatible data structure representing the data
		 * currently contained in the form.
		 * 
		 * @method getData
		 * @return {Object} A JSON object reprsenting the data of the current
		 *         form.
		 */
        getData: function () {

            var oForm = this.form,
                aElements,
                nTotalElements,
                oData,
                sName,
                oElement,
                nElements,
                sType,
                sTagName,
                aOptions,
                nOptions,
                aValues,
                oOption,
                oRadio,
                oCheckbox,
                valueAttr,
                i,
                n;    
    
            function isFormElement(p_oElement) {
                var sTag = p_oElement.tagName.toUpperCase();
                return ((sTag == "INPUT" || sTag == "TEXTAREA" || 
                        sTag == "SELECT") && p_oElement.name == sName);
            }

            if (oForm) {

                aElements = oForm.elements;
                nTotalElements = aElements.length;
                oData = {};

                for (i = 0; i < nTotalElements; i++) {
                    sName = aElements[i].name;

                    /*
					 * Using "Dom.getElementsBy" to safeguard user from JS
					 * errors that result from giving a form field (or set of
					 * fields) the same name as a native method of a form (like
					 * "submit") or a DOM collection (such as the "item"
					 * method). Originally tried accessing fields via the
					 * "namedItem" method of the "element" collection, but
					 * discovered that it won't return a collection of fields in
					 * Gecko.
					 */

                    oElement = Dom.getElementsBy(isFormElement, "*", oForm);
                    nElements = oElement.length;

                    if (nElements > 0) {
                        if (nElements == 1) {
                            oElement = oElement[0];

                            sType = oElement.type;
                            sTagName = oElement.tagName.toUpperCase();

                            switch (sTagName) {
                                case "INPUT":
                                    if (sType == "checkbox") {
                                        oData[sName] = oElement.checked;
                                    } else if (sType != "radio") {
                                        oData[sName] = oElement.value;
                                    }
                                    break;

                                case "TEXTAREA":
                                    oData[sName] = oElement.value;
                                    break;
    
                                case "SELECT":
                                    aOptions = oElement.options;
                                    nOptions = aOptions.length;
                                    aValues = [];
    
                                    for (n = 0; n < nOptions; n++) {
                                        oOption = aOptions[n];
                                        if (oOption.selected) {
                                            valueAttr = oOption.attributes.value;
                                            aValues[aValues.length] = (valueAttr && valueAttr.specified) ? oOption.value : oOption.text;
                                        }
                                    }
                                    oData[sName] = aValues;
                                    break;
                            }
        
                        } else {
                            sType = oElement[0].type;
                            switch (sType) {
                                case "radio":
                                    for (n = 0; n < nElements; n++) {
                                        oRadio = oElement[n];
                                        if (oRadio.checked) {
                                            oData[sName] = oRadio.value;
                                            break;
                                        }
                                    }
                                    break;
        
                                case "checkbox":
                                    aValues = [];
                                    for (n = 0; n < nElements; n++) {
                                        oCheckbox = oElement[n];
                                        if (oCheckbox.checked) {
                                            aValues[aValues.length] =  oCheckbox.value;
                                        }
                                    }
                                    oData[sName] = aValues;
                                    break;
                            }
                        }
                    }
                }
            }

            return oData;
        },

        /**
		 * Removes the Panel element from the DOM and sets all child elements to
		 * null.
		 * 
		 * @method destroy
		 * @param {boolean}
		 *            shallowPurge If true, only the parent element's DOM event
		 *            listeners are purged. If false, or not provided, all
		 *            children are also purged of DOM event listeners. NOTE: The
		 *            flag is a "shallowPurge" flag, as opposed to what may be a
		 *            more intuitive "purgeChildren" flag to maintain backwards
		 *            compatibility with behavior prior to 2.9.0.
		 */
        destroy: function (shallowPurge) {
            removeButtonEventHandlers.call(this);

            this._aButtons = null;

            var aForms = this.element.getElementsByTagName("form"),
                oForm;

            if (aForms.length > 0) {
                oForm = aForms[0];

                if (oForm) {
                    Event.purgeElement(oForm);
                    if (oForm.parentNode) {
                        oForm.parentNode.removeChild(oForm);
                    }
                    this.form = null;
                }
            }
            Dialog.superclass.destroy.call(this, shallowPurge);
        },

        /**
		 * Returns a string representation of the object.
		 * 
		 * @method toString
		 * @return {String} The string representation of the Dialog
		 */
        toString: function () {
            return "Dialog " + this.id;
        }
    
    });

}());
(function () {

    /**
	 * SimpleDialog is a simple implementation of Dialog that can be used to
	 * submit a single value. Forms can be processed in 3 ways -- via an
	 * asynchronous Connection utility call, a simple form POST or GET, or
	 * manually.
	 * 
	 * @namespace YAHOO.widget
	 * @class SimpleDialog
	 * @extends YAHOO.widget.Dialog
	 * @constructor
	 * @param {String}
	 *            el The element ID representing the SimpleDialog <em>OR</em>
	 * @param {HTMLElement}
	 *            el The element representing the SimpleDialog
	 * @param {Object}
	 *            userConfig The configuration object literal containing the
	 *            configuration that should be set for this SimpleDialog. See
	 *            configuration documentation for more details.
	 */
    YAHOO.widget.SimpleDialog = function (el, userConfig) {
    
        YAHOO.widget.SimpleDialog.superclass.constructor.call(this, 
            el, userConfig);
    
    };

    var Dom = YAHOO.util.Dom,
        SimpleDialog = YAHOO.widget.SimpleDialog,
    
        /**
		 * Constant representing the SimpleDialog's configuration properties
		 * 
		 * @property DEFAULT_CONFIG
		 * @private
		 * @final
		 * @type Object
		 */
        DEFAULT_CONFIG = {
        
            "ICON": { 
                key: "icon", 
                value: "none", 
                suppressEvent: true  
            },
        
            "TEXT": { 
                key: "text", 
                value: "", 
                suppressEvent: true, 
                supercedes: ["icon"] 
            }
        
        };

    /**
	 * Constant for the standard network icon for a blocking action
	 * 
	 * @property YAHOO.widget.SimpleDialog.ICON_BLOCK
	 * @static
	 * @final
	 * @type String
	 */
    SimpleDialog.ICON_BLOCK = "blckicon";
    
    /**
	 * Constant for the standard network icon for alarm
	 * 
	 * @property YAHOO.widget.SimpleDialog.ICON_ALARM
	 * @static
	 * @final
	 * @type String
	 */
    SimpleDialog.ICON_ALARM = "alrticon";
    
    /**
	 * Constant for the standard network icon for help
	 * 
	 * @property YAHOO.widget.SimpleDialog.ICON_HELP
	 * @static
	 * @final
	 * @type String
	 */
    SimpleDialog.ICON_HELP  = "hlpicon";
    
    /**
	 * Constant for the standard network icon for info
	 * 
	 * @property YAHOO.widget.SimpleDialog.ICON_INFO
	 * @static
	 * @final
	 * @type String
	 */
    SimpleDialog.ICON_INFO  = "infoicon";
    
    /**
	 * Constant for the standard network icon for warn
	 * 
	 * @property YAHOO.widget.SimpleDialog.ICON_WARN
	 * @static
	 * @final
	 * @type String
	 */
    SimpleDialog.ICON_WARN  = "warnicon";
    
    /**
	 * Constant for the standard network icon for a tip
	 * 
	 * @property YAHOO.widget.SimpleDialog.ICON_TIP
	 * @static
	 * @final
	 * @type String
	 */
    SimpleDialog.ICON_TIP   = "tipicon";

    /**
	 * Constant representing the name of the CSS class applied to the element
	 * created by the "icon" configuration property.
	 * 
	 * @property YAHOO.widget.SimpleDialog.ICON_CSS_CLASSNAME
	 * @static
	 * @final
	 * @type String
	 */
    SimpleDialog.ICON_CSS_CLASSNAME = "yui-icon";
    
    /**
	 * Constant representing the default CSS class used for a SimpleDialog
	 * 
	 * @property YAHOO.widget.SimpleDialog.CSS_SIMPLEDIALOG
	 * @static
	 * @final
	 * @type String
	 */
    SimpleDialog.CSS_SIMPLEDIALOG = "yui-simple-dialog";

    
    YAHOO.extend(SimpleDialog, YAHOO.widget.Dialog, {
    
        /**
		 * Initializes the class's configurable properties which can be changed
		 * using the SimpleDialog's Config object (cfg).
		 * 
		 * @method initDefaultConfig
		 */
        initDefaultConfig: function () {
        
            SimpleDialog.superclass.initDefaultConfig.call(this);
        
            // Add dialog config properties //
        
            /**
			 * Sets the informational icon for the SimpleDialog
			 * 
			 * @config icon
			 * @type String
			 * @default "none"
			 */
            this.cfg.addProperty(DEFAULT_CONFIG.ICON.key, {
                handler: this.configIcon,
                value: DEFAULT_CONFIG.ICON.value,
                suppressEvent: DEFAULT_CONFIG.ICON.suppressEvent
            });
        
            /**
			 * Sets the text for the SimpleDialog. The text is inserted into the
			 * DOM as HTML, and should be escaped by the implementor if coming
			 * from an external source.
			 * 
			 * @config text
			 * @type HTML
			 * @default ""
			 */
            this.cfg.addProperty(DEFAULT_CONFIG.TEXT.key, { 
                handler: this.configText, 
                value: DEFAULT_CONFIG.TEXT.value, 
                suppressEvent: DEFAULT_CONFIG.TEXT.suppressEvent, 
                supercedes: DEFAULT_CONFIG.TEXT.supercedes 
            });
        
        },
        
        
        /**
		 * The SimpleDialog initialization method, which is executed for
		 * SimpleDialog and all of its subclasses. This method is automatically
		 * called by the constructor, and sets up all DOM references for
		 * pre-existing markup, and creates required markup if it is not already
		 * present.
		 * 
		 * @method init
		 * @param {String}
		 *            el The element ID representing the SimpleDialog
		 *            <em>OR</em>
		 * @param {HTMLElement}
		 *            el The element representing the SimpleDialog
		 * @param {Object}
		 *            userConfig The configuration object literal containing the
		 *            configuration that should be set for this SimpleDialog.
		 *            See configuration documentation for more details.
		 */
        init: function (el, userConfig) {

            /*
			 * Note that we don't pass the user config in here yet because we
			 * only want it executed once, at the lowest subclass level
			 */

            SimpleDialog.superclass.init.call(this, el/* , userConfig */);
        
            this.beforeInitEvent.fire(SimpleDialog);
        
            Dom.addClass(this.element, SimpleDialog.CSS_SIMPLEDIALOG);
        
            this.cfg.queueProperty("postmethod", "manual");
        
            if (userConfig) {
                this.cfg.applyConfig(userConfig, true);
            }
        
            this.beforeRenderEvent.subscribe(function () {
                if (! this.body) {
                    this.setBody("");
                }
            }, this, true);
        
            this.initEvent.fire(SimpleDialog);
        
        },
        
        /**
		 * Prepares the SimpleDialog's internal FORM object, creating one if one
		 * is not currently present, and adding the value hidden field.
		 * 
		 * @method registerForm
		 */
        registerForm: function () {
            SimpleDialog.superclass.registerForm.call(this);

            var doc = this.form.ownerDocument,
                input = doc.createElement("input");

            input.type = "hidden";
            input.name = this.id;
            input.value = "";

            this.form.appendChild(input);
        },

        // BEGIN BUILT-IN PROPERTY EVENT HANDLERS //
        
        /**
		 * Fired when the "icon" property is set.
		 * 
		 * @method configIcon
		 * @param {String}
		 *            type The CustomEvent type (usually the property name)
		 * @param {Object[]}
		 *            args The CustomEvent arguments. For configuration
		 *            handlers, args[0] will equal the newly applied value for
		 *            the property.
		 * @param {Object}
		 *            obj The scope object. For configuration handlers, this
		 *            will usually equal the owner.
		 */
        configIcon: function (type,args,obj) {
        
            var sIcon = args[0],
                oBody = this.body,
                sCSSClass = SimpleDialog.ICON_CSS_CLASSNAME,
				aElements,
                oIcon,
                oIconParent;
        
            if (sIcon && sIcon != "none") {

                aElements = Dom.getElementsByClassName(sCSSClass, "*" , oBody);

				if (aElements.length === 1) {

					oIcon = aElements[0];
                    oIconParent = oIcon.parentNode;

                    if (oIconParent) {

                        oIconParent.removeChild(oIcon);

                        oIcon = null;

                    }

				}


                if (sIcon.indexOf(".") == -1) {

                    oIcon = document.createElement("span");
                    oIcon.className = (sCSSClass + " " + sIcon);
                    oIcon.innerHTML = "&#160;";

                } else {

                    oIcon = document.createElement("img");
                    oIcon.src = (this.imageRoot + sIcon);
                    oIcon.className = sCSSClass;

                }
                

                if (oIcon) {
                
                    oBody.insertBefore(oIcon, oBody.firstChild);
                
                }

            }

        },

        /**
		 * Fired when the "text" property is set.
		 * 
		 * @method configText
		 * @param {String}
		 *            type The CustomEvent type (usually the property name)
		 * @param {Object[]}
		 *            args The CustomEvent arguments. For configuration
		 *            handlers, args[0] will equal the newly applied value for
		 *            the property.
		 * @param {Object}
		 *            obj The scope object. For configuration handlers, this
		 *            will usually equal the owner.
		 */
        configText: function (type,args,obj) {
            var text = args[0];
            if (text) {
                this.setBody(text);
                this.cfg.refireEvent("icon");
            }
        },
        
        // END BUILT-IN PROPERTY EVENT HANDLERS //
        
        /**
		 * Returns a string representation of the object.
		 * 
		 * @method toString
		 * @return {String} The string representation of the SimpleDialog
		 */
        toString: function () {
            return "SimpleDialog " + this.id;
        }

        /**
		 * <p>
		 * Sets the SimpleDialog's body content to the HTML specified. If no
		 * body is present, one will be automatically created. An empty string
		 * can be passed to the method to clear the contents of the body.
		 * </p>
		 * <p>
		 * <strong>NOTE:</strong> SimpleDialog provides the <a
		 * href="#config_text">text</a> and <a href="#config_icon">icon</a>
		 * configuration properties to set the contents of it's body element in
		 * accordance with the UI design for a SimpleDialog (an icon and message
		 * text). Calling setBody on the SimpleDialog will not enforce this UI
		 * design constraint and will replace the entire contents of the
		 * SimpleDialog body. It should only be used if you wish the replace the
		 * default icon/text body structure of a SimpleDialog with your own
		 * custom markup.
		 * </p>
		 * 
		 * @method setBody
		 * @param {HTML}
		 *            bodyContent The HTML used to set the body. As a
		 *            convenience, non HTMLElement objects can also be passed
		 *            into the method, and will be treated as strings, with the
		 *            body innerHTML set to their default toString
		 *            implementations.
		 * 
		 * <p>
		 * NOTE: Markup passed into this method is added to the DOM as HTML, and
		 * should be escaped by the implementor if coming from an external
		 * source.
		 * </p>
		 * 
		 * <em>OR</em>
		 * @param {HTMLElement}
		 *            bodyContent The HTMLElement to add as the first and only
		 *            child of the body element. <em>OR</em>
		 * @param {DocumentFragment}
		 *            bodyContent The document fragment containing elements
		 *            which are to be added to the body
		 */
    });

}());
(function () {

    /**
	 * ContainerEffect encapsulates animation transitions that are executed when
	 * an Overlay is shown or hidden.
	 * 
	 * @namespace YAHOO.widget
	 * @class ContainerEffect
	 * @constructor
	 * @param {YAHOO.widget.Overlay}
	 *            overlay The Overlay that the animation should be associated
	 *            with
	 * @param {Object}
	 *            attrIn The object literal representing the animation arguments
	 *            to be used for the animate-in transition. The arguments for
	 *            this literal are: attributes(object, see YAHOO.util.Anim for
	 *            description), duration(Number), and method(i.e.
	 *            Easing.easeIn).
	 * @param {Object}
	 *            attrOut The object literal representing the animation
	 *            arguments to be used for the animate-out transition. The
	 *            arguments for this literal are: attributes(object, see
	 *            YAHOO.util.Anim for description), duration(Number), and
	 *            method(i.e. Easing.easeIn).
	 * @param {HTMLElement}
	 *            targetElement Optional. The target element that should be
	 *            animated during the transition. Defaults to overlay.element.
	 * @param {class}
	 *            Optional. The animation class to instantiate. Defaults to
	 *            YAHOO.util.Anim. Other options include YAHOO.util.Motion.
	 */
    YAHOO.widget.ContainerEffect = function (overlay, attrIn, attrOut, targetElement, animClass) {

        if (!animClass) {
            animClass = YAHOO.util.Anim;
        }

        /**
		 * The overlay to animate
		 * 
		 * @property overlay
		 * @type YAHOO.widget.Overlay
		 */
        this.overlay = overlay;
    
        /**
		 * The animation attributes to use when transitioning into view
		 * 
		 * @property attrIn
		 * @type Object
		 */
        this.attrIn = attrIn;
    
        /**
		 * The animation attributes to use when transitioning out of view
		 * 
		 * @property attrOut
		 * @type Object
		 */
        this.attrOut = attrOut;
    
        /**
		 * The target element to be animated
		 * 
		 * @property targetElement
		 * @type HTMLElement
		 */
        this.targetElement = targetElement || overlay.element;
    
        /**
		 * The animation class to use for animating the overlay
		 * 
		 * @property animClass
		 * @type class
		 */
        this.animClass = animClass;
    };

    var Dom = YAHOO.util.Dom,
        CustomEvent = YAHOO.util.CustomEvent,
        ContainerEffect = YAHOO.widget.ContainerEffect;

    /**
	 * A pre-configured ContainerEffect instance that can be used for fading an
	 * overlay in and out.
	 * 
	 * @method FADE
	 * @static
	 * @param {YAHOO.widget.Overlay}
	 *            overlay The Overlay object to animate
	 * @param {Number}
	 *            dur The duration of the animation
	 * @return {YAHOO.widget.ContainerEffect} The configured ContainerEffect
	 *         object
	 */
    ContainerEffect.FADE = function (overlay, dur) {

        var Easing = YAHOO.util.Easing,
            fin = {
                attributes: {opacity:{from:0, to:1}},
                duration: dur,
                method: Easing.easeIn
            },
            fout = {
                attributes: {opacity:{to:0}},
                duration: dur,
                method: Easing.easeOut
            },
            fade = new ContainerEffect(overlay, fin, fout, overlay.element);

        fade.handleUnderlayStart = function() {
            var underlay = this.overlay.underlay;
            if (underlay && YAHOO.env.ua.ie) {
                var hasFilters = (underlay.filters && underlay.filters.length > 0);
                if(hasFilters) {
                    Dom.addClass(overlay.element, "yui-effect-fade");
                }
            }
        };

        fade.handleUnderlayComplete = function() {
            var underlay = this.overlay.underlay;
            if (underlay && YAHOO.env.ua.ie) {
                Dom.removeClass(overlay.element, "yui-effect-fade");
            }
        };

        fade.handleStartAnimateIn = function (type, args, obj) {
            obj.overlay._fadingIn = true;

            Dom.addClass(obj.overlay.element, "hide-select");

            if (!obj.overlay.underlay) {
                obj.overlay.cfg.refireEvent("underlay");
            }

            obj.handleUnderlayStart();

            obj.overlay._setDomVisibility(true);
            Dom.setStyle(obj.overlay.element, "opacity", 0);
        };

        fade.handleCompleteAnimateIn = function (type,args,obj) {
            obj.overlay._fadingIn = false;
            
            Dom.removeClass(obj.overlay.element, "hide-select");

            if (obj.overlay.element.style.filter) {
                obj.overlay.element.style.filter = null;
            }

            obj.handleUnderlayComplete();

            obj.overlay.cfg.refireEvent("iframe");
            obj.animateInCompleteEvent.fire();
        };

        fade.handleStartAnimateOut = function (type, args, obj) {
            obj.overlay._fadingOut = true;
            Dom.addClass(obj.overlay.element, "hide-select");
            obj.handleUnderlayStart();
        };

        fade.handleCompleteAnimateOut =  function (type, args, obj) {
            obj.overlay._fadingOut = false;
            Dom.removeClass(obj.overlay.element, "hide-select");

            if (obj.overlay.element.style.filter) {
                obj.overlay.element.style.filter = null;
            }
            obj.overlay._setDomVisibility(false);
            Dom.setStyle(obj.overlay.element, "opacity", 1);

            obj.handleUnderlayComplete();

            obj.overlay.cfg.refireEvent("iframe");
            obj.animateOutCompleteEvent.fire();
        };

        fade.init();
        return fade;
    };
    
    
    /**
	 * A pre-configured ContainerEffect instance that can be used for sliding an
	 * overlay in and out.
	 * 
	 * @method SLIDE
	 * @static
	 * @param {YAHOO.widget.Overlay}
	 *            overlay The Overlay object to animate
	 * @param {Number}
	 *            dur The duration of the animation
	 * @return {YAHOO.widget.ContainerEffect} The configured ContainerEffect
	 *         object
	 */
    ContainerEffect.SLIDE = function (overlay, dur) {
        var Easing = YAHOO.util.Easing,

            x = overlay.cfg.getProperty("x") || Dom.getX(overlay.element),
            y = overlay.cfg.getProperty("y") || Dom.getY(overlay.element),
            clientWidth = Dom.getClientWidth(),
            offsetWidth = overlay.element.offsetWidth,

            sin =  { 
                attributes: { points: { to: [x, y] } },
                duration: dur,
                method: Easing.easeIn 
            },

            sout = {
                attributes: { points: { to: [(clientWidth + 25), y] } },
                duration: dur,
                method: Easing.easeOut 
            },

            slide = new ContainerEffect(overlay, sin, sout, overlay.element, YAHOO.util.Motion);

        slide.handleStartAnimateIn = function (type,args,obj) {
            obj.overlay.element.style.left = ((-25) - offsetWidth) + "px";
            obj.overlay.element.style.top  = y + "px";
        };

        slide.handleTweenAnimateIn = function (type, args, obj) {
        
            var pos = Dom.getXY(obj.overlay.element),
                currentX = pos[0],
                currentY = pos[1];
        
            if (Dom.getStyle(obj.overlay.element, "visibility") == 
                "hidden" && currentX < x) {

                obj.overlay._setDomVisibility(true);

            }
        
            obj.overlay.cfg.setProperty("xy", [currentX, currentY], true);
            obj.overlay.cfg.refireEvent("iframe");
        };
        
        slide.handleCompleteAnimateIn = function (type, args, obj) {
            obj.overlay.cfg.setProperty("xy", [x, y], true);
            obj.startX = x;
            obj.startY = y;
            obj.overlay.cfg.refireEvent("iframe");
            obj.animateInCompleteEvent.fire();
        };

        slide.handleStartAnimateOut = function (type, args, obj) {
    
            var vw = Dom.getViewportWidth(),
                pos = Dom.getXY(obj.overlay.element),
                yso = pos[1];
    
            obj.animOut.attributes.points.to = [(vw + 25), yso];
        };
        
        slide.handleTweenAnimateOut = function (type, args, obj) {
    
            var pos = Dom.getXY(obj.overlay.element),
                xto = pos[0],
                yto = pos[1];
        
            obj.overlay.cfg.setProperty("xy", [xto, yto], true);
            obj.overlay.cfg.refireEvent("iframe");
        };
        
        slide.handleCompleteAnimateOut = function (type, args, obj) {
            obj.overlay._setDomVisibility(false);

            obj.overlay.cfg.setProperty("xy", [x, y]);
            obj.animateOutCompleteEvent.fire();
        };

        slide.init();
        return slide;
    };

    ContainerEffect.prototype = {

        /**
		 * Initializes the animation classes and events.
		 * 
		 * @method init
		 */
        init: function () {

            this.beforeAnimateInEvent = this.createEvent("beforeAnimateIn");
            this.beforeAnimateInEvent.signature = CustomEvent.LIST;
            
            this.beforeAnimateOutEvent = this.createEvent("beforeAnimateOut");
            this.beforeAnimateOutEvent.signature = CustomEvent.LIST;
        
            this.animateInCompleteEvent = this.createEvent("animateInComplete");
            this.animateInCompleteEvent.signature = CustomEvent.LIST;
        
            this.animateOutCompleteEvent = this.createEvent("animateOutComplete");
            this.animateOutCompleteEvent.signature = CustomEvent.LIST;

            this.animIn = new this.animClass(
                this.targetElement, 
                this.attrIn.attributes, 
                this.attrIn.duration, 
                this.attrIn.method);

            this.animIn.onStart.subscribe(this.handleStartAnimateIn, this);
            this.animIn.onTween.subscribe(this.handleTweenAnimateIn, this);
            this.animIn.onComplete.subscribe(this.handleCompleteAnimateIn,this);
        
            this.animOut = new this.animClass(
                this.targetElement, 
                this.attrOut.attributes, 
                this.attrOut.duration, 
                this.attrOut.method);

            this.animOut.onStart.subscribe(this.handleStartAnimateOut, this);
            this.animOut.onTween.subscribe(this.handleTweenAnimateOut, this);
            this.animOut.onComplete.subscribe(this.handleCompleteAnimateOut, this);

        },

        /**
		 * Triggers the in-animation.
		 * 
		 * @method animateIn
		 */
        animateIn: function () {
            this._stopAnims(this.lastFrameOnStop);
            this.beforeAnimateInEvent.fire();
            this.animIn.animate();
        },

        /**
		 * Triggers the out-animation.
		 * 
		 * @method animateOut
		 */
        animateOut: function () {
            this._stopAnims(this.lastFrameOnStop);
            this.beforeAnimateOutEvent.fire();
            this.animOut.animate();
        },
        
        /**
		 * Flag to define whether Anim should jump to the last frame, when
		 * animateIn or animateOut is stopped.
		 * 
		 * @property lastFrameOnStop
		 * @default true
		 * @type boolean
		 */
        lastFrameOnStop : true,

        /**
		 * Stops both animIn and animOut instances, if in progress.
		 * 
		 * @method _stopAnims
		 * @param {boolean}
		 *            finish If true, animation will jump to final frame.
		 * @protected
		 */
        _stopAnims : function(finish) {
            if (this.animOut && this.animOut.isAnimated()) {
                this.animOut.stop(finish);
            }

            if (this.animIn && this.animIn.isAnimated()) {
                this.animIn.stop(finish);
            }
        },

        /**
		 * The default onStart handler for the in-animation.
		 * 
		 * @method handleStartAnimateIn
		 * @param {String}
		 *            type The CustomEvent type
		 * @param {Object[]}
		 *            args The CustomEvent arguments
		 * @param {Object}
		 *            obj The scope object
		 */
        handleStartAnimateIn: function (type, args, obj) { },

        /**
		 * The default onTween handler for the in-animation.
		 * 
		 * @method handleTweenAnimateIn
		 * @param {String}
		 *            type The CustomEvent type
		 * @param {Object[]}
		 *            args The CustomEvent arguments
		 * @param {Object}
		 *            obj The scope object
		 */
        handleTweenAnimateIn: function (type, args, obj) { },

        /**
		 * The default onComplete handler for the in-animation.
		 * 
		 * @method handleCompleteAnimateIn
		 * @param {String}
		 *            type The CustomEvent type
		 * @param {Object[]}
		 *            args The CustomEvent arguments
		 * @param {Object}
		 *            obj The scope object
		 */
        handleCompleteAnimateIn: function (type, args, obj) { },

        /**
		 * The default onStart handler for the out-animation.
		 * 
		 * @method handleStartAnimateOut
		 * @param {String}
		 *            type The CustomEvent type
		 * @param {Object[]}
		 *            args The CustomEvent arguments
		 * @param {Object}
		 *            obj The scope object
		 */
        handleStartAnimateOut: function (type, args, obj) { },

        /**
		 * The default onTween handler for the out-animation.
		 * 
		 * @method handleTweenAnimateOut
		 * @param {String}
		 *            type The CustomEvent type
		 * @param {Object[]}
		 *            args The CustomEvent arguments
		 * @param {Object}
		 *            obj The scope object
		 */
        handleTweenAnimateOut: function (type, args, obj) { },

        /**
		 * The default onComplete handler for the out-animation.
		 * 
		 * @method handleCompleteAnimateOut
		 * @param {String}
		 *            type The CustomEvent type
		 * @param {Object[]}
		 *            args The CustomEvent arguments
		 * @param {Object}
		 *            obj The scope object
		 */
        handleCompleteAnimateOut: function (type, args, obj) { },
        
        /**
		 * Returns a string representation of the object.
		 * 
		 * @method toString
		 * @return {String} The string representation of the ContainerEffect
		 */
        toString: function () {
            var output = "ContainerEffect";
            if (this.overlay) {
                output += " [" + this.overlay.toString() + "]";
            }
            return output;
        }
    };

    YAHOO.lang.augmentProto(ContainerEffect, YAHOO.util.EventProvider);

})();
YAHOO.register("container", YAHOO.widget.Module, {version: "2.9.0", build: "2800"});
/*
 * Copyright (c) 2011, Yahoo! Inc. All rights reserved. Code licensed under the
 * BSD License: http://developer.yahoo.com/yui/license.html version: 2.9.0
 */


/**
 * @module menu
 * @description
 *         <p>
 *         The Menu family of components features a collection of controls that
 *         make it easy to add menus to your website or web application. With
 *         the Menu Controls you can create website fly-out menus, customized
 *         context menus, or application-style menu bars with just a small
 *         amount of scripting.
 *         </p>
 *         <p>
 *         The Menu family of controls features:
 *         </p>
 *         <ul>
 *         <li>Keyboard and mouse navigation.</li>
 *         <li>A rich event model that provides access to all of a menu's
 *         interesting moments.</li>
 *         <li>Support for <a
 *         href="http://en.wikipedia.org/wiki/Progressive_Enhancement">Progressive
 *         Enhancement</a>; Menus can be created from simple, semantic markup
 *         on the page or purely through JavaScript.</li>
 *         </ul>
 * @title Menu
 * @namespace YAHOO.widget
 * @requires Event, Dom, Container
 */
(function () {

    var UA = YAHOO.env.ua,
        Dom = YAHOO.util.Dom,
        Event = YAHOO.util.Event,
        Lang = YAHOO.lang,

        _DIV = "DIV",
        _HD = "hd",
        _BD = "bd",
        _FT = "ft",
        _LI = "LI",
        _DISABLED = "disabled",
        _MOUSEOVER = "mouseover",
        _MOUSEOUT = "mouseout",
        _MOUSEDOWN = "mousedown",
        _MOUSEUP = "mouseup",
        _CLICK = "click",
        _KEYDOWN = "keydown",
        _KEYUP = "keyup",
        _KEYPRESS = "keypress",
        _CLICK_TO_HIDE = "clicktohide",
        _POSITION = "position", 
        _DYNAMIC = "dynamic",
        _SHOW_DELAY = "showdelay",
        _SELECTED = "selected",
        _VISIBLE = "visible",
        _UL = "UL",
        _MENUMANAGER = "MenuManager";


    /**
	 * Singleton that manages a collection of all menus and menu items. Listens
	 * for DOM events at the document level and dispatches the events to the
	 * corresponding menu or menu item.
	 * 
	 * @namespace YAHOO.widget
	 * @class MenuManager
	 * @static
	 */
    YAHOO.widget.MenuManager = function () {
    
        // Private member variables
    
    
        // Flag indicating if the DOM event handlers have been attached
    
        var m_bInitializedEventHandlers = false,
    
    
        // Collection of menus

        m_oMenus = {},


        // Collection of visible menus
    
        m_oVisibleMenus = {},
    
    
        // Collection of menu items

        m_oItems = {},


        // Map of DOM event types to their equivalent CustomEvent types
        
        m_oEventTypes = {
            "click": "clickEvent",
            "mousedown": "mouseDownEvent",
            "mouseup": "mouseUpEvent",
            "mouseover": "mouseOverEvent",
            "mouseout": "mouseOutEvent",
            "keydown": "keyDownEvent",
            "keyup": "keyUpEvent",
            "keypress": "keyPressEvent",
            "focus": "focusEvent",
            "focusin": "focusEvent",
            "blur": "blurEvent",
            "focusout": "blurEvent"
        },
    
    
        m_oFocusedMenuItem = null;
    
    
    
        // Private methods
    
    
        /**
		 * @method getMenuRootElement
		 * @description Finds the root DIV node of a menu or the root LI node of
		 *              a menu item.
		 * @private
		 * @param {
		 *            <a
		 *            href="http://www.w3.org/TR/2000/WD-DOM-Level-1-20000929/
		 *            level-one-html.html#ID-58190037">HTMLElement</a>}
		 *            p_oElement Object specifying an HTML element.
		 */
        function getMenuRootElement(p_oElement) {
        
            var oParentNode,
                returnVal;
    
            if (p_oElement && p_oElement.tagName) {
            
                switch (p_oElement.tagName.toUpperCase()) {
                        
                case _DIV:
    
                    oParentNode = p_oElement.parentNode;
    
                    // Check if the DIV is the inner "body" node of a menu

                    if ((
                            Dom.hasClass(p_oElement, _HD) ||
                            Dom.hasClass(p_oElement, _BD) ||
                            Dom.hasClass(p_oElement, _FT)
                        ) && 
                        oParentNode && 
                        oParentNode.tagName && 
                        oParentNode.tagName.toUpperCase() == _DIV) {
                    
                        returnVal = oParentNode;
                    
                    }
                    else {
                    
                        returnVal = p_oElement;
                    
                    }
                
                    break;

                case _LI:
    
                    returnVal = p_oElement;
                    
                    break;

                default:
    
                    oParentNode = p_oElement.parentNode;
    
                    if (oParentNode) {
                    
                        returnVal = getMenuRootElement(oParentNode);
                    
                    }
                
                    break;
                
                }
    
            }
            
            return returnVal;
            
        }
    
    
    
        // Private event handlers
    
    
        /**
		 * @method onDOMEvent
		 * @description Generic, global event handler for all of a menu's
		 *              DOM-based events. This listens for events against the
		 *              document object. If the target of a given event is a
		 *              member of a menu or menu item's DOM, the instance's
		 *              corresponding Custom Event is fired.
		 * @private
		 * @param {Event}
		 *            p_oEvent Object representing the DOM event object passed
		 *            back by the event utility (YAHOO.util.Event).
		 */
        function onDOMEvent(p_oEvent) {
    
            // Get the target node of the DOM event
        
            var oTarget = Event.getTarget(p_oEvent),
                
            // See if the target of the event was a menu, or a menu item
    
            oElement = getMenuRootElement(oTarget),
            bFireEvent = true,
            sEventType = p_oEvent.type,
            sCustomEventType,
            sTagName,
            sId,
            oMenuItem,
            oMenu; 
    
    
            if (oElement) {
    
                sTagName = oElement.tagName.toUpperCase();
        
                if (sTagName == _LI) {
            
                    sId = oElement.id;
            
                    if (sId && m_oItems[sId]) {
            
                        oMenuItem = m_oItems[sId];
                        oMenu = oMenuItem.parent;
            
                    }
                
                }
                else if (sTagName == _DIV) {
                
                    if (oElement.id) {
                    
                        oMenu = m_oMenus[oElement.id];
                    
                    }
                
                }
    
            }
    
    
            if (oMenu) {
    
                sCustomEventType = m_oEventTypes[sEventType];

                /*
				 * There is an inconsistency between Firefox for Mac OS X and
				 * Firefox Windows & Linux regarding the triggering of the
				 * display of the browser's context menu and the subsequent
				 * firing of the "click" event. In Firefox for Windows & Linux,
				 * when the user triggers the display of the browser's context
				 * menu the "click" event also fires for the document object,
				 * even though the "click" event did not fire for the element
				 * that was the original target of the "contextmenu" event. This
				 * is unique to Firefox on Windows & Linux. For all other
				 * A-Grade browsers, including Firefox for Mac OS X, the "click"
				 * event doesn't fire for the document object.
				 * 
				 * This bug in Firefox for Windows affects Menu, as Menu
				 * instances listen for events at the document level and
				 * dispatches Custom Events of the same name. Therefore users of
				 * Menu will get an unwanted firing of the "click" custom event.
				 * The following line fixes this bug.
				 */
                


                if (sEventType == "click" && 
                    (UA.gecko && oMenu.platform != "mac") && 
                    p_oEvent.button > 0) {

                    bFireEvent = false;

                }
    
                // Fire the Custom Event that corresponds the current DOM event
        
                if (bFireEvent && oMenuItem && !oMenuItem.cfg.getProperty(_DISABLED)) {
                    oMenuItem[sCustomEventType].fire(p_oEvent);                   
                }
        
                if (bFireEvent) {
                    oMenu[sCustomEventType].fire(p_oEvent, oMenuItem);
                }
            
            }
            else if (sEventType == _MOUSEDOWN) {
    
                /*
				 * If the target of the event wasn't a menu, hide all
				 * dynamically positioned menus
				 */
                
                for (var i in m_oVisibleMenus) {
        
                    if (Lang.hasOwnProperty(m_oVisibleMenus, i)) {
        
                        oMenu = m_oVisibleMenus[i];

                        if (oMenu.cfg.getProperty(_CLICK_TO_HIDE) && 
                            !(oMenu instanceof YAHOO.widget.MenuBar) && 
                            oMenu.cfg.getProperty(_POSITION) == _DYNAMIC) {

                            oMenu.hide();

                            // In IE when the user mouses down on a focusable
                            // element that element will be focused and become
                            // the "activeElement".
                            // (http://msdn.microsoft.com/en-us/library/ms533065(VS.85).aspx)
                            // However, there is a bug in IE where if there is
                            // a positioned element with a focused descendant
                            // that is hidden in response to the mousedown
                            // event, the target of the mousedown event will
                            // appear to have focus, but will not be set as
                            // the activeElement. This will result in the
                            // element not firing key events, even though it
                            // appears to have focus. The following call to
                            // "setActive" fixes this bug.

                            if (UA.ie && oTarget.focus && (UA.ie < 9)) {
                                oTarget.setActive();
                            }
        
                        }
                        else {
                            
                            if (oMenu.cfg.getProperty(_SHOW_DELAY) > 0) {
                            
                                oMenu._cancelShowDelay();
                            
                            }


                            if (oMenu.activeItem) {
                        
                                oMenu.activeItem.blur();
                                oMenu.activeItem.cfg.setProperty(_SELECTED, false);
                        
                                oMenu.activeItem = null;            
                        
                            }
        
                        }
        
                    }
        
                } 
    
            }
            
        }
    
    
        /**
		 * @method onMenuDestroy
		 * @description "destroy" event handler for a menu.
		 * @private
		 * @param {String}
		 *            p_sType String representing the name of the event that was
		 *            fired.
		 * @param {Array}
		 *            p_aArgs Array of arguments sent when the event was fired.
		 * @param {YAHOO.widget.Menu}
		 *            p_oMenu The menu that fired the event.
		 */
        function onMenuDestroy(p_sType, p_aArgs, p_oMenu) {
    
            if (m_oMenus[p_oMenu.id]) {
    
                this.removeMenu(p_oMenu);
    
            }
    
        }
    
    
        /**
		 * @method onMenuFocus
		 * @description "focus" event handler for a MenuItem instance.
		 * @private
		 * @param {String}
		 *            p_sType String representing the name of the event that was
		 *            fired.
		 * @param {Array}
		 *            p_aArgs Array of arguments sent when the event was fired.
		 */
        function onMenuFocus(p_sType, p_aArgs) {
    
            var oItem = p_aArgs[1];
    
            if (oItem) {
    
                m_oFocusedMenuItem = oItem;
            
            }
    
        }
    
    
        /**
		 * @method onMenuBlur
		 * @description "blur" event handler for a MenuItem instance.
		 * @private
		 * @param {String}
		 *            p_sType String representing the name of the event that was
		 *            fired.
		 * @param {Array}
		 *            p_aArgs Array of arguments sent when the event was fired.
		 */
        function onMenuBlur(p_sType, p_aArgs) {
    
            m_oFocusedMenuItem = null;
    
        }

    
        /**
		 * @method onMenuVisibleConfigChange
		 * @description Event handler for when the "visible" configuration
		 *              property of a Menu instance changes.
		 * @private
		 * @param {String}
		 *            p_sType String representing the name of the event that was
		 *            fired.
		 * @param {Array}
		 *            p_aArgs Array of arguments sent when the event was fired.
		 */
        function onMenuVisibleConfigChange(p_sType, p_aArgs) {
    
            var bVisible = p_aArgs[0],
                sId = this.id;
            
            if (bVisible) {
    
                m_oVisibleMenus[sId] = this;
                
            
            }
            else if (m_oVisibleMenus[sId]) {
            
                delete m_oVisibleMenus[sId];
                
            
            }
        
        }
    
    
        /**
		 * @method onItemDestroy
		 * @description "destroy" event handler for a MenuItem instance.
		 * @private
		 * @param {String}
		 *            p_sType String representing the name of the event that was
		 *            fired.
		 * @param {Array}
		 *            p_aArgs Array of arguments sent when the event was fired.
		 */
        function onItemDestroy(p_sType, p_aArgs) {
    
            removeItem(this);
    
        }


        /**
		 * @method removeItem
		 * @description Removes a MenuItem instance from the MenuManager's
		 *              collection of MenuItems.
		 * @private
		 * @param {MenuItem}
		 *            p_oMenuItem The MenuItem instance to be removed.
		 */    
        function removeItem(p_oMenuItem) {

            var sId = p_oMenuItem.id;
    
            if (sId && m_oItems[sId]) {
    
                if (m_oFocusedMenuItem == p_oMenuItem) {
    
                    m_oFocusedMenuItem = null;
    
                }
    
                delete m_oItems[sId];
                
                p_oMenuItem.destroyEvent.unsubscribe(onItemDestroy);
    
    
            }

        }
    
    
        /**
		 * @method onItemAdded
		 * @description "itemadded" event handler for a Menu instance.
		 * @private
		 * @param {String}
		 *            p_sType String representing the name of the event that was
		 *            fired.
		 * @param {Array}
		 *            p_aArgs Array of arguments sent when the event was fired.
		 */
        function onItemAdded(p_sType, p_aArgs) {
    
            var oItem = p_aArgs[0],
                sId;
    
            if (oItem instanceof YAHOO.widget.MenuItem) { 
    
                sId = oItem.id;
        
                if (!m_oItems[sId]) {
            
                    m_oItems[sId] = oItem;
        
                    oItem.destroyEvent.subscribe(onItemDestroy);
        
        
                }
    
            }
        
        }
    
    
        return {
    
            // Privileged methods
    
    
            /**
			 * @method addMenu
			 * @description Adds a menu to the collection of known menus.
			 * @param {YAHOO.widget.Menu}
			 *            p_oMenu Object specifying the Menu instance to be
			 *            added.
			 */
            addMenu: function (p_oMenu) {
    
                var oDoc;
    
                if (p_oMenu instanceof YAHOO.widget.Menu && p_oMenu.id && 
                    !m_oMenus[p_oMenu.id]) {
        
                    m_oMenus[p_oMenu.id] = p_oMenu;
                
            
                    if (!m_bInitializedEventHandlers) {
            
                        oDoc = document;
                
                        Event.on(oDoc, _MOUSEOVER, onDOMEvent, this, true);
                        Event.on(oDoc, _MOUSEOUT, onDOMEvent, this, true);
                        Event.on(oDoc, _MOUSEDOWN, onDOMEvent, this, true);
                        Event.on(oDoc, _MOUSEUP, onDOMEvent, this, true);
                        Event.on(oDoc, _CLICK, onDOMEvent, this, true);
                        Event.on(oDoc, _KEYDOWN, onDOMEvent, this, true);
                        Event.on(oDoc, _KEYUP, onDOMEvent, this, true);
                        Event.on(oDoc, _KEYPRESS, onDOMEvent, this, true);
    
                        Event.onFocus(oDoc, onDOMEvent, this, true);
                        Event.onBlur(oDoc, onDOMEvent, this, true);						
    
                        m_bInitializedEventHandlers = true;
                        
            
                    }
            
                    p_oMenu.cfg.subscribeToConfigEvent(_VISIBLE, onMenuVisibleConfigChange);
                    p_oMenu.destroyEvent.subscribe(onMenuDestroy, p_oMenu, this);
                    p_oMenu.itemAddedEvent.subscribe(onItemAdded);
                    p_oMenu.focusEvent.subscribe(onMenuFocus);
                    p_oMenu.blurEvent.subscribe(onMenuBlur);
        
        
                }
        
            },
    
        
            /**
			 * @method removeMenu
			 * @description Removes a menu from the collection of known menus.
			 * @param {YAHOO.widget.Menu}
			 *            p_oMenu Object specifying the Menu instance to be
			 *            removed.
			 */
            removeMenu: function (p_oMenu) {
    
                var sId,
                    aItems,
                    i;
        
                if (p_oMenu) {
    
                    sId = p_oMenu.id;
        
                    if ((sId in m_oMenus) && (m_oMenus[sId] == p_oMenu)) {

                        // Unregister each menu item

                        aItems = p_oMenu.getItems();

                        if (aItems && aItems.length > 0) {

                            i = aItems.length - 1;

                            do {

                                removeItem(aItems[i]);

                            }
                            while (i--);

                        }


                        // Unregister the menu

                        delete m_oMenus[sId];
            
        

                        /*
						 * Unregister the menu from the collection of visible
						 * menus
						 */

                        if ((sId in m_oVisibleMenus) && (m_oVisibleMenus[sId] == p_oMenu)) {
            
                            delete m_oVisibleMenus[sId];
                            
       
                        }


                        // Unsubscribe event listeners

                        if (p_oMenu.cfg) {

                            p_oMenu.cfg.unsubscribeFromConfigEvent(_VISIBLE, 
                                onMenuVisibleConfigChange);
                            
                        }

                        p_oMenu.destroyEvent.unsubscribe(onMenuDestroy, 
                            p_oMenu);
                
                        p_oMenu.itemAddedEvent.unsubscribe(onItemAdded);
                        p_oMenu.focusEvent.unsubscribe(onMenuFocus);
                        p_oMenu.blurEvent.unsubscribe(onMenuBlur);

                    }
                
                }
    
            },
        
        
            /**
			 * @method hideVisible
			 * @description Hides all visible, dynamically positioned menus
			 *              (excluding instances of YAHOO.widget.MenuBar).
			 */
            hideVisible: function () {
        
                var oMenu;
        
                for (var i in m_oVisibleMenus) {
        
                    if (Lang.hasOwnProperty(m_oVisibleMenus, i)) {
        
                        oMenu = m_oVisibleMenus[i];
        
                        if (!(oMenu instanceof YAHOO.widget.MenuBar) && 
                            oMenu.cfg.getProperty(_POSITION) == _DYNAMIC) {
        
                            oMenu.hide();
        
                        }
        
                    }
        
                }        
    
            },


            /**
			 * @method getVisible
			 * @description Returns a collection of all visible menus registered
			 *              with the menu manger.
			 * @return {Object}
			 */
            getVisible: function () {
            
                return m_oVisibleMenus;
            
            },

    
            /**
			 * @method getMenus
			 * @description Returns a collection of all menus registered with
			 *              the menu manger.
			 * @return {Object}
			 */
            getMenus: function () {
    
                return m_oMenus;
            
            },
    
    
            /**
			 * @method getMenu
			 * @description Returns a menu with the specified id.
			 * @param {String}
			 *            p_sId String specifying the id of the
			 *            <code>&#60;div&#62;</code> element representing the
			 *            menu to be retrieved.
			 * @return {YAHOO.widget.Menu}
			 */
            getMenu: function (p_sId) {
                
                var returnVal;
                
                if (p_sId in m_oMenus) {
                
                    returnVal = m_oMenus[p_sId];
                
                }
            
                return returnVal;
            
            },
    
    
            /**
			 * @method getMenuItem
			 * @description Returns a menu item with the specified id.
			 * @param {String}
			 *            p_sId String specifying the id of the
			 *            <code>&#60;li&#62;</code> element representing the
			 *            menu item to be retrieved.
			 * @return {YAHOO.widget.MenuItem}
			 */
            getMenuItem: function (p_sId) {
    
                var returnVal;
    
                if (p_sId in m_oItems) {
    
                    returnVal = m_oItems[p_sId];
                
                }
                
                return returnVal;
            
            },


            /**
			 * @method getMenuItemGroup
			 * @description Returns an array of menu item instances whose
			 *              corresponding <code>&#60;li&#62;</code> elements
			 *              are child nodes of the <code>&#60;ul&#62;</code>
			 *              element with the specified id.
			 * @param {String}
			 *            p_sId String specifying the id of the
			 *            <code>&#60;ul&#62;</code> element representing the
			 *            group of menu items to be retrieved.
			 * @return {Array}
			 */
            getMenuItemGroup: function (p_sId) {

                var oUL = Dom.get(p_sId),
                    aItems,
                    oNode,
                    oItem,
                    sId,
                    returnVal;
    

                if (oUL && oUL.tagName && oUL.tagName.toUpperCase() == _UL) {

                    oNode = oUL.firstChild;

                    if (oNode) {

                        aItems = [];
                        
                        do {

                            sId = oNode.id;

                            if (sId) {
                            
                                oItem = this.getMenuItem(sId);
                                
                                if (oItem) {
                                
                                    aItems[aItems.length] = oItem;
                                
                                }
                            
                            }
                        
                        }
                        while ((oNode = oNode.nextSibling));


                        if (aItems.length > 0) {

                            returnVal = aItems;
                        
                        }

                    }
                
                }

                return returnVal;
            
            },

    
            /**
			 * @method getFocusedMenuItem
			 * @description Returns a reference to the menu item that currently
			 *              has focus.
			 * @return {YAHOO.widget.MenuItem}
			 */
            getFocusedMenuItem: function () {
    
                return m_oFocusedMenuItem;
    
            },
    
    
            /**
			 * @method getFocusedMenu
			 * @description Returns a reference to the menu that currently has
			 *              focus.
			 * @return {YAHOO.widget.Menu}
			 */
            getFocusedMenu: function () {

                var returnVal;
    
                if (m_oFocusedMenuItem) {
    
                    returnVal = m_oFocusedMenuItem.parent.getRoot();
                
                }
    
                return returnVal;
    
            },
    
        
            /**
			 * @method toString
			 * @description Returns a string representing the menu manager.
			 * @return {String}
			 */
            toString: function () {
            
                return _MENUMANAGER;
            
            }
    
        };
    
    }();

})();



(function () {

    var Lang = YAHOO.lang,

    // String constants
    
        _MENU = "Menu",
        _DIV_UPPERCASE = "DIV",
        _DIV_LOWERCASE = "div",
        _ID = "id",
        _SELECT = "SELECT",
        _XY = "xy",
        _Y = "y",
        _UL_UPPERCASE = "UL",
        _UL_LOWERCASE = "ul",
        _FIRST_OF_TYPE = "first-of-type",
        _LI = "LI",
        _OPTGROUP = "OPTGROUP",
        _OPTION = "OPTION",
        _DISABLED = "disabled",
        _NONE = "none",
        _SELECTED = "selected",
        _GROUP_INDEX = "groupindex",
        _INDEX = "index",
        _SUBMENU = "submenu",
        _VISIBLE = "visible",
        _HIDE_DELAY = "hidedelay",
        _POSITION = "position",
        _DYNAMIC = "dynamic",
        _STATIC = "static",
        _DYNAMIC_STATIC = _DYNAMIC + "," + _STATIC,
        _URL = "url",
        _HASH = "#",
        _TARGET = "target",
        _MAX_HEIGHT = "maxheight",
        _TOP_SCROLLBAR = "topscrollbar",
        _BOTTOM_SCROLLBAR = "bottomscrollbar",
        _UNDERSCORE = "_",
        _TOP_SCROLLBAR_DISABLED = _TOP_SCROLLBAR + _UNDERSCORE + _DISABLED,
        _BOTTOM_SCROLLBAR_DISABLED = _BOTTOM_SCROLLBAR + _UNDERSCORE + _DISABLED,
        _MOUSEMOVE = "mousemove",
        _SHOW_DELAY = "showdelay",
        _SUBMENU_HIDE_DELAY = "submenuhidedelay",
        _IFRAME = "iframe",
        _CONSTRAIN_TO_VIEWPORT = "constraintoviewport",
        _PREVENT_CONTEXT_OVERLAP = "preventcontextoverlap",
        _SUBMENU_ALIGNMENT = "submenualignment",
        _AUTO_SUBMENU_DISPLAY = "autosubmenudisplay",
        _CLICK_TO_HIDE = "clicktohide",
        _CONTAINER = "container",
        _SCROLL_INCREMENT = "scrollincrement",
        _MIN_SCROLL_HEIGHT = "minscrollheight",
        _CLASSNAME = "classname",
        _SHADOW = "shadow",
        _KEEP_OPEN = "keepopen",
        _HD = "hd",
        _HAS_TITLE = "hastitle",
        _CONTEXT = "context",
        _EMPTY_STRING = "",
        _MOUSEDOWN = "mousedown",
        _KEYDOWN = "keydown",
        _HEIGHT = "height",
        _WIDTH = "width",
        _PX = "px",
        _EFFECT = "effect",
        _MONITOR_RESIZE = "monitorresize",
        _DISPLAY = "display",
        _BLOCK = "block",
        _VISIBILITY = "visibility",
        _ABSOLUTE = "absolute",
        _ZINDEX = "zindex",
        _YUI_MENU_BODY_SCROLLED = "yui-menu-body-scrolled",
        _NON_BREAKING_SPACE = "&#32;",
        _SPACE = " ",
        _MOUSEOVER = "mouseover",
        _MOUSEOUT = "mouseout",
        _ITEM_ADDED = "itemAdded",
        _ITEM_REMOVED = "itemRemoved",
        _HIDDEN = "hidden",
        _YUI_MENU_SHADOW = "yui-menu-shadow",
        _YUI_MENU_SHADOW_VISIBLE = _YUI_MENU_SHADOW + "-visible",
        _YUI_MENU_SHADOW_YUI_MENU_SHADOW_VISIBLE = _YUI_MENU_SHADOW + _SPACE + _YUI_MENU_SHADOW_VISIBLE;


/**
 * The Menu class creates a container that holds a vertical list representing a
 * set of options or commands. Menu is the base class for all menu containers.
 * 
 * @param {String}
 *            p_oElement String specifying the id attribute of the
 *            <code>&#60;div&#62;</code> element of the menu.
 * @param {String}
 *            p_oElement String specifying the id attribute of the
 *            <code>&#60;select&#62;</code> element to be used as the data
 *            source for the menu.
 * @param {
 *            <a href="http://www.w3.org/TR/2000/WD-DOM-Level-1-20000929/
 *            level-one-html.html#ID-22445964">HTMLDivElement</a>} p_oElement
 *            Object specifying the <code>&#60;div&#62;</code> element of the
 *            menu.
 * @param {
 *            <a href="http://www.w3.org/TR/2000/WD-DOM-Level-1-20000929/
 *            level-one-html.html#ID-94282980">HTMLSelectElement</a>}
 *            p_oElement Object specifying the <code>&#60;select&#62;</code>
 *            element to be used as the data source for the menu.
 * @param {Object}
 *            p_oConfig Optional. Object literal specifying the configuration
 *            for the menu. See configuration class documentation for more
 *            details.
 * @namespace YAHOO.widget
 * @class Menu
 * @constructor
 * @extends YAHOO.widget.Overlay
 */
YAHOO.widget.Menu = function (p_oElement, p_oConfig) {

    if (p_oConfig) {
        this.parent = p_oConfig.parent;
        this.lazyLoad = p_oConfig.lazyLoad || p_oConfig.lazyload;
        this.itemData = p_oConfig.itemData || p_oConfig.itemdata;
    }

    YAHOO.widget.Menu.superclass.constructor.call(this, p_oElement, p_oConfig);
};



/**
 * @method checkPosition
 * @description Checks to make sure that the value of the "position" property is
 *              one of the supported strings. Returns true if the position is
 *              supported.
 * @private
 * @param {Object}
 *            p_sPosition String specifying the position of the menu.
 * @return {Boolean}
 */
function checkPosition(p_sPosition) {

    var returnVal = false;

    if (Lang.isString(p_sPosition)) {

        returnVal = (_DYNAMIC_STATIC.indexOf((p_sPosition.toLowerCase())) != -1);

    }

    return returnVal;

}


var Dom = YAHOO.util.Dom,
    Event = YAHOO.util.Event,
    Module = YAHOO.widget.Module,
    Overlay = YAHOO.widget.Overlay,
    Menu = YAHOO.widget.Menu,
    MenuManager = YAHOO.widget.MenuManager,
    CustomEvent = YAHOO.util.CustomEvent,
    UA = YAHOO.env.ua,
    
    m_oShadowTemplate,

    bFocusListenerInitialized = false,

    oFocusedElement,

    EVENT_TYPES = [
    
        ["mouseOverEvent", _MOUSEOVER],
        ["mouseOutEvent", _MOUSEOUT],
        ["mouseDownEvent", _MOUSEDOWN],
        ["mouseUpEvent", "mouseup"],
        ["clickEvent", "click"],
        ["keyPressEvent", "keypress"],
        ["keyDownEvent", _KEYDOWN],
        ["keyUpEvent", "keyup"],
        ["focusEvent", "focus"],
        ["blurEvent", "blur"],
        ["itemAddedEvent", _ITEM_ADDED],
        ["itemRemovedEvent", _ITEM_REMOVED]

    ],

    VISIBLE_CONFIG =  { 
        key: _VISIBLE, 
        value: false, 
        validator: Lang.isBoolean
    }, 

    CONSTRAIN_TO_VIEWPORT_CONFIG =  {
        key: _CONSTRAIN_TO_VIEWPORT, 
        value: true, 
        validator: Lang.isBoolean, 
        supercedes: [_IFRAME,"x",_Y,_XY]
    }, 

    PREVENT_CONTEXT_OVERLAP_CONFIG =  {
        key: _PREVENT_CONTEXT_OVERLAP,
        value: true,
        validator: Lang.isBoolean,  
        supercedes: [_CONSTRAIN_TO_VIEWPORT]
    },

    POSITION_CONFIG =  { 
        key: _POSITION, 
        value: _DYNAMIC, 
        validator: checkPosition, 
        supercedes: [_VISIBLE, _IFRAME]
    }, 

    SUBMENU_ALIGNMENT_CONFIG =  { 
        key: _SUBMENU_ALIGNMENT, 
        value: ["tl","tr"]
    },

    AUTO_SUBMENU_DISPLAY_CONFIG =  { 
        key: _AUTO_SUBMENU_DISPLAY, 
        value: true, 
        validator: Lang.isBoolean,
        suppressEvent: true
    }, 

    SHOW_DELAY_CONFIG =  { 
        key: _SHOW_DELAY, 
        value: 250, 
        validator: Lang.isNumber, 
        suppressEvent: true
    }, 

    HIDE_DELAY_CONFIG =  { 
        key: _HIDE_DELAY, 
        value: 0, 
        validator: Lang.isNumber, 
        suppressEvent: true
    }, 

    SUBMENU_HIDE_DELAY_CONFIG =  { 
        key: _SUBMENU_HIDE_DELAY, 
        value: 250, 
        validator: Lang.isNumber,
        suppressEvent: true
    }, 

    CLICK_TO_HIDE_CONFIG =  { 
        key: _CLICK_TO_HIDE, 
        value: true, 
        validator: Lang.isBoolean,
        suppressEvent: true
    },

    CONTAINER_CONFIG =  { 
        key: _CONTAINER,
        suppressEvent: true
    }, 

    SCROLL_INCREMENT_CONFIG =  { 
        key: _SCROLL_INCREMENT, 
        value: 1, 
        validator: Lang.isNumber,
        supercedes: [_MAX_HEIGHT],
        suppressEvent: true
    },

    MIN_SCROLL_HEIGHT_CONFIG =  { 
        key: _MIN_SCROLL_HEIGHT, 
        value: 90, 
        validator: Lang.isNumber,
        supercedes: [_MAX_HEIGHT],
        suppressEvent: true
    },    

    MAX_HEIGHT_CONFIG =  { 
        key: _MAX_HEIGHT, 
        value: 0, 
        validator: Lang.isNumber,
        supercedes: [_IFRAME],
        suppressEvent: true
    }, 

    CLASS_NAME_CONFIG =  { 
        key: _CLASSNAME, 
        value: null, 
        validator: Lang.isString,
        suppressEvent: true
    }, 

    DISABLED_CONFIG =  { 
        key: _DISABLED, 
        value: false, 
        validator: Lang.isBoolean,
        suppressEvent: true
    },
    
    SHADOW_CONFIG =  { 
        key: _SHADOW, 
        value: true, 
        validator: Lang.isBoolean,
        suppressEvent: true,
        supercedes: [_VISIBLE]
    },
    
    KEEP_OPEN_CONFIG = {
        key: _KEEP_OPEN, 
        value: false, 
        validator: Lang.isBoolean
    };


function onDocFocus(event) {

    oFocusedElement = Event.getTarget(event);

}



YAHOO.lang.extend(Menu, Overlay, {


// Constants


/**
 * @property CSS_CLASS_NAME
 * @description String representing the CSS class(es) to be applied to the
 *              menu's <code>&#60;div&#62;</code> element.
 * @default "yuimenu"
 * @final
 * @type String
 */
CSS_CLASS_NAME: "yuimenu",


/**
 * @property ITEM_TYPE
 * @description Object representing the type of menu item to instantiate and add
 *              when parsing the child nodes (either <code>&#60;li&#62;</code>
 *              element, <code>&#60;optgroup&#62;</code> element or
 *              <code>&#60;option&#62;</code>) of the menu's source HTML
 *              element.
 * @default YAHOO.widget.MenuItem
 * @final
 * @type YAHOO.widget.MenuItem
 */
ITEM_TYPE: null,


/**
 * @property GROUP_TITLE_TAG_NAME
 * @description String representing the tagname of the HTML element used to
 *              title the menu's item groups.
 * @default H6
 * @final
 * @type String
 */
GROUP_TITLE_TAG_NAME: "h6",


/**
 * @property OFF_SCREEN_POSITION
 * @description Array representing the default x and y position that a menu
 *              should have when it is positioned outside the viewport by the
 *              "poistionOffScreen" method.
 * @default "-999em"
 * @final
 * @type String
 */
OFF_SCREEN_POSITION: "-999em",


// Private properties


/**
 * @property _useHideDelay
 * @description Boolean indicating if the "mouseover" and "mouseout" event
 *              handlers used for hiding the menu via a call to
 *              "YAHOO.lang.later" have already been assigned.
 * @default false
 * @private
 * @type Boolean
 */
_useHideDelay: false,


/**
 * @property _bHandledMouseOverEvent
 * @description Boolean indicating the current state of the menu's "mouseover"
 *              event.
 * @default false
 * @private
 * @type Boolean
 */
_bHandledMouseOverEvent: false,


/**
 * @property _bHandledMouseOutEvent
 * @description Boolean indicating the current state of the menu's "mouseout"
 *              event.
 * @default false
 * @private
 * @type Boolean
 */
_bHandledMouseOutEvent: false,


/**
 * @property _aGroupTitleElements
 * @description Array of HTML element used to title groups of menu items.
 * @default []
 * @private
 * @type Array
 */
_aGroupTitleElements: null,


/**
 * @property _aItemGroups
 * @description Multi-dimensional Array representing the menu items as they are
 *              grouped in the menu.
 * @default []
 * @private
 * @type Array
 */
_aItemGroups: null,


/**
 * @property _aListElements
 * @description Array of <code>&#60;ul&#62;</code> elements, each of which is
 *              the parent node for each item's <code>&#60;li&#62;</code>
 *              element.
 * @default []
 * @private
 * @type Array
 */
_aListElements: null,


/**
 * @property _nCurrentMouseX
 * @description The current x coordinate of the mouse inside the area of the
 *              menu.
 * @default 0
 * @private
 * @type Number
 */
_nCurrentMouseX: 0,


/**
 * @property _bStopMouseEventHandlers
 * @description Stops "mouseover," "mouseout," and "mousemove" event handlers
 *              from executing.
 * @default false
 * @private
 * @type Boolean
 */
_bStopMouseEventHandlers: false,


/**
 * @property _sClassName
 * @description The current value of the "classname" configuration attribute.
 * @default null
 * @private
 * @type String
 */
_sClassName: null,



// Public properties


/**
 * @property lazyLoad
 * @description Boolean indicating if the menu's "lazy load" feature is enabled.
 *              If set to "true," initialization and rendering of the menu's
 *              items will be deferred until the first time it is made visible.
 *              This property should be set via the constructor using the
 *              configuration object literal.
 * @default false
 * @type Boolean
 */
lazyLoad: false,


/**
 * @property itemData
 * @description Array of items to be added to the menu. The array can contain
 *              strings representing the text for each item to be created,
 *              object literals representing the menu item configuration
 *              properties, or MenuItem instances. This property should be set
 *              via the constructor using the configuration object literal.
 * @default null
 * @type Array
 */
itemData: null,


/**
 * @property activeItem
 * @description Object reference to the item in the menu that has is selected.
 * @default null
 * @type YAHOO.widget.MenuItem
 */
activeItem: null,


/**
 * @property parent
 * @description Object reference to the menu's parent menu or menu item. This
 *              property can be set via the constructor using the configuration
 *              object literal.
 * @default null
 * @type YAHOO.widget.MenuItem
 */
parent: null,


/**
 * @property srcElement
 * @description Object reference to the HTML element (either
 *              <code>&#60;select&#62;</code> or <code>&#60;div&#62;</code>)
 *              used to create the menu.
 * @default null
 * @type <a href="http://www.w3.org/TR/2000/WD-DOM-Level-1-20000929/
 *       level-one-html.html#ID-94282980">HTMLSelectElement</a>|<a
 *       href="http://www.w3.org/TR/2000/WD-DOM-Level-1-20000929/level-one-html.
 *       html#ID-22445964">HTMLDivElement</a>
 */
srcElement: null,



// Events


/**
 * @event mouseOverEvent
 * @description Fires when the mouse has entered the menu. Passes back the DOM
 *              Event object as an argument.
 */


/**
 * @event mouseOutEvent
 * @description Fires when the mouse has left the menu. Passes back the DOM
 *              Event object as an argument.
 * @type YAHOO.util.CustomEvent
 */


/**
 * @event mouseDownEvent
 * @description Fires when the user mouses down on the menu. Passes back the DOM
 *              Event object as an argument.
 * @type YAHOO.util.CustomEvent
 */


/**
 * @event mouseUpEvent
 * @description Fires when the user releases a mouse button while the mouse is
 *              over the menu. Passes back the DOM Event object as an argument.
 * @type YAHOO.util.CustomEvent
 */


/**
 * @event clickEvent
 * @description Fires when the user clicks the on the menu. Passes back the DOM
 *              Event object as an argument.
 * @type YAHOO.util.CustomEvent
 */


/**
 * @event keyPressEvent
 * @description Fires when the user presses an alphanumeric key when one of the
 *              menu's items has focus. Passes back the DOM Event object as an
 *              argument.
 * @type YAHOO.util.CustomEvent
 */


/**
 * @event keyDownEvent
 * @description Fires when the user presses a key when one of the menu's items
 *              has focus. Passes back the DOM Event object as an argument.
 * @type YAHOO.util.CustomEvent
 */


/**
 * @event keyUpEvent
 * @description Fires when the user releases a key when one of the menu's items
 *              has focus. Passes back the DOM Event object as an argument.
 * @type YAHOO.util.CustomEvent
 */


/**
 * @event itemAddedEvent
 * @description Fires when an item is added to the menu.
 * @type YAHOO.util.CustomEvent
 */


/**
 * @event itemRemovedEvent
 * @description Fires when an item is removed to the menu.
 * @type YAHOO.util.CustomEvent
 */


/**
 * @method init
 * @description The Menu class's initialization method. This method is
 *              automatically called by the constructor, and sets up all DOM
 *              references for pre-existing markup, and creates required markup
 *              if it is not already present.
 * @param {String}
 *            p_oElement String specifying the id attribute of the
 *            <code>&#60;div&#62;</code> element of the menu.
 * @param {String}
 *            p_oElement String specifying the id attribute of the
 *            <code>&#60;select&#62;</code> element to be used as the data
 *            source for the menu.
 * @param {
 *            <a href="http://www.w3.org/TR/2000/WD-DOM-Level-1-20000929/
 *            level-one-html.html#ID-22445964">HTMLDivElement</a>} p_oElement
 *            Object specifying the <code>&#60;div&#62;</code> element of the
 *            menu.
 * @param {
 *            <a href="http://www.w3.org/TR/2000/WD-DOM-Level-1-20000929/
 *            level-one-html.html#ID-94282980">HTMLSelectElement</a>}
 *            p_oElement Object specifying the <code>&#60;select&#62;</code>
 *            element to be used as the data source for the menu.
 * @param {Object}
 *            p_oConfig Optional. Object literal specifying the configuration
 *            for the menu. See configuration class documentation for more
 *            details.
 */
init: function (p_oElement, p_oConfig) {

    this._aItemGroups = [];
    this._aListElements = [];
    this._aGroupTitleElements = [];

    if (!this.ITEM_TYPE) {

        this.ITEM_TYPE = YAHOO.widget.MenuItem;

    }


    var oElement;

    if (Lang.isString(p_oElement)) {

        oElement = Dom.get(p_oElement);

    }
    else if (p_oElement.tagName) {

        oElement = p_oElement;

    }


    if (oElement && oElement.tagName) {

        switch(oElement.tagName.toUpperCase()) {
    
            case _DIV_UPPERCASE:

                this.srcElement = oElement;

                if (!oElement.id) {

                    oElement.setAttribute(_ID, Dom.generateId());

                }


                /*
				 * Note: we don't pass the user config in here yet because we
				 * only want it executed once, at the lowest subclass level.
				 */ 
            
                Menu.superclass.init.call(this, oElement);

                this.beforeInitEvent.fire(Menu);

    
            break;
    
            case _SELECT:
    
                this.srcElement = oElement;

    
                /*
				 * The source element is not something that we can use outright,
				 * so we need to create a new Overlay
				 * 
				 * Note: we don't pass the user config in here yet because we
				 * only want it executed once, at the lowest subclass level.
				 */ 

                Menu.superclass.init.call(this, Dom.generateId());

                this.beforeInitEvent.fire(Menu);


            break;

        }

    }
    else {

        /*
		 * Note: we don't pass the user config in here yet because we only want
		 * it executed once, at the lowest subclass level.
		 */ 
    
        Menu.superclass.init.call(this, p_oElement);

        this.beforeInitEvent.fire(Menu);


    }


    if (this.element) {
        Dom.addClass(this.element, this.CSS_CLASS_NAME);

        // Subscribe to Custom Events
        this.initEvent.subscribe(this._onInit);
        this.beforeRenderEvent.subscribe(this._onBeforeRender);
        this.renderEvent.subscribe(this._onRender);
        this.beforeShowEvent.subscribe(this._onBeforeShow);
        this.hideEvent.subscribe(this._onHide);
        this.showEvent.subscribe(this._onShow);
        this.beforeHideEvent.subscribe(this._onBeforeHide);
        this.mouseOverEvent.subscribe(this._onMouseOver);
        this.mouseOutEvent.subscribe(this._onMouseOut);
        this.clickEvent.subscribe(this._onClick);
        this.keyDownEvent.subscribe(this._onKeyDown);
        this.keyPressEvent.subscribe(this._onKeyPress);
        this.blurEvent.subscribe(this._onBlur);

        if (!bFocusListenerInitialized) {
            Event.onFocus(document, onDocFocus);
            bFocusListenerInitialized = true;
        }

        // Fixes an issue in Firefox 2 and Webkit where Dom's "getX" and "getY"
        // methods return values that don't take scrollTop into consideration

        if ((UA.gecko && UA.gecko < 1.9) || (UA.webkit && UA.webkit < 523)) {
            this.cfg.subscribeToConfigEvent(_Y, this._onYChange);
        }


        if (p_oConfig) {
            this.cfg.applyConfig(p_oConfig, true);
        }

        // Register the Menu instance with the MenuManager
        MenuManager.addMenu(this);

        this.initEvent.fire(Menu);
    }
},



// Private methods


/**
 * @method _initSubTree
 * @description Iterates the childNodes of the source element to find nodes used
 *              to instantiate menu and menu items.
 * @private
 */
_initSubTree: function () {

    var oSrcElement = this.srcElement,
        sSrcElementTagName,
        nGroup,
        sGroupTitleTagName,
        oNode,
        aListElements,
        nListElements,
        i;


    if (oSrcElement) {
    
        sSrcElementTagName = 
            (oSrcElement.tagName && oSrcElement.tagName.toUpperCase());


        if (sSrcElementTagName == _DIV_UPPERCASE) {
    
            // Populate the collection of item groups and item group titles
    
            oNode = this.body.firstChild;
    

            if (oNode) {
    
                nGroup = 0;
                sGroupTitleTagName = this.GROUP_TITLE_TAG_NAME.toUpperCase();
        
                do {
        

                    if (oNode && oNode.tagName) {
        
                        switch (oNode.tagName.toUpperCase()) {
        
                            case sGroupTitleTagName:
                            
                                this._aGroupTitleElements[nGroup] = oNode;
        
                            break;
        
                            case _UL_UPPERCASE:
        
                                this._aListElements[nGroup] = oNode;
                                this._aItemGroups[nGroup] = [];
                                nGroup++;
        
                            break;
        
                        }
                    
                    }
        
                }
                while ((oNode = oNode.nextSibling));
        
        
                /*
				 * Apply the "first-of-type" class to the first UL to mimic the
				 * ":first-of-type" CSS3 psuedo class.
				 */
        
                if (this._aListElements[0]) {
        
                    Dom.addClass(this._aListElements[0], _FIRST_OF_TYPE);
        
                }
            
            }
    
        }
    
    
        oNode = null;
    
    

        if (sSrcElementTagName) {
    
            switch (sSrcElementTagName) {
        
                case _DIV_UPPERCASE:

                    aListElements = this._aListElements;
                    nListElements = aListElements.length;
        
                    if (nListElements > 0) {
        
        
                        i = nListElements - 1;
        
                        do {
        
                            oNode = aListElements[i].firstChild;
            
                            if (oNode) {

            
                                do {
                
                                    if (oNode && oNode.tagName && 
                                        oNode.tagName.toUpperCase() == _LI) {
                
        
                                        this.addItem(new this.ITEM_TYPE(oNode, 
                                                    { parent: this }), i);
            
                                    }
                        
                                }
                                while ((oNode = oNode.nextSibling));
                            
                            }
                    
                        }
                        while (i--);
        
                    }
        
                break;
        
                case _SELECT:
        
        
                    oNode = oSrcElement.firstChild;
        
                    do {
        
                        if (oNode && oNode.tagName) {
                        
                            switch (oNode.tagName.toUpperCase()) {
            
                                case _OPTGROUP:
                                case _OPTION:
            
            
                                    this.addItem(
                                            new this.ITEM_TYPE(
                                                    oNode, 
                                                    { parent: this }
                                                )
                                            );
            
                                break;
            
                            }
    
                        }
        
                    }
                    while ((oNode = oNode.nextSibling));
        
                break;
        
            }
    
        }    
    
    }

},


/**
 * @method _getFirstEnabledItem
 * @description Returns the first enabled item in the menu.
 * @return {YAHOO.widget.MenuItem}
 * @private
 */
_getFirstEnabledItem: function () {

    var aItems = this.getItems(),
        nItems = aItems.length,
        oItem,
        returnVal;
    

    for(var i=0; i<nItems; i++) {

        oItem = aItems[i];

        if (oItem && !oItem.cfg.getProperty(_DISABLED) && oItem.element.style.display != _NONE) {

            returnVal = oItem;
            break;

        }
    
    }
    
    return returnVal;
    
},


/**
 * @method _addItemToGroup
 * @description Adds a menu item to a group.
 * @private
 * @param {Number}
 *            p_nGroupIndex Number indicating the group to which the item
 *            belongs.
 * @param {YAHOO.widget.MenuItem}
 *            p_oItem Object reference for the MenuItem instance to be added to
 *            the menu.
 * @param {HTML}
 *            p_oItem String or markup specifying the content of the item to be
 *            added to the menu. The item is inserted into the DOM as HTML, and
 *            should be escaped by the implementor if coming from an external
 *            source.
 * @param {Object}
 *            p_oItem Object literal containing a set of menu item configuration
 *            properties.
 * @param {Number}
 *            p_nItemIndex Optional. Number indicating the index at which the
 *            menu item should be added.
 * @return {YAHOO.widget.MenuItem}
 */
_addItemToGroup: function (p_nGroupIndex, p_oItem, p_nItemIndex) {

    var oItem,
        nGroupIndex,
        aGroup,
        oGroupItem,
        bAppend,
        oNextItemSibling,
        nItemIndex,
        returnVal;


    function getNextItemSibling(p_aArray, p_nStartIndex) {

        return (p_aArray[p_nStartIndex] || getNextItemSibling(p_aArray, (p_nStartIndex+1)));

    }


    if (p_oItem instanceof this.ITEM_TYPE) {

        oItem = p_oItem;
        oItem.parent = this;

    }
    else if (Lang.isString(p_oItem)) {

        oItem = new this.ITEM_TYPE(p_oItem, { parent: this });
    
    }
    else if (Lang.isObject(p_oItem)) {

        p_oItem.parent = this;

        oItem = new this.ITEM_TYPE(p_oItem.text, p_oItem);

    }


    if (oItem) {

        if (oItem.cfg.getProperty(_SELECTED)) {

            this.activeItem = oItem;
        
        }


        nGroupIndex = Lang.isNumber(p_nGroupIndex) ? p_nGroupIndex : 0;
        aGroup = this._getItemGroup(nGroupIndex);



        if (!aGroup) {

            aGroup = this._createItemGroup(nGroupIndex);

        }


        if (Lang.isNumber(p_nItemIndex)) {

            bAppend = (p_nItemIndex >= aGroup.length);            


            if (aGroup[p_nItemIndex]) {
    
                aGroup.splice(p_nItemIndex, 0, oItem);
    
            }
            else {
    
                aGroup[p_nItemIndex] = oItem;
    
            }


            oGroupItem = aGroup[p_nItemIndex];

            if (oGroupItem) {

                if (bAppend && (!oGroupItem.element.parentNode || 
                        oGroupItem.element.parentNode.nodeType == 11)) {
        
                    this._aListElements[nGroupIndex].appendChild(oGroupItem.element);
    
                }
                else {
    
                    oNextItemSibling = getNextItemSibling(aGroup, (p_nItemIndex+1));
    
                    if (oNextItemSibling && (!oGroupItem.element.parentNode || 
                            oGroupItem.element.parentNode.nodeType == 11)) {
            
                        this._aListElements[nGroupIndex].insertBefore(
                                oGroupItem.element, oNextItemSibling.element);
        
                    }
    
                }
    

                oGroupItem.parent = this;
        
                this._subscribeToItemEvents(oGroupItem);
    
                this._configureSubmenu(oGroupItem);
                
                this._updateItemProperties(nGroupIndex);
        

                this.itemAddedEvent.fire(oGroupItem);
                this.changeContentEvent.fire();

                returnVal = oGroupItem;
    
            }

        }
        else {
    
            nItemIndex = aGroup.length;
    
            aGroup[nItemIndex] = oItem;

            oGroupItem = aGroup[nItemIndex];
    

            if (oGroupItem) {
    
                if (!Dom.isAncestor(this._aListElements[nGroupIndex], oGroupItem.element)) {
    
                    this._aListElements[nGroupIndex].appendChild(oGroupItem.element);
    
                }
    
                oGroupItem.element.setAttribute(_GROUP_INDEX, nGroupIndex);
                oGroupItem.element.setAttribute(_INDEX, nItemIndex);
        
                oGroupItem.parent = this;
    
                oGroupItem.index = nItemIndex;
                oGroupItem.groupIndex = nGroupIndex;
        
                this._subscribeToItemEvents(oGroupItem);
    
                this._configureSubmenu(oGroupItem);
    
                if (nItemIndex === 0) {
        
                    Dom.addClass(oGroupItem.element, _FIRST_OF_TYPE);
        
                }

        

                this.itemAddedEvent.fire(oGroupItem);
                this.changeContentEvent.fire();

                returnVal = oGroupItem;
    
            }
    
        }

    }
    
    return returnVal;
    
},


/**
 * @method _removeItemFromGroupByIndex
 * @description Removes a menu item from a group by index. Returns the menu item
 *              that was removed.
 * @private
 * @param {Number}
 *            p_nGroupIndex Number indicating the group to which the menu item
 *            belongs.
 * @param {Number}
 *            p_nItemIndex Number indicating the index of the menu item to be
 *            removed.
 * @return {YAHOO.widget.MenuItem}
 */
_removeItemFromGroupByIndex: function (p_nGroupIndex, p_nItemIndex) {

    var nGroupIndex = Lang.isNumber(p_nGroupIndex) ? p_nGroupIndex : 0,
        aGroup = this._getItemGroup(nGroupIndex),
        aArray,
        oItem,
        oUL;

    if (aGroup) {

        aArray = aGroup.splice(p_nItemIndex, 1);
        oItem = aArray[0];
    
        if (oItem) {
    
            // Update the index and className properties of each member
            
            this._updateItemProperties(nGroupIndex);
    
            if (aGroup.length === 0) {
    
                // Remove the UL
    
                oUL = this._aListElements[nGroupIndex];
    
                if (oUL && oUL.parentNode) {
                    oUL.parentNode.removeChild(oUL);
                }
    
                // Remove the group from the array of items
    
                this._aItemGroups.splice(nGroupIndex, 1);
    
    
                // Remove the UL from the array of ULs
    
                this._aListElements.splice(nGroupIndex, 1);
    
    
                /*
				 * Assign the "first-of-type" class to the new first UL in the
				 * collection
				 */
    
                oUL = this._aListElements[0];
    
                if (oUL) {
    
                    Dom.addClass(oUL, _FIRST_OF_TYPE);
    
                }            
    
            }
    

            this.itemRemovedEvent.fire(oItem);
            this.changeContentEvent.fire();
    
        }

    }

    // Return a reference to the item that was removed

    return oItem;
    
},


/**
 * @method _removeItemFromGroupByValue
 * @description Removes a menu item from a group by reference. Returns the menu
 *              item that was removed.
 * @private
 * @param {Number}
 *            p_nGroupIndex Number indicating the group to which the menu item
 *            belongs.
 * @param {YAHOO.widget.MenuItem}
 *            p_oItem Object reference for the MenuItem instance to be removed.
 * @return {YAHOO.widget.MenuItem}
 */    
_removeItemFromGroupByValue: function (p_nGroupIndex, p_oItem) {

    var aGroup = this._getItemGroup(p_nGroupIndex),
        nItems,
        nItemIndex,
        returnVal,
        i;

    if (aGroup) {

        nItems = aGroup.length;
        nItemIndex = -1;
    
        if (nItems > 0) {
    
            i = nItems-1;
        
            do {
        
                if (aGroup[i] == p_oItem) {
        
                    nItemIndex = i;
                    break;    
        
                }
        
            }
            while (i--);
        
            if (nItemIndex > -1) {
        
                returnVal = this._removeItemFromGroupByIndex(p_nGroupIndex, nItemIndex);
        
            }
    
        }
    
    }
    
    return returnVal;

},


/**
 * @method _updateItemProperties
 * @description Updates the "index," "groupindex," and "className" properties of
 *              the menu items in the specified group.
 * @private
 * @param {Number}
 *            p_nGroupIndex Number indicating the group of items to update.
 */
_updateItemProperties: function (p_nGroupIndex) {

    var aGroup = this._getItemGroup(p_nGroupIndex),
        nItems = aGroup.length,
        oItem,
        oLI,
        i;


    if (nItems > 0) {

        i = nItems - 1;

        // Update the index and className properties of each member
    
        do {

            oItem = aGroup[i];

            if (oItem) {
    
                oLI = oItem.element;

                oItem.index = i;
                oItem.groupIndex = p_nGroupIndex;

                oLI.setAttribute(_GROUP_INDEX, p_nGroupIndex);
                oLI.setAttribute(_INDEX, i);

                Dom.removeClass(oLI, _FIRST_OF_TYPE);

            }
    
        }
        while (i--);


        if (oLI) {

            Dom.addClass(oLI, _FIRST_OF_TYPE);

        }

    }

},


/**
 * @method _createItemGroup
 * @description Creates a new menu item group (array) and its associated
 *              <code>&#60;ul&#62;</code> element. Returns an aray of menu
 *              item groups.
 * @private
 * @param {Number}
 *            p_nIndex Number indicating the group to create.
 * @return {Array}
 */
_createItemGroup: function (p_nIndex) {

    var oUL,
        returnVal;

    if (!this._aItemGroups[p_nIndex]) {

        this._aItemGroups[p_nIndex] = [];

        oUL = document.createElement(_UL_LOWERCASE);

        this._aListElements[p_nIndex] = oUL;

        returnVal = this._aItemGroups[p_nIndex];

    }
    
    return returnVal;

},


/**
 * @method _getItemGroup
 * @description Returns the menu item group at the specified index.
 * @private
 * @param {Number}
 *            p_nIndex Number indicating the index of the menu item group to be
 *            retrieved.
 * @return {Array}
 */
_getItemGroup: function (p_nIndex) {

    var nIndex = Lang.isNumber(p_nIndex) ? p_nIndex : 0,
        aGroups = this._aItemGroups,
        returnVal;

    if (nIndex in aGroups) {

        returnVal = aGroups[nIndex];

    }
    
    return returnVal;

},


/**
 * @method _configureSubmenu
 * @description Subscribes the menu item's submenu to its parent menu's events.
 * @private
 * @param {YAHOO.widget.MenuItem}
 *            p_oItem Object reference for the MenuItem instance with the
 *            submenu to be configured.
 */
_configureSubmenu: function (p_oItem) {

    var oSubmenu = p_oItem.cfg.getProperty(_SUBMENU);

    if (oSubmenu) {
            
        /*
		 * Listen for configuration changes to the parent menu so they they can
		 * be applied to the submenu.
		 */

        this.cfg.configChangedEvent.subscribe(this._onParentMenuConfigChange, oSubmenu, true);

        this.renderEvent.subscribe(this._onParentMenuRender, oSubmenu, true);

    }

},




/**
 * @method _subscribeToItemEvents
 * @description Subscribes a menu to a menu item's event.
 * @private
 * @param {YAHOO.widget.MenuItem}
 *            p_oItem Object reference for the MenuItem instance whose events
 *            should be subscribed to.
 */
_subscribeToItemEvents: function (p_oItem) {

    p_oItem.destroyEvent.subscribe(this._onMenuItemDestroy, p_oItem, this);
    p_oItem.cfg.configChangedEvent.subscribe(this._onMenuItemConfigChange, p_oItem, this);

},


/**
 * @method _onVisibleChange
 * @description Change event handler for the the menu's "visible" configuration
 *              property.
 * @private
 * @param {String}
 *            p_sType String representing the name of the event that was fired.
 * @param {Array}
 *            p_aArgs Array of arguments sent when the event was fired.
 */
_onVisibleChange: function (p_sType, p_aArgs) {

    var bVisible = p_aArgs[0];
    
    if (bVisible) {

        Dom.addClass(this.element, _VISIBLE);

    }
    else {

        Dom.removeClass(this.element, _VISIBLE);

    }

},


/**
 * @method _cancelHideDelay
 * @description Cancels the call to "hideMenu."
 * @private
 */
_cancelHideDelay: function () {

    var oTimer = this.getRoot()._hideDelayTimer;

    if (oTimer) {

        oTimer.cancel();

    }

},


/**
 * @method _execHideDelay
 * @description Hides the menu after the number of milliseconds specified by the
 *              "hidedelay" configuration property.
 * @private
 */
_execHideDelay: function () {

    this._cancelHideDelay();

    var oRoot = this.getRoot();

    oRoot._hideDelayTimer = Lang.later(oRoot.cfg.getProperty(_HIDE_DELAY), this, function () {
    
        if (oRoot.activeItem) {
            if (oRoot.hasFocus()) {
                oRoot.activeItem.focus();
            }
            oRoot.clearActiveItem();
        }

        if (oRoot == this && !(this instanceof YAHOO.widget.MenuBar) && 
            this.cfg.getProperty(_POSITION) == _DYNAMIC) {
            this.hide();
        }
    });

},


/**
 * @method _cancelShowDelay
 * @description Cancels the call to the "showMenu."
 * @private
 */
_cancelShowDelay: function () {
    var oTimer = this.getRoot()._showDelayTimer;
    if (oTimer) {
        oTimer.cancel();
    }
},


/**
 * @method _execSubmenuHideDelay
 * @description Hides a submenu after the number of milliseconds specified by
 *              the "submenuhidedelay" configuration property have elapsed.
 * @private
 * @param {YAHOO.widget.Menu}
 *            p_oSubmenu Object specifying the submenu that should be hidden.
 * @param {Number}
 *            p_nMouseX The x coordinate of the mouse when it left the specified
 *            submenu's parent menu item.
 * @param {Number}
 *            p_nHideDelay The number of milliseconds that should ellapse before
 *            the submenu is hidden.
 */
_execSubmenuHideDelay: function (p_oSubmenu, p_nMouseX, p_nHideDelay) {

    p_oSubmenu._submenuHideDelayTimer = Lang.later(50, this, function () {

        if (this._nCurrentMouseX > (p_nMouseX + 10)) {

            p_oSubmenu._submenuHideDelayTimer = Lang.later(p_nHideDelay, p_oSubmenu, function () {
        
                this.hide();

            });

        }
        else {

            p_oSubmenu.hide();
        
        }
    
    });

},



// Protected methods


/**
 * @method _disableScrollHeader
 * @description Disables the header used for scrolling the body of the menu.
 * @protected
 */
_disableScrollHeader: function () {

    if (!this._bHeaderDisabled) {

        Dom.addClass(this.header, _TOP_SCROLLBAR_DISABLED);
        this._bHeaderDisabled = true;

    }

},


/**
 * @method _disableScrollFooter
 * @description Disables the footer used for scrolling the body of the menu.
 * @protected
 */
_disableScrollFooter: function () {

    if (!this._bFooterDisabled) {

        Dom.addClass(this.footer, _BOTTOM_SCROLLBAR_DISABLED);
        this._bFooterDisabled = true;

    }

},


/**
 * @method _enableScrollHeader
 * @description Enables the header used for scrolling the body of the menu.
 * @protected
 */
_enableScrollHeader: function () {

    if (this._bHeaderDisabled) {

        Dom.removeClass(this.header, _TOP_SCROLLBAR_DISABLED);
        this._bHeaderDisabled = false;

    }

},


/**
 * @method _enableScrollFooter
 * @description Enables the footer used for scrolling the body of the menu.
 * @protected
 */
_enableScrollFooter: function () {

    if (this._bFooterDisabled) {

        Dom.removeClass(this.footer, _BOTTOM_SCROLLBAR_DISABLED);
        this._bFooterDisabled = false;

    }

},


/**
 * @method _onMouseOver
 * @description "mouseover" event handler for the menu.
 * @protected
 * @param {String}
 *            p_sType String representing the name of the event that was fired.
 * @param {Array}
 *            p_aArgs Array of arguments sent when the event was fired.
 */
_onMouseOver: function (p_sType, p_aArgs) {

    var oEvent = p_aArgs[0],
        oItem = p_aArgs[1],
        oTarget = Event.getTarget(oEvent),
        oRoot = this.getRoot(),
        oSubmenuHideDelayTimer = this._submenuHideDelayTimer,
        oParentMenu,
        nShowDelay,
        bShowDelay,
        oActiveItem,
        oItemCfg,
        oSubmenu;


    var showSubmenu = function () {

        if (this.parent.cfg.getProperty(_SELECTED)) {

            this.show();

        }

    };


    if (!this._bStopMouseEventHandlers) {
    
        if (!this._bHandledMouseOverEvent && (oTarget == this.element || 
                Dom.isAncestor(this.element, oTarget))) {
    
            // Menu mouseover logic

            if (this._useHideDelay) {
                this._cancelHideDelay();
            }
    
            this._nCurrentMouseX = 0;
    
            Event.on(this.element, _MOUSEMOVE, this._onMouseMove, this, true);


            /*
			 * If the mouse is moving from the submenu back to its corresponding
			 * menu item, don't hide the submenu or clear the active MenuItem.
			 */

            if (!(oItem && Dom.isAncestor(oItem.element, Event.getRelatedTarget(oEvent)))) {

                this.clearActiveItem();

            }
    

            if (this.parent && oSubmenuHideDelayTimer) {
    
                oSubmenuHideDelayTimer.cancel();
    
                this.parent.cfg.setProperty(_SELECTED, true);
    
                oParentMenu = this.parent.parent;
    
                oParentMenu._bHandledMouseOutEvent = true;
                oParentMenu._bHandledMouseOverEvent = false;
    
            }
    
    
            this._bHandledMouseOverEvent = true;
            this._bHandledMouseOutEvent = false;
        
        }
    
    
        if (oItem && !oItem.handledMouseOverEvent && !oItem.cfg.getProperty(_DISABLED) && 
            (oTarget == oItem.element || Dom.isAncestor(oItem.element, oTarget))) {
    
            // Menu Item mouseover logic
    
            nShowDelay = this.cfg.getProperty(_SHOW_DELAY);
            bShowDelay = (nShowDelay > 0);
    
    
            if (bShowDelay) {
            
                this._cancelShowDelay();
            
            }
    
    
            oActiveItem = this.activeItem;
        
            if (oActiveItem) {
        
                oActiveItem.cfg.setProperty(_SELECTED, false);
        
            }
    
    
            oItemCfg = oItem.cfg;
        
            // Select and focus the current menu item
        
            oItemCfg.setProperty(_SELECTED, true);
    
    
            if (this.hasFocus() || oRoot._hasFocus) {
            
                oItem.focus();
                
                oRoot._hasFocus = false;
            
            }
    
    
            if (this.cfg.getProperty(_AUTO_SUBMENU_DISPLAY)) {
    
                // Show the submenu this menu item
    
                oSubmenu = oItemCfg.getProperty(_SUBMENU);
            
                if (oSubmenu) {
            
                    if (bShowDelay) {
    
                        oRoot._showDelayTimer = 
                            Lang.later(oRoot.cfg.getProperty(_SHOW_DELAY), oSubmenu, showSubmenu);
            
                    }
                    else {
    
                        oSubmenu.show();
    
                    }
    
                }
    
            }                        
    
            oItem.handledMouseOverEvent = true;
            oItem.handledMouseOutEvent = false;
    
        }
    
    }

},


/**
 * @method _onMouseOut
 * @description "mouseout" event handler for the menu.
 * @protected
 * @param {String}
 *            p_sType String representing the name of the event that was fired.
 * @param {Array}
 *            p_aArgs Array of arguments sent when the event was fired.
 */
_onMouseOut: function (p_sType, p_aArgs) {

    var oEvent = p_aArgs[0],
        oItem = p_aArgs[1],
        oRelatedTarget = Event.getRelatedTarget(oEvent),
        bMovingToSubmenu = false,
        oItemCfg,
        oSubmenu,
        nSubmenuHideDelay,
        nShowDelay;



    if (!this._bStopMouseEventHandlers) {
    
        if (oItem && !oItem.cfg.getProperty(_DISABLED)) {
    
            oItemCfg = oItem.cfg;
            oSubmenu = oItemCfg.getProperty(_SUBMENU);
    
    
            if (oSubmenu && (oRelatedTarget == oSubmenu.element || Dom.isAncestor(oSubmenu.element, oRelatedTarget))) {
                bMovingToSubmenu = true;
            }
    
            if (!oItem.handledMouseOutEvent && ((oRelatedTarget != oItem.element && !Dom.isAncestor(oItem.element, oRelatedTarget)) || bMovingToSubmenu)) {
                if (!bMovingToSubmenu) {
                    oItem.cfg.setProperty(_SELECTED, false);
                    if (oSubmenu) {
                        
                        nSubmenuHideDelay = this.cfg.getProperty(_SUBMENU_HIDE_DELAY);
                        nShowDelay = this.cfg.getProperty(_SHOW_DELAY);
                        if (!(this instanceof YAHOO.widget.MenuBar) && nSubmenuHideDelay > 0 && nSubmenuHideDelay >= nShowDelay) {
                            this._execSubmenuHideDelay(oSubmenu, Event.getPageX(oEvent), nSubmenuHideDelay);
                        } else {
                            oSubmenu.hide();
                        }
                    }
                }
    
                oItem.handledMouseOutEvent = true;
                oItem.handledMouseOverEvent = false;
            }
        }


        if (!this._bHandledMouseOutEvent) {
            if (this._didMouseLeave(oRelatedTarget) || bMovingToSubmenu) {
                // Menu mouseout logic
                if (this._useHideDelay) {
                    this._execHideDelay();
                }
    
                Event.removeListener(this.element, _MOUSEMOVE, this._onMouseMove);
        
                this._nCurrentMouseX = Event.getPageX(oEvent);
        
                this._bHandledMouseOutEvent = true;
                this._bHandledMouseOverEvent = false;
            }
        }
    }

},

/**
 * Utilility method to determine if we really moused out of the menu based on
 * the related target
 * 
 * @method _didMouseLeave
 * @protected
 * @param {HTMLElement}
 *            oRelatedTarget The related target based on which we're making the
 *            decision
 * @return {boolean} true if it's OK to hide based on the related target.
 */
_didMouseLeave : function(oRelatedTarget) {
    // Hide if we're not moving back to the element from somewhere inside the
	// element, or we're moving to an element inside the menu.
    // The shadow is treated as an edge case, inside inside the menu, but we get
	// no further mouseouts, because it overflows the element,
    // so we need to close when moving to the menu.
    return (oRelatedTarget === this._shadow || (oRelatedTarget != this.element && !Dom.isAncestor(this.element, oRelatedTarget)));
},

/**
 * @method _onMouseMove
 * @description "click" event handler for the menu.
 * @protected
 * @param {Event}
 *            p_oEvent Object representing the DOM event object passed back by
 *            the event utility (YAHOO.util.Event).
 * @param {YAHOO.widget.Menu}
 *            p_oMenu Object representing the menu that fired the event.
 */
_onMouseMove: function (p_oEvent, p_oMenu) {

    if (!this._bStopMouseEventHandlers) {
    
        this._nCurrentMouseX = Event.getPageX(p_oEvent);
    
    }

},


/**
 * @method _onClick
 * @description "click" event handler for the menu.
 * @protected
 * @param {String}
 *            p_sType String representing the name of the event that was fired.
 * @param {Array}
 *            p_aArgs Array of arguments sent when the event was fired.
 */
_onClick: function (p_sType, p_aArgs) {

    var oEvent = p_aArgs[0],
        oItem = p_aArgs[1],
        bInMenuAnchor = false,
        oSubmenu,
        oMenu,
        oRoot,
        sId,
        sURL,
        nHashPos,
        nLen;


    var hide = function () {
        
        oRoot = this.getRoot();

        if (oRoot instanceof YAHOO.widget.MenuBar || 
            oRoot.cfg.getProperty(_POSITION) == _STATIC) {

            oRoot.clearActiveItem();

        }
        else {

            oRoot.hide();
        
        }
    
    };


    if (oItem) {
    
        if (oItem.cfg.getProperty(_DISABLED)) {
        
            Event.preventDefault(oEvent);

            hide.call(this);

        }
        else {

            oSubmenu = oItem.cfg.getProperty(_SUBMENU);
    
            
            /*
			 * Check if the URL of the anchor is pointing to an element that is
			 * a child of the menu.
			 */
            
            sURL = oItem.cfg.getProperty(_URL);

        
            if (sURL) {
    
                nHashPos = sURL.indexOf(_HASH);
    
                nLen = sURL.length;
    
    
                if (nHashPos != -1) {
    
                    sURL = sURL.substr(nHashPos, nLen);
        
                    nLen = sURL.length;
    
    
                    if (nLen > 1) {
    
                        sId = sURL.substr(1, nLen);
    
                        oMenu = YAHOO.widget.MenuManager.getMenu(sId);
                        
                        if (oMenu) {

                            bInMenuAnchor = 
                                (this.getRoot() === oMenu.getRoot());

                        }
                        
                    }
                    else if (nLen === 1) {
    
                        bInMenuAnchor = true;
                    
                    }
    
                }
            
            }

    
            if (bInMenuAnchor && !oItem.cfg.getProperty(_TARGET)) {
    
                Event.preventDefault(oEvent);
                

                if (UA.webkit) {
                
                    oItem.focus();
                
                }
                else {

                    oItem.focusEvent.fire();
                
                }
            
            }
    
    
            if (!oSubmenu && !this.cfg.getProperty(_KEEP_OPEN)) {
    
                hide.call(this);
    
            }
            
        }
    
    }

},

/*
 * This function is called to prevent a bug in Firefox. In Firefox, moving a DOM
 * element into a stationary mouse pointer will cause the browser to fire mouse
 * events. This can result in the menu mouse event handlers being called
 * uncessarily, especially when menus are moved into a stationary mouse pointer
 * as a result of a key event handler.
 */
/**
 * Utility method to stop mouseevents from being fired if the DOM changes under
 * a stationary mouse pointer (as opposed to the mouse moving over a DOM
 * element).
 * 
 * @method _stopMouseEventHandlers
 * @private
 */
_stopMouseEventHandlers: function() {
    this._bStopMouseEventHandlers = true;

    Lang.later(10, this, function () {
        this._bStopMouseEventHandlers = false;
    });
},

/**
 * @method _onKeyDown
 * @description "keydown" event handler for the menu.
 * @protected
 * @param {String}
 *            p_sType String representing the name of the event that was fired.
 * @param {Array}
 *            p_aArgs Array of arguments sent when the event was fired.
 */
_onKeyDown: function (p_sType, p_aArgs) {

    var oEvent = p_aArgs[0],
        oItem = p_aArgs[1],
        oSubmenu,
        oItemCfg,
        oParentItem,
        oRoot,
        oNextItem,
        oBody,
        nBodyScrollTop,
        nBodyOffsetHeight,
        aItems,
        nItems,
        nNextItemOffsetTop,
        nScrollTarget,
        oParentMenu,
        oFocusedEl;


    if (this._useHideDelay) {
        this._cancelHideDelay();
    }

    if (oItem && !oItem.cfg.getProperty(_DISABLED)) {

        oItemCfg = oItem.cfg;
        oParentItem = this.parent;

        switch(oEvent.keyCode) {
    
            case 38:    // Up arrow
            case 40:    // Down arrow
    
                oNextItem = (oEvent.keyCode == 38) ? 
                    oItem.getPreviousEnabledSibling() : 
                    oItem.getNextEnabledSibling();
        
                if (oNextItem) {

                    this.clearActiveItem();

                    oNextItem.cfg.setProperty(_SELECTED, true);
                    oNextItem.focus();

                    if (this.cfg.getProperty(_MAX_HEIGHT) > 0 || Dom.hasClass(this.body, _YUI_MENU_BODY_SCROLLED)) {

                        oBody = this.body;
                        nBodyScrollTop = oBody.scrollTop;
                        nBodyOffsetHeight = oBody.offsetHeight;
                        aItems = this.getItems();
                        nItems = aItems.length - 1;
                        nNextItemOffsetTop = oNextItem.element.offsetTop;


                        if (oEvent.keyCode == 40 ) {    // Down
                       
                            if (nNextItemOffsetTop >= (nBodyOffsetHeight + nBodyScrollTop)) {

                                oBody.scrollTop = nNextItemOffsetTop - nBodyOffsetHeight;

                            }
                            else if (nNextItemOffsetTop <= nBodyScrollTop) {
                            
                                oBody.scrollTop = 0;
                            
                            }


                            if (oNextItem == aItems[nItems]) {

                                oBody.scrollTop = oNextItem.element.offsetTop;

                            }

                        }
                        else {  // Up

                            if (nNextItemOffsetTop <= nBodyScrollTop) {

                                oBody.scrollTop = nNextItemOffsetTop - oNextItem.element.offsetHeight;
                            
                            }
                            else if (nNextItemOffsetTop >= (nBodyScrollTop + nBodyOffsetHeight)) {
                            
                                oBody.scrollTop = nNextItemOffsetTop;
                            
                            }


                            if (oNextItem == aItems[0]) {
                            
                                oBody.scrollTop = 0;
                            
                            }

                        }


                        nBodyScrollTop = oBody.scrollTop;
                        nScrollTarget = oBody.scrollHeight - oBody.offsetHeight;

                        if (nBodyScrollTop === 0) {

                            this._disableScrollHeader();
                            this._enableScrollFooter();

                        }
                        else if (nBodyScrollTop == nScrollTarget) {

                             this._enableScrollHeader();
                             this._disableScrollFooter();

                        }
                        else {

                            this._enableScrollHeader();
                            this._enableScrollFooter();

                        }

                    }

                }

    
                Event.preventDefault(oEvent);

                this._stopMouseEventHandlers();
    
            break;
            
    
            case 39:    // Right arrow
    
                oSubmenu = oItemCfg.getProperty(_SUBMENU);
    
                if (oSubmenu) {
    
                    if (!oItemCfg.getProperty(_SELECTED)) {
        
                        oItemCfg.setProperty(_SELECTED, true);
        
                    }
    
                    oSubmenu.show();
                    oSubmenu.setInitialFocus();
                    oSubmenu.setInitialSelection();
    
                }
                else {
    
                    oRoot = this.getRoot();
                    
                    if (oRoot instanceof YAHOO.widget.MenuBar) {
    
                        oNextItem = oRoot.activeItem.getNextEnabledSibling();
    
                        if (oNextItem) {
                        
                            oRoot.clearActiveItem();
    
                            oNextItem.cfg.setProperty(_SELECTED, true);
    
                            oSubmenu = oNextItem.cfg.getProperty(_SUBMENU);
    
                            if (oSubmenu) {
    
                                oSubmenu.show();
                                oSubmenu.setInitialFocus();
                            
                            }
                            else {
    
                                oNextItem.focus();
                            
                            }
                        
                        }
                    
                    }
                
                }
    
    
                Event.preventDefault(oEvent);

                this._stopMouseEventHandlers();

            break;
    
    
            case 37:    // Left arrow
    
                if (oParentItem) {
    
                    oParentMenu = oParentItem.parent;
    
                    if (oParentMenu instanceof YAHOO.widget.MenuBar) {
    
                        oNextItem = 
                            oParentMenu.activeItem.getPreviousEnabledSibling();
    
                        if (oNextItem) {
                        
                            oParentMenu.clearActiveItem();
    
                            oNextItem.cfg.setProperty(_SELECTED, true);
    
                            oSubmenu = oNextItem.cfg.getProperty(_SUBMENU);
    
                            if (oSubmenu) {
                            
                                oSubmenu.show();
                                oSubmenu.setInitialFocus();
                            
                            }
                            else {
    
                                oNextItem.focus();
                            
                            }
                        
                        } 
                    
                    }
                    else {
    
                        this.hide();
    
                        oParentItem.focus();
                    
                    }
    
                }
    
                Event.preventDefault(oEvent);

                this._stopMouseEventHandlers();

            break;        
    
        }


    }


    if (oEvent.keyCode == 27) { // Esc key

        if (this.cfg.getProperty(_POSITION) == _DYNAMIC) {
        
            this.hide();

            if (this.parent) {

                this.parent.focus();
            
            }
            else {
                // Focus the element that previously had focus

                oFocusedEl = this._focusedElement;

                if (oFocusedEl && oFocusedEl.focus) {

                    try {
                        oFocusedEl.focus();
                    }
                    catch(ex) {
                    }

                }
                
            }

        }
        else if (this.activeItem) {

            oSubmenu = this.activeItem.cfg.getProperty(_SUBMENU);

            if (oSubmenu && oSubmenu.cfg.getProperty(_VISIBLE)) {
            
                oSubmenu.hide();
                this.activeItem.focus();
            
            }
            else {

                this.activeItem.blur();
                this.activeItem.cfg.setProperty(_SELECTED, false);
        
            }
        
        }


        Event.preventDefault(oEvent);
    
    }
    
},


/**
 * @method _onKeyPress
 * @description "keypress" event handler for a Menu instance.
 * @protected
 * @param {String}
 *            p_sType The name of the event that was fired.
 * @param {Array}
 *            p_aArgs Collection of arguments sent when the event was fired.
 */
_onKeyPress: function (p_sType, p_aArgs) {
    
    var oEvent = p_aArgs[0];


    if (oEvent.keyCode == 40 || oEvent.keyCode == 38) {

        Event.preventDefault(oEvent);

    }

},


/**
 * @method _onBlur
 * @description "blur" event handler for a Menu instance.
 * @protected
 * @param {String}
 *            p_sType The name of the event that was fired.
 * @param {Array}
 *            p_aArgs Collection of arguments sent when the event was fired.
 */
_onBlur: function (p_sType, p_aArgs) {
        
    if (this._hasFocus) {
        this._hasFocus = false;
    }

},

/**
 * @method _onYChange
 * @description "y" event handler for a Menu instance.
 * @protected
 * @param {String}
 *            p_sType The name of the event that was fired.
 * @param {Array}
 *            p_aArgs Collection of arguments sent when the event was fired.
 */
_onYChange: function (p_sType, p_aArgs) {

    var oParent = this.parent,
        nScrollTop,
        oIFrame,
        nY;


    if (oParent) {

        nScrollTop = oParent.parent.body.scrollTop;


        if (nScrollTop > 0) {
    
            nY = (this.cfg.getProperty(_Y) - nScrollTop);
            
            Dom.setY(this.element, nY);

            oIFrame = this.iframe;            
    

            if (oIFrame) {
    
                Dom.setY(oIFrame, nY);
    
            }
            
            this.cfg.setProperty(_Y, nY, true);
        
        }
    
    }

},


/**
 * @method _onScrollTargetMouseOver
 * @description "mouseover" event handler for the menu's "header" and "footer"
 *              elements. Used to scroll the body of the menu up and down when
 *              the menu's "maxheight" configuration property is set to a value
 *              greater than 0.
 * @protected
 * @param {Event}
 *            p_oEvent Object representing the DOM event object passed back by
 *            the event utility (YAHOO.util.Event).
 * @param {YAHOO.widget.Menu}
 *            p_oMenu Object representing the menu that fired the event.
 */
_onScrollTargetMouseOver: function (p_oEvent, p_oMenu) {

    var oBodyScrollTimer = this._bodyScrollTimer;


    if (oBodyScrollTimer) {

        oBodyScrollTimer.cancel();

    }


    this._cancelHideDelay();


    var oTarget = Event.getTarget(p_oEvent),
        oBody = this.body,
        nScrollIncrement = this.cfg.getProperty(_SCROLL_INCREMENT),
        nScrollTarget,
        fnScrollFunction;


    function scrollBodyDown() {

        var nScrollTop = oBody.scrollTop;


        if (nScrollTop < nScrollTarget) {

            oBody.scrollTop = (nScrollTop + nScrollIncrement);

            this._enableScrollHeader();

        }
        else {

            oBody.scrollTop = nScrollTarget;

            this._bodyScrollTimer.cancel();

            this._disableScrollFooter();

        }

    }


    function scrollBodyUp() {

        var nScrollTop = oBody.scrollTop;


        if (nScrollTop > 0) {

            oBody.scrollTop = (nScrollTop - nScrollIncrement);

            this._enableScrollFooter();

        }
        else {

            oBody.scrollTop = 0;

            this._bodyScrollTimer.cancel();

            this._disableScrollHeader();

        }

    }

    
    if (Dom.hasClass(oTarget, _HD)) {

        fnScrollFunction = scrollBodyUp;
    
    }
    else {

        nScrollTarget = oBody.scrollHeight - oBody.offsetHeight;

        fnScrollFunction = scrollBodyDown;
    
    }
    

    this._bodyScrollTimer = Lang.later(10, this, fnScrollFunction, null, true);

},


/**
 * @method _onScrollTargetMouseOut
 * @description "mouseout" event handler for the menu's "header" and "footer"
 *              elements. Used to stop scrolling the body of the menu up and
 *              down when the menu's "maxheight" configuration property is set
 *              to a value greater than 0.
 * @protected
 * @param {Event}
 *            p_oEvent Object representing the DOM event object passed back by
 *            the event utility (YAHOO.util.Event).
 * @param {YAHOO.widget.Menu}
 *            p_oMenu Object representing the menu that fired the event.
 */
_onScrollTargetMouseOut: function (p_oEvent, p_oMenu) {

    var oBodyScrollTimer = this._bodyScrollTimer;

    if (oBodyScrollTimer) {

        oBodyScrollTimer.cancel();

    }
    
    this._cancelHideDelay();

},



// Private methods


/**
 * @method _onInit
 * @description "init" event handler for the menu.
 * @private
 * @param {String}
 *            p_sType String representing the name of the event that was fired.
 * @param {Array}
 *            p_aArgs Array of arguments sent when the event was fired.
 */
_onInit: function (p_sType, p_aArgs) {

    this.cfg.subscribeToConfigEvent(_VISIBLE, this._onVisibleChange);

    var bRootMenu = !this.parent,
        bLazyLoad = this.lazyLoad;


    /*
	 * Automatically initialize a menu's subtree if:
	 * 
	 * 1) This is the root menu and lazyload is off
	 * 
	 * 2) This is the root menu, lazyload is on, but the menu is already visible
	 * 
	 * 3) This menu is a submenu and lazyload is off
	 */



    if (((bRootMenu && !bLazyLoad) || 
        (bRootMenu && (this.cfg.getProperty(_VISIBLE) || 
        this.cfg.getProperty(_POSITION) == _STATIC)) || 
        (!bRootMenu && !bLazyLoad)) && this.getItemGroups().length === 0) {

        if (this.srcElement) {

            this._initSubTree();
        
        }


        if (this.itemData) {

            this.addItems(this.itemData);

        }
    
    }
    else if (bLazyLoad) {

        this.cfg.fireQueue();
    
    }

},


/**
 * @method _onBeforeRender
 * @description "beforerender" event handler for the menu. Appends all of the
 *              <code>&#60;ul&#62;</code>, <code>&#60;li&#62;</code> and
 *              their accompanying title elements to the body element of the
 *              menu.
 * @private
 * @param {String}
 *            p_sType String representing the name of the event that was fired.
 * @param {Array}
 *            p_aArgs Array of arguments sent when the event was fired.
 */
_onBeforeRender: function (p_sType, p_aArgs) {

    var oEl = this.element,
        nListElements = this._aListElements.length,
        bFirstList = true,
        i = 0,
        oUL,
        oGroupTitle;

    if (nListElements > 0) {

        do {

            oUL = this._aListElements[i];

            if (oUL) {

                if (bFirstList) {
        
                    Dom.addClass(oUL, _FIRST_OF_TYPE);
                    bFirstList = false;
        
                }


                if (!Dom.isAncestor(oEl, oUL)) {

                    this.appendToBody(oUL);

                }


                oGroupTitle = this._aGroupTitleElements[i];

                if (oGroupTitle) {

                    if (!Dom.isAncestor(oEl, oGroupTitle)) {

                        oUL.parentNode.insertBefore(oGroupTitle, oUL);

                    }


                    Dom.addClass(oUL, _HAS_TITLE);

                }

            }

            i++;

        }
        while (i < nListElements);

    }

},


/**
 * @method _onRender
 * @description "render" event handler for the menu.
 * @private
 * @param {String}
 *            p_sType String representing the name of the event that was fired.
 * @param {Array}
 *            p_aArgs Array of arguments sent when the event was fired.
 */
_onRender: function (p_sType, p_aArgs) {

    if (this.cfg.getProperty(_POSITION) == _DYNAMIC) { 

        if (!this.cfg.getProperty(_VISIBLE)) {

            this.positionOffScreen();

        }
    
    }

},





/**
 * @method _onBeforeShow
 * @description "beforeshow" event handler for the menu.
 * @private
 * @param {String}
 *            p_sType String representing the name of the event that was fired.
 * @param {Array}
 *            p_aArgs Array of arguments sent when the event was fired.
 */
_onBeforeShow: function (p_sType, p_aArgs) {

    var nOptions,
        n,
        oSrcElement,
        oContainer = this.cfg.getProperty(_CONTAINER);


    if (this.lazyLoad && this.getItemGroups().length === 0) {

        if (this.srcElement) {
        
            this._initSubTree();

        }


        if (this.itemData) {

            if (this.parent && this.parent.parent && 
                this.parent.parent.srcElement && 
                this.parent.parent.srcElement.tagName.toUpperCase() == 
                _SELECT) {

                nOptions = this.itemData.length;
    
                for(n=0; n<nOptions; n++) {

                    if (this.itemData[n].tagName) {

                        this.addItem((new this.ITEM_TYPE(this.itemData[n])));
    
                    }
    
                }
            
            }
            else {

                this.addItems(this.itemData);
            
            }
        
        }


        oSrcElement = this.srcElement;

        if (oSrcElement) {

            if (oSrcElement.tagName.toUpperCase() == _SELECT) {

                if (Dom.inDocument(oSrcElement)) {

                    this.render(oSrcElement.parentNode);
                
                }
                else {
                
                    this.render(oContainer);
                
                }

            }
            else {

                this.render();

            }

        }
        else {

            if (this.parent) {

                this.render(this.parent.element);     

            }
            else {

                this.render(oContainer);

            }                

        }

    }



    var oParent = this.parent,
        aAlignment;


    if (!oParent && this.cfg.getProperty(_POSITION) == _DYNAMIC) {

        this.cfg.refireEvent(_XY);
   
    }


    if (oParent) {

        aAlignment = oParent.parent.cfg.getProperty(_SUBMENU_ALIGNMENT);
        
        this.cfg.setProperty(_CONTEXT, [oParent.element, aAlignment[0], aAlignment[1]]);
        this.align();
    
    }

},


getConstrainedY: function (y) {

    var oMenu = this,
    
        aContext = oMenu.cfg.getProperty(_CONTEXT),
        nInitialMaxHeight = oMenu.cfg.getProperty(_MAX_HEIGHT),

        nMaxHeight,

        oOverlapPositions = {

            "trbr": true,
            "tlbl": true,
            "bltl": true,
            "brtr": true

        },

        bPotentialContextOverlap = (aContext && oOverlapPositions[aContext[1] + aContext[2]]),
    
        oMenuEl = oMenu.element,
        nMenuOffsetHeight = oMenuEl.offsetHeight,
    
        nViewportOffset = Overlay.VIEWPORT_OFFSET,
        viewPortHeight = Dom.getViewportHeight(),
        scrollY = Dom.getDocumentScrollTop(),

        bCanConstrain = 
            (oMenu.cfg.getProperty(_MIN_SCROLL_HEIGHT) + nViewportOffset < viewPortHeight),

        nAvailableHeight,

        oContextEl,
        nContextElY,
        nContextElHeight,

        bFlipped = false,

        nTopRegionHeight,
        nBottomRegionHeight,

        topConstraint = scrollY + nViewportOffset,
        bottomConstraint = scrollY + viewPortHeight - nMenuOffsetHeight - nViewportOffset,

        yNew = y;
        

    var flipVertical = function () {

        var nNewY;
    
        // The Menu is below the context element, flip it above
        if ((oMenu.cfg.getProperty(_Y) - scrollY) > nContextElY) { 
            nNewY = (nContextElY - nMenuOffsetHeight);
        }
        else {	// The Menu is above the context element, flip it below
            nNewY = (nContextElY + nContextElHeight);
        }

        oMenu.cfg.setProperty(_Y, (nNewY + scrollY), true);
        
        return nNewY;
    
    };


    /*
	 * Uses the context element's position to calculate the availble height
	 * above and below it to display its corresponding Menu.
	 */

    var getDisplayRegionHeight = function () {

        // The Menu is below the context element
        if ((oMenu.cfg.getProperty(_Y) - scrollY) > nContextElY) {
            return (nBottomRegionHeight - nViewportOffset);				
        }
        else {	// The Menu is above the context element
            return (nTopRegionHeight - nViewportOffset);				
        }

    };


    /*
	 * Sets the Menu's "y" configuration property to the correct value based on
	 * its current orientation.
	 */ 

    var alignY = function () {

        var nNewY;

        if ((oMenu.cfg.getProperty(_Y) - scrollY) > nContextElY) { 
            nNewY = (nContextElY + nContextElHeight);
        }
        else {	
            nNewY = (nContextElY - oMenuEl.offsetHeight);
        }

        oMenu.cfg.setProperty(_Y, (nNewY + scrollY), true);
    
    };


    // Resets the maxheight of the Menu to the value set by the user

    var resetMaxHeight = function () {

        oMenu._setScrollHeight(this.cfg.getProperty(_MAX_HEIGHT));

        oMenu.hideEvent.unsubscribe(resetMaxHeight);
    
    };


    /*
	 * Trys to place the Menu in the best possible position (either above or
	 * below its corresponding context element).
	 */

    var setVerticalPosition = function () {

        var nDisplayRegionHeight = getDisplayRegionHeight(),
            bMenuHasItems = (oMenu.getItems().length > 0),
            nMenuMinScrollHeight,
            fnReturnVal;


        if (nMenuOffsetHeight > nDisplayRegionHeight) {

            nMenuMinScrollHeight = 
                bMenuHasItems ? oMenu.cfg.getProperty(_MIN_SCROLL_HEIGHT) : nMenuOffsetHeight;


            if ((nDisplayRegionHeight > nMenuMinScrollHeight) && bMenuHasItems) {
                nMaxHeight = nDisplayRegionHeight;
            }
            else {
                nMaxHeight = nInitialMaxHeight;
            }


            oMenu._setScrollHeight(nMaxHeight);
            oMenu.hideEvent.subscribe(resetMaxHeight);
            

            // Re-align the Menu since its height has just changed
            // as a result of the setting of the maxheight property.

            alignY();
            

            if (nDisplayRegionHeight < nMenuMinScrollHeight) {

                if (bFlipped) {
    
                    /*
					 * All possible positions and values for the "maxheight"
					 * configuration property have been tried, but none were
					 * successful, so fall back to the original size and
					 * position.
					 */

                    flipVertical();
                    
                }
                else {
    
                    flipVertical();

                    bFlipped = true;
    
                    fnReturnVal = setVerticalPosition();
    
                }
                
            }
        
        }
        else if (nMaxHeight && (nMaxHeight !== nInitialMaxHeight)) {
        
            oMenu._setScrollHeight(nInitialMaxHeight);
            oMenu.hideEvent.subscribe(resetMaxHeight);

            // Re-align the Menu since its height has just changed
            // as a result of the setting of the maxheight property.

            alignY();
        
        }

        return fnReturnVal;

    };


    // Determine if the current value for the Menu's "y" configuration property
	// will
    // result in the Menu being positioned outside the boundaries of the
	// viewport

    if (y < topConstraint || y  > bottomConstraint) {

        // The current value for the Menu's "y" configuration property WILL
        // result in the Menu being positioned outside the boundaries of the
		// viewport

        if (bCanConstrain) {

            if (oMenu.cfg.getProperty(_PREVENT_CONTEXT_OVERLAP) && bPotentialContextOverlap) {
        
                // SOLUTION #1:
                // If the "preventcontextoverlap" configuration property is set
				// to "true",
                // try to flip and/or scroll the Menu to both keep it inside the
				// boundaries of the
                // viewport AND from overlaping its context element (MenuItem or
				// MenuBarItem).

                oContextEl = aContext[0];
                nContextElHeight = oContextEl.offsetHeight;
                nContextElY = (Dom.getY(oContextEl) - scrollY);
    
                nTopRegionHeight = nContextElY;
                nBottomRegionHeight = (viewPortHeight - (nContextElY + nContextElHeight));
    
                setVerticalPosition();
                
                yNew = oMenu.cfg.getProperty(_Y);
        
            }
            else if (!(oMenu instanceof YAHOO.widget.MenuBar) && 
                nMenuOffsetHeight >= viewPortHeight) {

                // SOLUTION #2:
                // If the Menu exceeds the height of the viewport, introduce
				// scroll bars
                // to keep the Menu inside the boundaries of the viewport

                nAvailableHeight = (viewPortHeight - (nViewportOffset * 2));
        
                if (nAvailableHeight > oMenu.cfg.getProperty(_MIN_SCROLL_HEIGHT)) {
        
                    oMenu._setScrollHeight(nAvailableHeight);
                    oMenu.hideEvent.subscribe(resetMaxHeight);
        
                    alignY();
                    
                    yNew = oMenu.cfg.getProperty(_Y);
                
                }
        
            }	
            else {

                // SOLUTION #3:
            
                if (y < topConstraint) {
                    yNew  = topConstraint;
                } else if (y  > bottomConstraint) {
                    yNew  = bottomConstraint;
                }				
            
            }

        }
        else {
            // The "y" configuration property cannot be set to a value that will
			// keep
            // entire Menu inside the boundary of the viewport. Therefore, set
            // the "y" configuration property to scrollY to keep as much of the
            // Menu inside the viewport as possible.
            yNew = nViewportOffset + scrollY;
        }	

    }

    return yNew;

},


/**
 * @method _onHide
 * @description "hide" event handler for the menu.
 * @private
 * @param {String}
 *            p_sType String representing the name of the event that was fired.
 * @param {Array}
 *            p_aArgs Array of arguments sent when the event was fired.
 */
_onHide: function (p_sType, p_aArgs) {

    if (this.cfg.getProperty(_POSITION) === _DYNAMIC) {
    
        this.positionOffScreen();
    
    }

},


/**
 * @method _onShow
 * @description "show" event handler for the menu.
 * @private
 * @param {String}
 *            p_sType String representing the name of the event that was fired.
 * @param {Array}
 *            p_aArgs Array of arguments sent when the event was fired.
 */
_onShow: function (p_sType, p_aArgs) {

    var oParent = this.parent,
        oParentMenu,
        oElement,
        nOffsetWidth,
        sWidth;        


    function disableAutoSubmenuDisplay(p_oEvent) {

        var oTarget;

        if (p_oEvent.type == _MOUSEDOWN || (p_oEvent.type == _KEYDOWN && p_oEvent.keyCode == 27)) {

            /*
			 * Set the "autosubmenudisplay" to "false" if the user clicks
			 * outside the menu bar.
			 */

            oTarget = Event.getTarget(p_oEvent);

            if (oTarget != oParentMenu.element || !Dom.isAncestor(oParentMenu.element, oTarget)) {

                oParentMenu.cfg.setProperty(_AUTO_SUBMENU_DISPLAY, false);

                Event.removeListener(document, _MOUSEDOWN, disableAutoSubmenuDisplay);
                Event.removeListener(document, _KEYDOWN, disableAutoSubmenuDisplay);

            }
        
        }

    }


    function onSubmenuHide(p_sType, p_aArgs, p_sWidth) {
    
        this.cfg.setProperty(_WIDTH, _EMPTY_STRING);
        this.hideEvent.unsubscribe(onSubmenuHide, p_sWidth);
    
    }


    if (oParent) {

        oParentMenu = oParent.parent;


        if (!oParentMenu.cfg.getProperty(_AUTO_SUBMENU_DISPLAY) && 
            (oParentMenu instanceof YAHOO.widget.MenuBar || 
            oParentMenu.cfg.getProperty(_POSITION) == _STATIC)) {

            oParentMenu.cfg.setProperty(_AUTO_SUBMENU_DISPLAY, true);

            Event.on(document, _MOUSEDOWN, disableAutoSubmenuDisplay);                             
            Event.on(document, _KEYDOWN, disableAutoSubmenuDisplay);

        }


        // The following fixes an issue with the selected state of a MenuItem
        // not rendering correctly when a submenu is aligned to the left of
        // its parent Menu instance.

        if ((this.cfg.getProperty("x") < oParentMenu.cfg.getProperty("x")) && 
            (UA.gecko && UA.gecko < 1.9) && !this.cfg.getProperty(_WIDTH)) {

            oElement = this.element;
            nOffsetWidth = oElement.offsetWidth;
            
            /*
			 * Measuring the difference of the offsetWidth before and after
			 * setting the "width" style attribute allows us to compute the
			 * about of padding and borders applied to the element, which in
			 * turn allows us to set the "width" property correctly.
			 */
            
            oElement.style.width = nOffsetWidth + _PX;
            
            sWidth = (nOffsetWidth - (oElement.offsetWidth - nOffsetWidth)) + _PX;
            
            this.cfg.setProperty(_WIDTH, sWidth);
        
            this.hideEvent.subscribe(onSubmenuHide, sWidth);
        
        }

    }


    /*
	 * Dynamically positioned, root Menus focus themselves when visible, and
	 * will then, when hidden, restore focus to the UI control that had focus
	 * before the Menu was made visible.
	 */ 

    if (this === this.getRoot() && this.cfg.getProperty(_POSITION) === _DYNAMIC) {

        this._focusedElement = oFocusedElement;
        
        this.focus();
    
    }


},


/**
 * @method _onBeforeHide
 * @description "beforehide" event handler for the menu.
 * @private
 * @param {String}
 *            p_sType String representing the name of the event that was fired.
 * @param {Array}
 *            p_aArgs Array of arguments sent when the event was fired.
 */
_onBeforeHide: function (p_sType, p_aArgs) {

    var oActiveItem = this.activeItem,
        oRoot = this.getRoot(),
        oConfig,
        oSubmenu;


    if (oActiveItem) {

        oConfig = oActiveItem.cfg;

        oConfig.setProperty(_SELECTED, false);

        oSubmenu = oConfig.getProperty(_SUBMENU);

        if (oSubmenu) {

            oSubmenu.hide();

        }

    }


    /*
	 * Focus can get lost in IE when the mouse is moving from a submenu back to
	 * its parent Menu. For this reason, it is necessary to maintain the focused
	 * state in a private property so that the _onMouseOver event handler is
	 * able to determined whether or not to set focus to MenuItems as the user
	 * is moving the mouse.
	 */ 

    if (UA.ie && this.cfg.getProperty(_POSITION) === _DYNAMIC && this.parent) {

        oRoot._hasFocus = this.hasFocus();
    
    }


    if (oRoot == this) {

        oRoot.blur();
    
    }

},


/**
 * @method _onParentMenuConfigChange
 * @description "configchange" event handler for a submenu.
 * @private
 * @param {String}
 *            p_sType String representing the name of the event that was fired.
 * @param {Array}
 *            p_aArgs Array of arguments sent when the event was fired.
 * @param {YAHOO.widget.Menu}
 *            p_oSubmenu Object representing the submenu that subscribed to the
 *            event.
 */
_onParentMenuConfigChange: function (p_sType, p_aArgs, p_oSubmenu) {
    
    var sPropertyName = p_aArgs[0][0],
        oPropertyValue = p_aArgs[0][1];

    switch(sPropertyName) {

        case _IFRAME:
        case _CONSTRAIN_TO_VIEWPORT:
        case _HIDE_DELAY:
        case _SHOW_DELAY:
        case _SUBMENU_HIDE_DELAY:
        case _CLICK_TO_HIDE:
        case _EFFECT:
        case _CLASSNAME:
        case _SCROLL_INCREMENT:
        case _MAX_HEIGHT:
        case _MIN_SCROLL_HEIGHT:
        case _MONITOR_RESIZE:
        case _SHADOW:
        case _PREVENT_CONTEXT_OVERLAP:
        case _KEEP_OPEN:

            p_oSubmenu.cfg.setProperty(sPropertyName, oPropertyValue);
                
        break;
        
        case _SUBMENU_ALIGNMENT:

            if (!(this.parent.parent instanceof YAHOO.widget.MenuBar)) {
        
                p_oSubmenu.cfg.setProperty(sPropertyName, oPropertyValue);
        
            }
        
        break;
        
    }
    
},


/**
 * @method _onParentMenuRender
 * @description "render" event handler for a submenu. Renders a submenu in
 *              response to the firing of its parent's "render" event.
 * @private
 * @param {String}
 *            p_sType String representing the name of the event that was fired.
 * @param {Array}
 *            p_aArgs Array of arguments sent when the event was fired.
 * @param {YAHOO.widget.Menu}
 *            p_oSubmenu Object representing the submenu that subscribed to the
 *            event.
 */
_onParentMenuRender: function (p_sType, p_aArgs, p_oSubmenu) {

    var oParentMenu = p_oSubmenu.parent.parent,
        oParentCfg = oParentMenu.cfg,

        oConfig = {

            constraintoviewport: oParentCfg.getProperty(_CONSTRAIN_TO_VIEWPORT),

            xy: [0,0],

            clicktohide: oParentCfg.getProperty(_CLICK_TO_HIDE),
                
            effect: oParentCfg.getProperty(_EFFECT),

            showdelay: oParentCfg.getProperty(_SHOW_DELAY),
            
            hidedelay: oParentCfg.getProperty(_HIDE_DELAY),

            submenuhidedelay: oParentCfg.getProperty(_SUBMENU_HIDE_DELAY),

            classname: oParentCfg.getProperty(_CLASSNAME),
            
            scrollincrement: oParentCfg.getProperty(_SCROLL_INCREMENT),
            
            maxheight: oParentCfg.getProperty(_MAX_HEIGHT),

            minscrollheight: oParentCfg.getProperty(_MIN_SCROLL_HEIGHT),
            
            iframe: oParentCfg.getProperty(_IFRAME),
            
            shadow: oParentCfg.getProperty(_SHADOW),

            preventcontextoverlap: oParentCfg.getProperty(_PREVENT_CONTEXT_OVERLAP),
            
            monitorresize: oParentCfg.getProperty(_MONITOR_RESIZE),

            keepopen: oParentCfg.getProperty(_KEEP_OPEN)

        },
        
        oLI;


    
    if (!(oParentMenu instanceof YAHOO.widget.MenuBar)) {

        oConfig[_SUBMENU_ALIGNMENT] = oParentCfg.getProperty(_SUBMENU_ALIGNMENT);

    }


    p_oSubmenu.cfg.applyConfig(oConfig);


    if (!this.lazyLoad) {

        oLI = this.parent.element;

        if (this.element.parentNode == oLI) {
    
            this.render();
    
        }
        else {

            this.render(oLI);
    
        }

    }
    
},


/**
 * @method _onMenuItemDestroy
 * @description "destroy" event handler for the menu's items.
 * @private
 * @param {String}
 *            p_sType String representing the name of the event that was fired.
 * @param {Array}
 *            p_aArgs Array of arguments sent when the event was fired.
 * @param {YAHOO.widget.MenuItem}
 *            p_oItem Object representing the menu item that fired the event.
 */
_onMenuItemDestroy: function (p_sType, p_aArgs, p_oItem) {

    this._removeItemFromGroupByValue(p_oItem.groupIndex, p_oItem);

},


/**
 * @method _onMenuItemConfigChange
 * @description "configchange" event handler for the menu's items.
 * @private
 * @param {String}
 *            p_sType String representing the name of the event that was fired.
 * @param {Array}
 *            p_aArgs Array of arguments sent when the event was fired.
 * @param {YAHOO.widget.MenuItem}
 *            p_oItem Object representing the menu item that fired the event.
 */
_onMenuItemConfigChange: function (p_sType, p_aArgs, p_oItem) {

    var sPropertyName = p_aArgs[0][0],
        oPropertyValue = p_aArgs[0][1],
        oSubmenu;


    switch(sPropertyName) {

        case _SELECTED:

            if (oPropertyValue === true) {

                this.activeItem = p_oItem;
            
            }

        break;

        case _SUBMENU:

            oSubmenu = p_aArgs[0][1];

            if (oSubmenu) {

                this._configureSubmenu(p_oItem);

            }

        break;

    }

},



// Public event handlers for configuration properties


/**
 * @method configVisible
 * @description Event handler for when the "visible" configuration property the
 *              menu changes.
 * @param {String}
 *            p_sType String representing the name of the event that was fired.
 * @param {Array}
 *            p_aArgs Array of arguments sent when the event was fired.
 * @param {YAHOO.widget.Menu}
 *            p_oMenu Object representing the menu that fired the event.
 */
configVisible: function (p_sType, p_aArgs, p_oMenu) {

    var bVisible,
        sDisplay;

    if (this.cfg.getProperty(_POSITION) == _DYNAMIC) {

        Menu.superclass.configVisible.call(this, p_sType, p_aArgs, p_oMenu);

    }
    else {

        bVisible = p_aArgs[0];
        sDisplay = Dom.getStyle(this.element, _DISPLAY);

        Dom.setStyle(this.element, _VISIBILITY, _VISIBLE);

        if (bVisible) {

            if (sDisplay != _BLOCK) {
                this.beforeShowEvent.fire();
                Dom.setStyle(this.element, _DISPLAY, _BLOCK);
                this.showEvent.fire();
            }
        
        }
        else {

            if (sDisplay == _BLOCK) {
                this.beforeHideEvent.fire();
                Dom.setStyle(this.element, _DISPLAY, _NONE);
                this.hideEvent.fire();
            }
        
        }

    }

},


/**
 * @method configPosition
 * @description Event handler for when the "position" configuration property of
 *              the menu changes.
 * @param {String}
 *            p_sType String representing the name of the event that was fired.
 * @param {Array}
 *            p_aArgs Array of arguments sent when the event was fired.
 * @param {YAHOO.widget.Menu}
 *            p_oMenu Object representing the menu that fired the event.
 */
configPosition: function (p_sType, p_aArgs, p_oMenu) {

    var oElement = this.element,
        sCSSPosition = p_aArgs[0] == _STATIC ? _STATIC : _ABSOLUTE,
        oCfg = this.cfg,
        nZIndex;


    Dom.setStyle(oElement, _POSITION, sCSSPosition);


    if (sCSSPosition == _STATIC) {

        // Statically positioned menus are visible by default
        
        Dom.setStyle(oElement, _DISPLAY, _BLOCK);

        oCfg.setProperty(_VISIBLE, true);

    }
    else {

        /*
		 * Even though the "visible" property is queued to "false" by default,
		 * we need to set the "visibility" property to "hidden" since Overlay's
		 * "configVisible" implementation checks the element's "visibility"
		 * style property before deciding whether or not to show an Overlay
		 * instance.
		 */

        Dom.setStyle(oElement, _VISIBILITY, _HIDDEN);
    
    }


     if (sCSSPosition == _ABSOLUTE) {
         nZIndex = oCfg.getProperty(_ZINDEX);

         if (!nZIndex || nZIndex === 0) {
             oCfg.setProperty(_ZINDEX, 1);
         }

     }

},


/**
 * @method configIframe
 * @description Event handler for when the "iframe" configuration property of
 *              the menu changes.
 * @param {String}
 *            p_sType String representing the name of the event that was fired.
 * @param {Array}
 *            p_aArgs Array of arguments sent when the event was fired.
 * @param {YAHOO.widget.Menu}
 *            p_oMenu Object representing the menu that fired the event.
 */
configIframe: function (p_sType, p_aArgs, p_oMenu) {    

    if (this.cfg.getProperty(_POSITION) == _DYNAMIC) {

        Menu.superclass.configIframe.call(this, p_sType, p_aArgs, p_oMenu);

    }

},


/**
 * @method configHideDelay
 * @description Event handler for when the "hidedelay" configuration property of
 *              the menu changes.
 * @param {String}
 *            p_sType String representing the name of the event that was fired.
 * @param {Array}
 *            p_aArgs Array of arguments sent when the event was fired.
 * @param {YAHOO.widget.Menu}
 *            p_oMenu Object representing the menu that fired the event.
 */
configHideDelay: function (p_sType, p_aArgs, p_oMenu) {

    var nHideDelay = p_aArgs[0];

    this._useHideDelay = (nHideDelay > 0);

},


/**
 * @method configContainer
 * @description Event handler for when the "container" configuration property of
 *              the menu changes.
 * @param {String}
 *            p_sType String representing the name of the event that was fired.
 * @param {Array}
 *            p_aArgs Array of arguments sent when the event was fired.
 * @param {YAHOO.widget.Menu}
 *            p_oMenu Object representing the menu that fired the event.
 */
configContainer: function (p_sType, p_aArgs, p_oMenu) {

    var oElement = p_aArgs[0];

    if (Lang.isString(oElement)) {

        this.cfg.setProperty(_CONTAINER, Dom.get(oElement), true);

    }

},


/**
 * @method _clearSetWidthFlag
 * @description Change event listener for the "width" configuration property.
 *              This listener is added when a Menu's "width" configuration
 *              property is set by the "_setScrollHeight" method, and is used to
 *              set the "_widthSetForScroll" property to "false" if the "width"
 *              configuration property is changed after it was set by the
 *              "_setScrollHeight" method. If the "_widthSetForScroll" property
 *              is set to "false", and the "_setScrollHeight" method is in the
 *              process of tearing down scrolling functionality, it will
 *              maintain the Menu's new width rather than reseting it.
 * @private
 */
_clearSetWidthFlag: function () {

    this._widthSetForScroll = false;
    
    this.cfg.unsubscribeFromConfigEvent(_WIDTH, this._clearSetWidthFlag);

},

/**
 * @method _subscribeScrollHandlers
 * @param {HTMLElement}
 *            oHeader The scroll header element
 * @param {HTMLElement}
 *            oFooter The scroll footer element
 */
_subscribeScrollHandlers : function(oHeader, oFooter) {
    var fnMouseOver = this._onScrollTargetMouseOver;
    var fnMouseOut = this._onScrollTargetMouseOut;

    Event.on(oHeader, _MOUSEOVER, fnMouseOver, this, true);
    Event.on(oHeader, _MOUSEOUT, fnMouseOut, this, true);
    Event.on(oFooter, _MOUSEOVER, fnMouseOver, this, true);
    Event.on(oFooter, _MOUSEOUT, fnMouseOut, this, true);
},

/**
 * @method _unsubscribeScrollHandlers
 * @param {HTMLElement}
 *            oHeader The scroll header element
 * @param {HTMLElement}
 *            oFooter The scroll footer element
 */
_unsubscribeScrollHandlers : function(oHeader, oFooter) {
    var fnMouseOver = this._onScrollTargetMouseOver;
    var fnMouseOut = this._onScrollTargetMouseOut;
    
    Event.removeListener(oHeader, _MOUSEOVER, fnMouseOver);
    Event.removeListener(oHeader, _MOUSEOUT, fnMouseOut);
    Event.removeListener(oFooter, _MOUSEOVER, fnMouseOver);
    Event.removeListener(oFooter, _MOUSEOUT, fnMouseOut);
},

/**
 * @method _setScrollHeight
 * @description
 * @param {String}
 *            p_nScrollHeight Number representing the scrolling height of the
 *            Menu.
 * @private
 */
_setScrollHeight: function (p_nScrollHeight) {

    var nScrollHeight = p_nScrollHeight,
        bRefireIFrameAndShadow = false,
        bSetWidth = false,
        oElement,
        oBody,
        oHeader,
        oFooter,
        nMinScrollHeight,
        nHeight,
        nOffsetWidth,
        sWidth;

    if (this.getItems().length > 0) {

        oElement = this.element;
        oBody = this.body;
        oHeader = this.header;
        oFooter = this.footer;
        nMinScrollHeight = this.cfg.getProperty(_MIN_SCROLL_HEIGHT);

        if (nScrollHeight > 0 && nScrollHeight < nMinScrollHeight) {
            nScrollHeight = nMinScrollHeight;
        }

        Dom.setStyle(oBody, _HEIGHT, _EMPTY_STRING);
        Dom.removeClass(oBody, _YUI_MENU_BODY_SCROLLED);
        oBody.scrollTop = 0;

        // Need to set a width for the Menu to fix the following problems in
        // Firefox 2 and IE:

        // #1) Scrolled Menus will render at 1px wide in Firefox 2

        // #2) There is a bug in gecko-based browsers where an element whose
        // "position" property is set to "absolute" and "overflow" property is
        // set to "hidden" will not render at the correct width when its
        // offsetParent's "position" property is also set to "absolute." It is
        // possible to work around this bug by specifying a value for the width
        // property in addition to overflow.

        // #3) In IE it is necessary to give the Menu a width before the
        // scrollbars are rendered to prevent the Menu from rendering with a
        // width that is 100% of the browser viewport.

        bSetWidth = ((UA.gecko && UA.gecko < 1.9) || UA.ie);

        if (nScrollHeight > 0 && bSetWidth && !this.cfg.getProperty(_WIDTH)) {

            nOffsetWidth = oElement.offsetWidth;
    
            /*
			 * Measuring the difference of the offsetWidth before and after
			 * setting the "width" style attribute allows us to compute the
			 * about of padding and borders applied to the element, which in
			 * turn allows us to set the "width" property correctly.
			 */
            
            oElement.style.width = nOffsetWidth + _PX;
    
            sWidth = (nOffsetWidth - (oElement.offsetWidth - nOffsetWidth)) + _PX;


            this.cfg.unsubscribeFromConfigEvent(_WIDTH, this._clearSetWidthFlag);


            this.cfg.setProperty(_WIDTH, sWidth);


            /*
			 * Set a flag (_widthSetForScroll) to maintain some history
			 * regarding how the "width" configuration property was set. If the
			 * "width" configuration property is set by something other than the
			 * "_setScrollHeight" method, it will be necessary to maintain that
			 * new value and not clear the width if scrolling is turned off.
			 */

            this._widthSetForScroll = true;

            this.cfg.subscribeToConfigEvent(_WIDTH, this._clearSetWidthFlag);
    
        }


        if (nScrollHeight > 0 && (!oHeader && !oFooter)) {


            this.setHeader(_NON_BREAKING_SPACE);
            this.setFooter(_NON_BREAKING_SPACE);

            oHeader = this.header;
            oFooter = this.footer;

            Dom.addClass(oHeader, _TOP_SCROLLBAR);
            Dom.addClass(oFooter, _BOTTOM_SCROLLBAR);

            oElement.insertBefore(oHeader, oBody);
            oElement.appendChild(oFooter);
        
        }

        nHeight = nScrollHeight;

        if (oHeader && oFooter) {
            nHeight = (nHeight - (oHeader.offsetHeight + oFooter.offsetHeight));
        }
    
    
        if ((nHeight > 0) && (oBody.offsetHeight > nScrollHeight)) {

    
            Dom.addClass(oBody, _YUI_MENU_BODY_SCROLLED);
            Dom.setStyle(oBody, _HEIGHT, (nHeight + _PX));

            if (!this._hasScrollEventHandlers) {
                this._subscribeScrollHandlers(oHeader, oFooter);
                this._hasScrollEventHandlers = true;
            }
    
            this._disableScrollHeader();
            this._enableScrollFooter();
            
            bRefireIFrameAndShadow = true;			
    
        }
        else if (oHeader && oFooter) {

    

            /*
			 * Only clear the the "width" configuration property if it was set
			 * the "_setScrollHeight" method and wasn't changed by some other
			 * means after it was set.
			 */	
    
            if (this._widthSetForScroll) {
    

                this._widthSetForScroll = false;

                this.cfg.unsubscribeFromConfigEvent(_WIDTH, this._clearSetWidthFlag);
    
                this.cfg.setProperty(_WIDTH, _EMPTY_STRING);
            
            }
    
    
            this._enableScrollHeader();
            this._enableScrollFooter();
    
            if (this._hasScrollEventHandlers) {
                this._unsubscribeScrollHandlers(oHeader, oFooter);    
                this._hasScrollEventHandlers = false;
            }

            oElement.removeChild(oHeader);
            oElement.removeChild(oFooter);
    
            this.header = null;
            this.footer = null;
            
            bRefireIFrameAndShadow = true;
        
        }


        if (bRefireIFrameAndShadow) {
    
            this.cfg.refireEvent(_IFRAME);
            this.cfg.refireEvent(_SHADOW);
        
        }
    
    }

},


/**
 * @method _setMaxHeight
 * @description "renderEvent" handler used to defer the setting of the
 *              "maxheight" configuration property until the menu is rendered in
 *              lazy load scenarios.
 * @param {String}
 *            p_sType The name of the event that was fired.
 * @param {Array}
 *            p_aArgs Collection of arguments sent when the event was fired.
 * @param {Number}
 *            p_nMaxHeight Number representing the value to set for the
 *            "maxheight" configuration property.
 * @private
 */
_setMaxHeight: function (p_sType, p_aArgs, p_nMaxHeight) {

    this._setScrollHeight(p_nMaxHeight);
    this.renderEvent.unsubscribe(this._setMaxHeight);

},


/**
 * @method configMaxHeight
 * @description Event handler for when the "maxheight" configuration property of
 *              a Menu changes.
 * @param {String}
 *            p_sType The name of the event that was fired.
 * @param {Array}
 *            p_aArgs Collection of arguments sent when the event was fired.
 * @param {YAHOO.widget.Menu}
 *            p_oMenu The Menu instance fired the event.
 */
configMaxHeight: function (p_sType, p_aArgs, p_oMenu) {

    var nMaxHeight = p_aArgs[0];

    if (this.lazyLoad && !this.body && nMaxHeight > 0) {
    
        this.renderEvent.subscribe(this._setMaxHeight, nMaxHeight, this);

    }
    else {

        this._setScrollHeight(nMaxHeight);
    
    }

},


/**
 * @method configClassName
 * @description Event handler for when the "classname" configuration property of
 *              a menu changes.
 * @param {String}
 *            p_sType The name of the event that was fired.
 * @param {Array}
 *            p_aArgs Collection of arguments sent when the event was fired.
 * @param {YAHOO.widget.Menu}
 *            p_oMenu The Menu instance fired the event.
 */
configClassName: function (p_sType, p_aArgs, p_oMenu) {

    var sClassName = p_aArgs[0];

    if (this._sClassName) {

        Dom.removeClass(this.element, this._sClassName);

    }

    Dom.addClass(this.element, sClassName);
    this._sClassName = sClassName;

},


/**
 * @method _onItemAdded
 * @description "itemadded" event handler for a Menu instance.
 * @private
 * @param {String}
 *            p_sType The name of the event that was fired.
 * @param {Array}
 *            p_aArgs Collection of arguments sent when the event was fired.
 */
_onItemAdded: function (p_sType, p_aArgs) {

    var oItem = p_aArgs[0];
    
    if (oItem) {

        oItem.cfg.setProperty(_DISABLED, true);
    
    }

},


/**
 * @method configDisabled
 * @description Event handler for when the "disabled" configuration property of
 *              a menu changes.
 * @param {String}
 *            p_sType The name of the event that was fired.
 * @param {Array}
 *            p_aArgs Collection of arguments sent when the event was fired.
 * @param {YAHOO.widget.Menu}
 *            p_oMenu The Menu instance fired the event.
 */
configDisabled: function (p_sType, p_aArgs, p_oMenu) {

    var bDisabled = p_aArgs[0],
        aItems = this.getItems(),
        nItems,
        i;

    if (Lang.isArray(aItems)) {

        nItems = aItems.length;
    
        if (nItems > 0) {
        
            i = nItems - 1;
    
            do {
    
                aItems[i].cfg.setProperty(_DISABLED, bDisabled);
            
            }
            while (i--);
        
        }


        if (bDisabled) {

            this.clearActiveItem(true);

            Dom.addClass(this.element, _DISABLED);

            this.itemAddedEvent.subscribe(this._onItemAdded);

        }
        else {

            Dom.removeClass(this.element, _DISABLED);

            this.itemAddedEvent.unsubscribe(this._onItemAdded);

        }
        
    }

},

/**
 * Resizes the shadow to match the container bounding element
 * 
 * @method _sizeShadow
 * @protected
 */
_sizeShadow : function () {

    var oElement = this.element,
        oShadow = this._shadow;

    if (oShadow && oElement) {
        // Clear the previous width
        if (oShadow.style.width && oShadow.style.height) {
            oShadow.style.width = _EMPTY_STRING;
            oShadow.style.height = _EMPTY_STRING;
        }

        oShadow.style.width = (oElement.offsetWidth + 6) + _PX;
        oShadow.style.height = (oElement.offsetHeight + 1) + _PX;
    }
},

/**
 * Replaces the shadow element in the DOM with the current shadow element
 * (this._shadow)
 * 
 * @method _replaceShadow
 * @protected
 */
_replaceShadow : function () {
    this.element.appendChild(this._shadow);
},

/**
 * Adds the classname marker for a visible shadow, to the shadow element
 * 
 * @method _addShadowVisibleClass
 * @protected
 */
_addShadowVisibleClass : function () {
    Dom.addClass(this._shadow, _YUI_MENU_SHADOW_VISIBLE);
},

/**
 * Removes the classname marker for a visible shadow, from the shadow element
 * 
 * @method _removeShadowVisibleClass
 * @protected
 */
_removeShadowVisibleClass : function () {
    Dom.removeClass(this._shadow, _YUI_MENU_SHADOW_VISIBLE);
},

/**
 * Removes the shadow element from the DOM, and unsubscribes all the listeners
 * used to keep it in sync. Used to handle setting the shadow to false.
 * 
 * @method _removeShadow
 * @protected
 */
_removeShadow : function() {

    var p = (this._shadow && this._shadow.parentNode);

    if (p) {
        p.removeChild(this._shadow);
    }

    this.beforeShowEvent.unsubscribe(this._addShadowVisibleClass);
    this.beforeHideEvent.unsubscribe(this._removeShadowVisibleClass);

    this.cfg.unsubscribeFromConfigEvent(_WIDTH, this._sizeShadow);
    this.cfg.unsubscribeFromConfigEvent(_HEIGHT, this._sizeShadow);
    this.cfg.unsubscribeFromConfigEvent(_MAX_HEIGHT, this._sizeShadow);
    this.cfg.unsubscribeFromConfigEvent(_MAX_HEIGHT, this._replaceShadow);

    this.changeContentEvent.unsubscribe(this._sizeShadow);

    Module.textResizeEvent.unsubscribe(this._sizeShadow);
},

/**
 * Used to create the shadow element, add it to the DOM, and subscribe listeners
 * to keep it in sync.
 * 
 * @method _createShadow
 * @protected
 */
_createShadow : function () {

    var oShadow = this._shadow,
        oElement;

    if (!oShadow) {
        oElement = this.element;

        if (!m_oShadowTemplate) {
            m_oShadowTemplate = document.createElement(_DIV_LOWERCASE);
            m_oShadowTemplate.className = _YUI_MENU_SHADOW_YUI_MENU_SHADOW_VISIBLE;
        }

        oShadow = m_oShadowTemplate.cloneNode(false);

        oElement.appendChild(oShadow);
        
        this._shadow = oShadow;

        this.beforeShowEvent.subscribe(this._addShadowVisibleClass);
        this.beforeHideEvent.subscribe(this._removeShadowVisibleClass);

        if (UA.ie) {
            /*
			 * Need to call sizeShadow & syncIframe via setTimeout for IE 7
			 * Quirks Mode and IE 6 Standards Mode and Quirks Mode or the shadow
			 * and iframe shim will not be sized and positioned properly.
			 */
            Lang.later(0, this, function () {
                this._sizeShadow(); 
                this.syncIframe();
            });

            this.cfg.subscribeToConfigEvent(_WIDTH, this._sizeShadow);
            this.cfg.subscribeToConfigEvent(_HEIGHT, this._sizeShadow);
            this.cfg.subscribeToConfigEvent(_MAX_HEIGHT, this._sizeShadow);
            this.changeContentEvent.subscribe(this._sizeShadow);

            Module.textResizeEvent.subscribe(this._sizeShadow, this, true);

            this.destroyEvent.subscribe(function () {
                Module.textResizeEvent.unsubscribe(this._sizeShadow, this);
            });
        }

        this.cfg.subscribeToConfigEvent(_MAX_HEIGHT, this._replaceShadow);
    }
},

/**
 * The beforeShow event handler used to set up the shadow lazily when the menu
 * is made visible.
 * 
 * @method _shadowBeforeShow
 * @protected
 */
_shadowBeforeShow : function () {
    if (this._shadow) {

        // If called because the "shadow" event was refired - just append again
		// and resize
        this._replaceShadow();

        if (UA.ie) {
            this._sizeShadow();
        }
    } else {
        this._createShadow();
    }

    this.beforeShowEvent.unsubscribe(this._shadowBeforeShow);
},

/**
 * @method configShadow
 * @description Event handler for when the "shadow" configuration property of a
 *              menu changes.
 * @param {String}
 *            p_sType The name of the event that was fired.
 * @param {Array}
 *            p_aArgs Collection of arguments sent when the event was fired.
 * @param {YAHOO.widget.Menu}
 *            p_oMenu The Menu instance fired the event.
 */
configShadow: function (p_sType, p_aArgs, p_oMenu) {

    var bShadow = p_aArgs[0];

    if (bShadow && this.cfg.getProperty(_POSITION) == _DYNAMIC) {
        if (this.cfg.getProperty(_VISIBLE)) {
            if (this._shadow) {
                // If the "shadow" event was refired - just append again and
				// resize
                this._replaceShadow();
                
                if (UA.ie) {
                    this._sizeShadow();
                }
            } else {
                this._createShadow();
            }
        } else {
            this.beforeShowEvent.subscribe(this._shadowBeforeShow);
        }
    } else if (!bShadow) {
        this.beforeShowEvent.unsubscribe(this._shadowBeforeShow);
        this._removeShadow();
    }
},

// Public methods

/**
 * @method initEvents
 * @description Initializes the custom events for the menu.
 */
initEvents: function () {

    Menu.superclass.initEvents.call(this);

    // Create custom events

    var i = EVENT_TYPES.length - 1,
        aEventData,
        oCustomEvent;


    do {

        aEventData = EVENT_TYPES[i];

        oCustomEvent = this.createEvent(aEventData[1]);
        oCustomEvent.signature = CustomEvent.LIST;
        
        this[aEventData[0]] = oCustomEvent;

    }
    while (i--);

},


/**
 * @method positionOffScreen
 * @description Positions the menu outside of the boundaries of the browser's
 *              viewport. Called automatically when a menu is hidden to ensure
 *              that it doesn't force the browser to render uncessary
 *              scrollbars.
 */
positionOffScreen: function () {

    var oIFrame = this.iframe,
        oElement = this.element,
        sPos = this.OFF_SCREEN_POSITION;
    
    oElement.style.top = _EMPTY_STRING;
    oElement.style.left = _EMPTY_STRING;
    
    if (oIFrame) {

        oIFrame.style.top = sPos;
        oIFrame.style.left = sPos;
    
    }

},


/**
 * @method getRoot
 * @description Finds the menu's root menu.
 */
getRoot: function () {

    var oItem = this.parent,
        oParentMenu,
        returnVal;

    if (oItem) {

        oParentMenu = oItem.parent;

        returnVal = oParentMenu ? oParentMenu.getRoot() : this;

    }
    else {
    
        returnVal = this;
    
    }
    
    return returnVal;

},


/**
 * @method toString
 * @description Returns a string representing the menu.
 * @return {String}
 */
toString: function () {

    var sReturnVal = _MENU,
        sId = this.id;

    if (sId) {

        sReturnVal += (_SPACE + sId);
    
    }

    return sReturnVal;

},


/**
 * @method setItemGroupTitle
 * @description Sets the title of a group of menu items.
 * @param {HTML}
 *            p_sGroupTitle String or markup specifying the title of the group.
 *            The title is inserted into the DOM as HTML, and should be escaped
 *            by the implementor if coming from an external source.
 * @param {Number}
 *            p_nGroupIndex Optional. Number specifying the group to which the
 *            title belongs.
 */
setItemGroupTitle: function (p_sGroupTitle, p_nGroupIndex) {

    var nGroupIndex,
        oTitle,
        i,
        nFirstIndex;
        
    if (Lang.isString(p_sGroupTitle) && p_sGroupTitle.length > 0) {

        nGroupIndex = Lang.isNumber(p_nGroupIndex) ? p_nGroupIndex : 0;
        oTitle = this._aGroupTitleElements[nGroupIndex];


        if (oTitle) {

            oTitle.innerHTML = p_sGroupTitle;
            
        }
        else {

            oTitle = document.createElement(this.GROUP_TITLE_TAG_NAME);
                    
            oTitle.innerHTML = p_sGroupTitle;

            this._aGroupTitleElements[nGroupIndex] = oTitle;

        }


        i = this._aGroupTitleElements.length - 1;

        do {

            if (this._aGroupTitleElements[i]) {

                Dom.removeClass(this._aGroupTitleElements[i], _FIRST_OF_TYPE);

                nFirstIndex = i;

            }

        }
        while (i--);


        if (nFirstIndex !== null) {

            Dom.addClass(this._aGroupTitleElements[nFirstIndex], 
                _FIRST_OF_TYPE);

        }

        this.changeContentEvent.fire();

    }

},



/**
 * @method addItem
 * @description Appends an item to the menu.
 * @param {YAHOO.widget.MenuItem}
 *            p_oItem Object reference for the MenuItem instance to be added to
 *            the menu.
 * @param {HTML}
 *            p_oItem String or markup specifying content of the item to be
 *            added to the menu. The item text is inserted into the DOM as HTML,
 *            and should be escaped by the implementor if coming from an
 *            external source.
 * @param {Object}
 *            p_oItem Object literal containing a set of menu item configuration
 *            properties.
 * @param {Number}
 *            p_nGroupIndex Optional. Number indicating the group to which the
 *            item belongs.
 * @return {YAHOO.widget.MenuItem}
 */
addItem: function (p_oItem, p_nGroupIndex) {

    return this._addItemToGroup(p_nGroupIndex, p_oItem);

},


/**
 * @method addItems
 * @description Adds an array of items to the menu.
 * @param {Array}
 *            p_aItems Array of items to be added to the menu. The array can
 *            contain strings specifying the markup for the content of each item
 *            to be created, object literals specifying each of the menu item
 *            configuration properties, or MenuItem instances. The item content
 *            if provided as a string is inserted into the DOM as HTML, and
 *            should be escaped by the implementor if coming from an external
 *            source.
 * @param {Number}
 *            p_nGroupIndex Optional. Number specifying the group to which the
 *            items belongs.
 * @return {Array}
 */
addItems: function (p_aItems, p_nGroupIndex) {

    var nItems,
        aItems,
        oItem,
        i,
        returnVal;


    if (Lang.isArray(p_aItems)) {

        nItems = p_aItems.length;
        aItems = [];

        for(i=0; i<nItems; i++) {

            oItem = p_aItems[i];

            if (oItem) {

                if (Lang.isArray(oItem)) {
    
                    aItems[aItems.length] = this.addItems(oItem, i);
    
                }
                else {
    
                    aItems[aItems.length] = this._addItemToGroup(p_nGroupIndex, oItem);
                
                }

            }
    
        }


        if (aItems.length) {
        
            returnVal = aItems;
        
        }

    }

    return returnVal;

},


/**
 * @method insertItem
 * @description Inserts an item into the menu at the specified index.
 * @param {YAHOO.widget.MenuItem}
 *            p_oItem Object reference for the MenuItem instance to be added to
 *            the menu.
 * @param {String}
 *            p_oItem String specifying the text of the item to be added to the
 *            menu.
 * @param {Object}
 *            p_oItem Object literal containing a set of menu item configuration
 *            properties.
 * @param {Number}
 *            p_nItemIndex Number indicating the ordinal position at which the
 *            item should be added.
 * @param {Number}
 *            p_nGroupIndex Optional. Number indicating the group to which the
 *            item belongs.
 * @return {YAHOO.widget.MenuItem}
 */
insertItem: function (p_oItem, p_nItemIndex, p_nGroupIndex) {
    
    return this._addItemToGroup(p_nGroupIndex, p_oItem, p_nItemIndex);

},


/**
 * @method removeItem
 * @description Removes the specified item from the menu.
 * @param {YAHOO.widget.MenuItem}
 *            p_oObject Object reference for the MenuItem instance to be removed
 *            from the menu.
 * @param {Number}
 *            p_oObject Number specifying the index of the item to be removed.
 * @param {Number}
 *            p_nGroupIndex Optional. Number specifying the group to which the
 *            item belongs.
 * @return {YAHOO.widget.MenuItem}
 */
removeItem: function (p_oObject, p_nGroupIndex) {

    var oItem,
        returnVal;
    
    if (!Lang.isUndefined(p_oObject)) {

        if (p_oObject instanceof YAHOO.widget.MenuItem) {

            oItem = this._removeItemFromGroupByValue(p_nGroupIndex, p_oObject);           

        }
        else if (Lang.isNumber(p_oObject)) {

            oItem = this._removeItemFromGroupByIndex(p_nGroupIndex, p_oObject);

        }

        if (oItem) {

            oItem.destroy();


            returnVal = oItem;

        }

    }

    return returnVal;

},


/**
 * @method getItems
 * @description Returns an array of all of the items in the menu.
 * @return {Array}
 */
getItems: function () {

    var aGroups = this._aItemGroups,
        nGroups,
        returnVal,
        aItems = [];


    if (Lang.isArray(aGroups)) {

        nGroups = aGroups.length;

        returnVal = ((nGroups == 1) ? aGroups[0] : (Array.prototype.concat.apply(aItems, aGroups)));

    }

    return returnVal;

},


/**
 * @method getItemGroups
 * @description Multi-dimensional Array representing the menu items as they are
 *              grouped in the menu.
 * @return {Array}
 */        
getItemGroups: function () {

    return this._aItemGroups;

},


/**
 * @method getItem
 * @description Returns the item at the specified index.
 * @param {Number}
 *            p_nItemIndex Number indicating the ordinal position of the item to
 *            be retrieved.
 * @param {Number}
 *            p_nGroupIndex Optional. Number indicating the group to which the
 *            item belongs.
 * @return {YAHOO.widget.MenuItem}
 */
getItem: function (p_nItemIndex, p_nGroupIndex) {
    
    var aGroup,
        returnVal;
    
    if (Lang.isNumber(p_nItemIndex)) {

        aGroup = this._getItemGroup(p_nGroupIndex);

        if (aGroup) {

            returnVal = aGroup[p_nItemIndex];
        
        }

    }
    
    return returnVal;
    
},


/**
 * @method getSubmenus
 * @description Returns an array of all of the submenus that are immediate
 *              children of the menu.
 * @return {Array}
 */
getSubmenus: function () {

    var aItems = this.getItems(),
        nItems = aItems.length,
        aSubmenus,
        oSubmenu,
        oItem,
        i;


    if (nItems > 0) {
        
        aSubmenus = [];

        for(i=0; i<nItems; i++) {

            oItem = aItems[i];
            
            if (oItem) {

                oSubmenu = oItem.cfg.getProperty(_SUBMENU);
                
                if (oSubmenu) {

                    aSubmenus[aSubmenus.length] = oSubmenu;

                }
            
            }
        
        }
    
    }

    return aSubmenus;

},


/**
 * @method clearContent
 * @description Removes all of the content from the menu, including the menu
 *              items, group titles, header and footer.
 */
clearContent: function () {

    var aItems = this.getItems(),
        nItems = aItems.length,
        oElement = this.element,
        oBody = this.body,
        oHeader = this.header,
        oFooter = this.footer,
        oItem,
        oSubmenu,
        i;


    if (nItems > 0) {

        i = nItems - 1;

        do {

            oItem = aItems[i];

            if (oItem) {

                oSubmenu = oItem.cfg.getProperty(_SUBMENU);

                if (oSubmenu) {

                    this.cfg.configChangedEvent.unsubscribe(
                        this._onParentMenuConfigChange, oSubmenu);

                    this.renderEvent.unsubscribe(this._onParentMenuRender, 
                        oSubmenu);

                }
                
                this.removeItem(oItem, oItem.groupIndex);

            }
        
        }
        while (i--);

    }


    if (oHeader) {

        Event.purgeElement(oHeader);
        oElement.removeChild(oHeader);

    }
    

    if (oFooter) {

        Event.purgeElement(oFooter);
        oElement.removeChild(oFooter);
    }


    if (oBody) {

        Event.purgeElement(oBody);

        oBody.innerHTML = _EMPTY_STRING;

    }

    this.activeItem = null;

    this._aItemGroups = [];
    this._aListElements = [];
    this._aGroupTitleElements = [];

    this.cfg.setProperty(_WIDTH, null);

},


/**
 * @method destroy
 * @description Removes the menu's <code>&#60;div&#62;</code> element (and
 *              accompanying child nodes) from the document.
 * @param {boolean}
 *            shallowPurge If true, only the parent element's DOM event
 *            listeners are purged. If false, or not provided, all children are
 *            also purged of DOM event listeners. NOTE: The flag is a
 *            "shallowPurge" flag, as opposed to what may be a more intuitive
 *            "purgeChildren" flag to maintain backwards compatibility with
 *            behavior prior to 2.9.0.
 * 
 */
destroy: function (shallowPurge) {

    // Remove all items

    this.clearContent();

    this._aItemGroups = null;
    this._aListElements = null;
    this._aGroupTitleElements = null;


    // Continue with the superclass implementation of this method

    Menu.superclass.destroy.call(this, shallowPurge);
    

},


/**
 * @method setInitialFocus
 * @description Sets focus to the menu's first enabled item.
 */
setInitialFocus: function () {

    var oItem = this._getFirstEnabledItem();
    
    if (oItem) {

        oItem.focus();

    }
    
},


/**
 * @method setInitialSelection
 * @description Sets the "selected" configuration property of the menu's first
 *              enabled item to "true."
 */
setInitialSelection: function () {

    var oItem = this._getFirstEnabledItem();
    
    if (oItem) {
    
        oItem.cfg.setProperty(_SELECTED, true);
    }        

},


/**
 * @method clearActiveItem
 * @description Sets the "selected" configuration property of the menu's active
 *              item to "false" and hides the item's submenu.
 * @param {Boolean}
 *            p_bBlur Boolean indicating if the menu's active item should be
 *            blurred.
 */
clearActiveItem: function (p_bBlur) {

    if (this.cfg.getProperty(_SHOW_DELAY) > 0) {
    
        this._cancelShowDelay();
    
    }


    var oActiveItem = this.activeItem,
        oConfig,
        oSubmenu;

    if (oActiveItem) {

        oConfig = oActiveItem.cfg;

        if (p_bBlur) {

            oActiveItem.blur();
            
            this.getRoot()._hasFocus = true;
        
        }

        oConfig.setProperty(_SELECTED, false);

        oSubmenu = oConfig.getProperty(_SUBMENU);


        if (oSubmenu) {

            oSubmenu.hide();

        }

        this.activeItem = null;  

    }

},


/**
 * @method focus
 * @description Causes the menu to receive focus and fires the "focus" event.
 */
focus: function () {

    if (!this.hasFocus()) {

        this.setInitialFocus();
    
    }

},


/**
 * @method blur
 * @description Causes the menu to lose focus and fires the "blur" event.
 */    
blur: function () {

    var oItem;

    if (this.hasFocus()) {
    
        oItem = MenuManager.getFocusedMenuItem();
        
        if (oItem) {

            oItem.blur();

        }

    }

},


/**
 * @method hasFocus
 * @description Returns a boolean indicating whether or not the menu has focus.
 * @return {Boolean}
 */
hasFocus: function () {

    return (MenuManager.getFocusedMenu() == this.getRoot());

},


_doItemSubmenuSubscribe: function (p_sType, p_aArgs, p_oObject) {

    var oItem = p_aArgs[0],
        oSubmenu = oItem.cfg.getProperty(_SUBMENU);

    if (oSubmenu) {
        oSubmenu.subscribe.apply(oSubmenu, p_oObject);
    }

},


_doSubmenuSubscribe: function (p_sType, p_aArgs, p_oObject) { 

    var oSubmenu = this.cfg.getProperty(_SUBMENU);
    
    if (oSubmenu) {
        oSubmenu.subscribe.apply(oSubmenu, p_oObject);
    }

},


/**
 * Adds the specified CustomEvent subscriber to the menu and each of its
 * submenus.
 * 
 * @method subscribe
 * @param p_type
 *            {string} the type, or name of the event
 * @param p_fn
 *            {function} the function to exectute when the event fires
 * @param p_obj
 *            {Object} An object to be passed along when the event fires
 * @param p_override
 *            {boolean} If true, the obj passed in becomes the execution scope
 *            of the listener
 */
subscribe: function () {

    // Subscribe to the event for this Menu instance
    Menu.superclass.subscribe.apply(this, arguments);

    // Subscribe to the "itemAdded" event so that all future submenus
    // also subscribe to this event
    Menu.superclass.subscribe.call(this, _ITEM_ADDED, this._doItemSubmenuSubscribe, arguments);


    var aItems = this.getItems(),
        nItems,
        oItem,
        oSubmenu,
        i;
        

    if (aItems) {

        nItems = aItems.length;
        
        if (nItems > 0) {
        
            i = nItems - 1;
            
            do {

                oItem = aItems[i];
                oSubmenu = oItem.cfg.getProperty(_SUBMENU);
                
                if (oSubmenu) {
                    oSubmenu.subscribe.apply(oSubmenu, arguments);
                }
                else {
                    oItem.cfg.subscribeToConfigEvent(_SUBMENU, this._doSubmenuSubscribe, arguments);
                }

            }
            while (i--);
        
        }

    }

},


unsubscribe: function () {

    // Remove the event for this Menu instance
    Menu.superclass.unsubscribe.apply(this, arguments);

    // Remove the "itemAdded" event so that all future submenus don't have
    // the event handler
    Menu.superclass.unsubscribe.call(this, _ITEM_ADDED, this._doItemSubmenuSubscribe, arguments);


    var aItems = this.getItems(),
        nItems,
        oItem,
        oSubmenu,
        i;
        

    if (aItems) {

        nItems = aItems.length;
        
        if (nItems > 0) {
        
            i = nItems - 1;
            
            do {

                oItem = aItems[i];
                oSubmenu = oItem.cfg.getProperty(_SUBMENU);
                
                if (oSubmenu) {
                    oSubmenu.unsubscribe.apply(oSubmenu, arguments);
                }
                else {
                    oItem.cfg.unsubscribeFromConfigEvent(_SUBMENU, this._doSubmenuSubscribe, arguments);
                }

            }
            while (i--);
        
        }

    }

},


/**
 * @description Initializes the class's configurable properties which can be
 *              changed using the menu's Config object ("cfg").
 * @method initDefaultConfig
 */
initDefaultConfig: function () {

    Menu.superclass.initDefaultConfig.call(this);

    var oConfig = this.cfg;


    // Module documentation overrides

    /**
	 * @config effect
	 * @description Object or array of objects representing the ContainerEffect
	 *              classes that are active for animating the container. When
	 *              set this property is automatically applied to all submenus.
	 * @type Object
	 * @default null
	 */

    // Overlay documentation overrides


    /**
	 * @config x
	 * @description Number representing the absolute x-coordinate position of
	 *              the Menu. This property is only applied when the "position"
	 *              configuration property is set to dynamic.
	 * @type Number
	 * @default null
	 */
    

    /**
	 * @config y
	 * @description Number representing the absolute y-coordinate position of
	 *              the Menu. This property is only applied when the "position"
	 *              configuration property is set to dynamic.
	 * @type Number
	 * @default null
	 */


    /**
	 * @description Array of the absolute x and y positions of the Menu. This
	 *              property is only applied when the "position" configuration
	 *              property is set to dynamic.
	 * @config xy
	 * @type Number[]
	 * @default null
	 */
    

    /**
	 * @config context
	 * @description Array of context arguments for context-sensitive
	 *              positioning. The format is: [id or element, element corner,
	 *              context corner]. For example, setting this property to
	 *              ["img1", "tl", "bl"] would align the Menu's top left corner
	 *              to the context element's bottom left corner. This property
	 *              is only applied when the "position" configuration property
	 *              is set to dynamic.
	 * @type Array
	 * @default null
	 */
    
    
    /**
	 * @config fixedcenter
	 * @description Boolean indicating if the Menu should be anchored to the
	 *              center of the viewport. This property is only applied when
	 *              the "position" configuration property is set to dynamic.
	 * @type Boolean
	 * @default false
	 */
    
    
    /**
	 * @config iframe
	 * @description Boolean indicating whether or not the Menu should have an
	 *              IFRAME shim; used to prevent SELECT elements from poking
	 *              through an Overlay instance in IE6. When set to "true", the
	 *              iframe shim is created when the Menu instance is intially
	 *              made visible. This property is only applied when the
	 *              "position" configuration property is set to dynamic and is
	 *              automatically applied to all submenus.
	 * @type Boolean
	 * @default true for IE6 and below, false for all other browsers.
	 */


    // Add configuration attributes

    /*
	 * Change the default value for the "visible" configuration property to
	 * "false" by re-adding the property.
	 */

    /**
	 * @config visible
	 * @description Boolean indicating whether or not the menu is visible. If
	 *              the menu's "position" configuration property is set to
	 *              "dynamic" (the default), this property toggles the menu's
	 *              <code>&#60;div&#62;</code> element's "visibility" style
	 *              property between "visible" (true) or "hidden" (false). If
	 *              the menu's "position" configuration property is set to
	 *              "static" this property toggles the menu's
	 *              <code>&#60;div&#62;</code> element's "display" style
	 *              property between "block" (true) or "none" (false).
	 * @default false
	 * @type Boolean
	 */
    oConfig.addProperty(
        VISIBLE_CONFIG.key, 
        {
            handler: this.configVisible, 
            value: VISIBLE_CONFIG.value, 
            validator: VISIBLE_CONFIG.validator
        }
     );


    /*
	 * Change the default value for the "constraintoviewport" configuration
	 * property (inherited by YAHOO.widget.Overlay) to "true" by re-adding the
	 * property.
	 */

    /**
	 * @config constraintoviewport
	 * @description Boolean indicating if the menu will try to remain inside the
	 *              boundaries of the size of viewport. This property is only
	 *              applied when the "position" configuration property is set to
	 *              dynamic and is automatically applied to all submenus.
	 * @default true
	 * @type Boolean
	 */
    oConfig.addProperty(
        CONSTRAIN_TO_VIEWPORT_CONFIG.key, 
        {
            handler: this.configConstrainToViewport, 
            value: CONSTRAIN_TO_VIEWPORT_CONFIG.value, 
            validator: CONSTRAIN_TO_VIEWPORT_CONFIG.validator, 
            supercedes: CONSTRAIN_TO_VIEWPORT_CONFIG.supercedes 
        } 
    );


    /*
	 * Change the default value for the "preventcontextoverlap" configuration
	 * property (inherited by YAHOO.widget.Overlay) to "true" by re-adding the
	 * property.
	 */

    /**
	 * @config preventcontextoverlap
	 * @description Boolean indicating whether or not a submenu should overlap
	 *              its parent MenuItem when the "constraintoviewport"
	 *              configuration property is set to "true".
	 * @type Boolean
	 * @default true
	 */
    oConfig.addProperty(PREVENT_CONTEXT_OVERLAP_CONFIG.key, {

        value: PREVENT_CONTEXT_OVERLAP_CONFIG.value, 
        validator: PREVENT_CONTEXT_OVERLAP_CONFIG.validator, 
        supercedes: PREVENT_CONTEXT_OVERLAP_CONFIG.supercedes

    });


    /**
	 * @config position
	 * @description String indicating how a menu should be positioned on the
	 *              screen. Possible values are "static" and "dynamic." Static
	 *              menus are visible by default and reside in the normal flow
	 *              of the document (CSS position: static). Dynamic menus are
	 *              hidden by default, reside out of the normal flow of the
	 *              document (CSS position: absolute), and can overlay other
	 *              elements on the screen.
	 * @default dynamic
	 * @type String
	 */
    oConfig.addProperty(
        POSITION_CONFIG.key, 
        {
            handler: this.configPosition,
            value: POSITION_CONFIG.value, 
            validator: POSITION_CONFIG.validator,
            supercedes: POSITION_CONFIG.supercedes
        }
    );


    /**
	 * @config submenualignment
	 * @description Array defining how submenus should be aligned to their
	 *              parent menu item. The format is: [itemCorner,
	 *              submenuCorner]. By default a submenu's top left corner is
	 *              aligned to its parent menu item's top right corner.
	 * @default ["tl","tr"]
	 * @type Array
	 */
    oConfig.addProperty(
        SUBMENU_ALIGNMENT_CONFIG.key, 
        { 
            value: SUBMENU_ALIGNMENT_CONFIG.value,
            suppressEvent: SUBMENU_ALIGNMENT_CONFIG.suppressEvent
        }
    );


    /**
	 * @config autosubmenudisplay
	 * @description Boolean indicating if submenus are automatically made
	 *              visible when the user mouses over the menu's items.
	 * @default true
	 * @type Boolean
	 */
    oConfig.addProperty(
       AUTO_SUBMENU_DISPLAY_CONFIG.key, 
       { 
           value: AUTO_SUBMENU_DISPLAY_CONFIG.value, 
           validator: AUTO_SUBMENU_DISPLAY_CONFIG.validator,
           suppressEvent: AUTO_SUBMENU_DISPLAY_CONFIG.suppressEvent
       } 
    );


    /**
	 * @config showdelay
	 * @description Number indicating the time (in milliseconds) that should
	 *              expire before a submenu is made visible when the user mouses
	 *              over the menu's items. This property is only applied when
	 *              the "position" configuration property is set to dynamic and
	 *              is automatically applied to all submenus.
	 * @default 250
	 * @type Number
	 */
    oConfig.addProperty(
       SHOW_DELAY_CONFIG.key, 
       { 
           value: SHOW_DELAY_CONFIG.value, 
           validator: SHOW_DELAY_CONFIG.validator,
           suppressEvent: SHOW_DELAY_CONFIG.suppressEvent
       } 
    );


    /**
	 * @config hidedelay
	 * @description Number indicating the time (in milliseconds) that should
	 *              expire before the menu is hidden. This property is only
	 *              applied when the "position" configuration property is set to
	 *              dynamic and is automatically applied to all submenus.
	 * @default 0
	 * @type Number
	 */
    oConfig.addProperty(
       HIDE_DELAY_CONFIG.key, 
       { 
           handler: this.configHideDelay,
           value: HIDE_DELAY_CONFIG.value, 
           validator: HIDE_DELAY_CONFIG.validator, 
           suppressEvent: HIDE_DELAY_CONFIG.suppressEvent
       } 
    );


    /**
	 * @config submenuhidedelay
	 * @description Number indicating the time (in milliseconds) that should
	 *              expire before a submenu is hidden when the user mouses out
	 *              of a menu item heading in the direction of a submenu. The
	 *              value must be greater than or equal to the value specified
	 *              for the "showdelay" configuration property. This property is
	 *              only applied when the "position" configuration property is
	 *              set to dynamic and is automatically applied to all submenus.
	 * @default 250
	 * @type Number
	 */
    oConfig.addProperty(
       SUBMENU_HIDE_DELAY_CONFIG.key, 
       { 
           value: SUBMENU_HIDE_DELAY_CONFIG.value, 
           validator: SUBMENU_HIDE_DELAY_CONFIG.validator,
           suppressEvent: SUBMENU_HIDE_DELAY_CONFIG.suppressEvent
       } 
    );


    /**
	 * @config clicktohide
	 * @description Boolean indicating if the menu will automatically be hidden
	 *              if the user clicks outside of it. This property is only
	 *              applied when the "position" configuration property is set to
	 *              dynamic and is automatically applied to all submenus.
	 * @default true
	 * @type Boolean
	 */
    oConfig.addProperty(
        CLICK_TO_HIDE_CONFIG.key,
        {
            value: CLICK_TO_HIDE_CONFIG.value,
            validator: CLICK_TO_HIDE_CONFIG.validator,
            suppressEvent: CLICK_TO_HIDE_CONFIG.suppressEvent
        }
    );


    /**
	 * @config container
	 * @description HTML element reference or string specifying the id attribute
	 *              of the HTML element that the menu's markup should be
	 *              rendered into.
	 * @type <a href="http://www.w3.org/TR/2000/WD-DOM-Level-1-20000929/
	 *       level-one-html.html#ID-58190037">HTMLElement</a>|String
	 * @default document.body
	 */
    oConfig.addProperty(
       CONTAINER_CONFIG.key, 
       { 
           handler: this.configContainer,
           value: document.body,
           suppressEvent: CONTAINER_CONFIG.suppressEvent
       } 
   );


    /**
	 * @config scrollincrement
	 * @description Number used to control the scroll speed of a menu. Used to
	 *              increment the "scrollTop" property of the menu's body by
	 *              when a menu's content is scrolling. When set this property
	 *              is automatically applied to all submenus.
	 * @default 1
	 * @type Number
	 */
    oConfig.addProperty(
        SCROLL_INCREMENT_CONFIG.key, 
        { 
            value: SCROLL_INCREMENT_CONFIG.value, 
            validator: SCROLL_INCREMENT_CONFIG.validator,
            supercedes: SCROLL_INCREMENT_CONFIG.supercedes,
            suppressEvent: SCROLL_INCREMENT_CONFIG.suppressEvent
        }
    );


    /**
	 * @config minscrollheight
	 * @description Number defining the minimum threshold for the "maxheight"
	 *              configuration property. When set this property is
	 *              automatically applied to all submenus.
	 * @default 90
	 * @type Number
	 */
    oConfig.addProperty(
        MIN_SCROLL_HEIGHT_CONFIG.key, 
        { 
            value: MIN_SCROLL_HEIGHT_CONFIG.value, 
            validator: MIN_SCROLL_HEIGHT_CONFIG.validator,
            supercedes: MIN_SCROLL_HEIGHT_CONFIG.supercedes,
            suppressEvent: MIN_SCROLL_HEIGHT_CONFIG.suppressEvent
        }
    );


    /**
	 * @config maxheight
	 * @description Number defining the maximum height (in pixels) for a menu's
	 *              body element (<code>&#60;div class="bd"&#62;</code>).
	 *              Once a menu's body exceeds this height, the contents of the
	 *              body are scrolled to maintain this value. This value cannot
	 *              be set lower than the value of the "minscrollheight"
	 *              configuration property.
	 * @default 0
	 * @type Number
	 */
    oConfig.addProperty(
       MAX_HEIGHT_CONFIG.key, 
       {
            handler: this.configMaxHeight,
            value: MAX_HEIGHT_CONFIG.value,
            validator: MAX_HEIGHT_CONFIG.validator,
            suppressEvent: MAX_HEIGHT_CONFIG.suppressEvent,
            supercedes: MAX_HEIGHT_CONFIG.supercedes            
       } 
    );


    /**
	 * @config classname
	 * @description String representing the CSS class to be applied to the
	 *              menu's root <code>&#60;div&#62;</code> element. The
	 *              specified class(es) are appended in addition to the default
	 *              class as specified by the menu's CSS_CLASS_NAME constant.
	 *              When set this property is automatically applied to all
	 *              submenus.
	 * @default null
	 * @type String
	 */
    oConfig.addProperty(
        CLASS_NAME_CONFIG.key, 
        { 
            handler: this.configClassName,
            value: CLASS_NAME_CONFIG.value, 
            validator: CLASS_NAME_CONFIG.validator,
            supercedes: CLASS_NAME_CONFIG.supercedes      
        }
    );


    /**
	 * @config disabled
	 * @description Boolean indicating if the menu should be disabled. Disabling
	 *              a menu disables each of its items. (Disabled menu items are
	 *              dimmed and will not respond to user input or fire events.)
	 *              Disabled menus have a corresponding "disabled" CSS class
	 *              applied to their root <code>&#60;div&#62;</code> element.
	 * @default false
	 * @type Boolean
	 */
    oConfig.addProperty(
        DISABLED_CONFIG.key, 
        { 
            handler: this.configDisabled,
            value: DISABLED_CONFIG.value, 
            validator: DISABLED_CONFIG.validator,
            suppressEvent: DISABLED_CONFIG.suppressEvent
        }
    );


    /**
	 * @config shadow
	 * @description Boolean indicating if the menu should have a shadow.
	 * @default true
	 * @type Boolean
	 */
    oConfig.addProperty(
        SHADOW_CONFIG.key, 
        { 
            handler: this.configShadow,
            value: SHADOW_CONFIG.value, 
            validator: SHADOW_CONFIG.validator
        }
    );


    /**
	 * @config keepopen
	 * @description Boolean indicating if the menu should remain open when
	 *              clicked.
	 * @default false
	 * @type Boolean
	 */
    oConfig.addProperty(
        KEEP_OPEN_CONFIG.key, 
        { 
            value: KEEP_OPEN_CONFIG.value, 
            validator: KEEP_OPEN_CONFIG.validator
        }
    );

}

}); // END YAHOO.lang.extend

})();



(function () {

/**
 * Creates an item for a menu.
 * 
 * @param {HTML}
 *            p_oObject Markup for the menu item content. The markup is inserted
 *            into the DOM as HTML, and should be escaped by the implementor if
 *            coming from an external source.
 * @param {
 *            <a href="http://www.w3.org/TR/2000/WD-DOM-Level-1-20000929/level-
 *            one-html.html#ID-74680021">HTMLLIElement</a>} p_oObject Object
 *            specifying the <code>&#60;li&#62;</code> element of the menu
 *            item.
 * @param {
 *            <a href="http://www.w3.org/TR/2000/WD-DOM-Level-1-20000929/level-
 *            one-html.html#ID-38450247">HTMLOptGroupElement</a>} p_oObject
 *            Object specifying the <code>&#60;optgroup&#62;</code> element of
 *            the menu item.
 * @param {
 *            <a href="http://www.w3.org/TR/2000/WD-DOM-Level-1-20000929/level-
 *            one-html.html#ID-70901257">HTMLOptionElement</a>} p_oObject
 *            Object specifying the <code>&#60;option&#62;</code> element of
 *            the menu item.
 * @param {Object}
 *            p_oConfig Optional. Object literal specifying the configuration
 *            for the menu item. See configuration class documentation for more
 *            details.
 * @class MenuItem
 * @constructor
 */
YAHOO.widget.MenuItem = function (p_oObject, p_oConfig) {

    if (p_oObject) {

        if (p_oConfig) {
    
            this.parent = p_oConfig.parent;
            this.value = p_oConfig.value;
            this.id = p_oConfig.id;

        }

        this.init(p_oObject, p_oConfig);

    }

};


var Dom = YAHOO.util.Dom,
    Module = YAHOO.widget.Module,
    Menu = YAHOO.widget.Menu,
    MenuItem = YAHOO.widget.MenuItem,
    CustomEvent = YAHOO.util.CustomEvent,
    UA = YAHOO.env.ua,
    Lang = YAHOO.lang,

    // Private string constants

    _TEXT = "text",
    _HASH = "#",
    _HYPHEN = "-",
    _HELP_TEXT = "helptext",
    _URL = "url",
    _TARGET = "target",
    _EMPHASIS = "emphasis",
    _STRONG_EMPHASIS = "strongemphasis",
    _CHECKED = "checked",
    _SUBMENU = "submenu",
    _DISABLED = "disabled",
    _SELECTED = "selected",
    _HAS_SUBMENU = "hassubmenu",
    _CHECKED_DISABLED = "checked-disabled",
    _HAS_SUBMENU_DISABLED = "hassubmenu-disabled",
    _HAS_SUBMENU_SELECTED = "hassubmenu-selected",
    _CHECKED_SELECTED = "checked-selected",
    _ONCLICK = "onclick",
    _CLASSNAME = "classname",
    _EMPTY_STRING = "",
    _OPTION = "OPTION",
    _OPTGROUP = "OPTGROUP",
    _LI_UPPERCASE = "LI",
    _HREF = "href",
    _SELECT = "SELECT",
    _DIV = "DIV",
    _START_HELP_TEXT = "<em class=\"helptext\">",
    _START_EM = "<em>",
    _END_EM = "</em>",
    _START_STRONG = "<strong>",
    _END_STRONG = "</strong>",
    _PREVENT_CONTEXT_OVERLAP = "preventcontextoverlap",
    _OBJ = "obj",
    _SCOPE = "scope",
    _NONE = "none",
    _VISIBLE = "visible",
    _SPACE = " ",
    _MENUITEM = "MenuItem",
    _CLICK = "click",
    _SHOW = "show",
    _HIDE = "hide",
    _LI_LOWERCASE = "li",
    _ANCHOR_TEMPLATE = "<a href=\"#\"></a>",

    EVENT_TYPES = [
    
        ["mouseOverEvent", "mouseover"],
        ["mouseOutEvent", "mouseout"],
        ["mouseDownEvent", "mousedown"],
        ["mouseUpEvent", "mouseup"],
        ["clickEvent", _CLICK],
        ["keyPressEvent", "keypress"],
        ["keyDownEvent", "keydown"],
        ["keyUpEvent", "keyup"],
        ["focusEvent", "focus"],
        ["blurEvent", "blur"],
        ["destroyEvent", "destroy"]
    
    ],

    TEXT_CONFIG = { 
        key: _TEXT, 
        value: _EMPTY_STRING, 
        validator: Lang.isString, 
        suppressEvent: true 
    }, 

    HELP_TEXT_CONFIG = { 
        key: _HELP_TEXT,
        supercedes: [_TEXT], 
        suppressEvent: true 
    },

    URL_CONFIG = { 
        key: _URL, 
        value: _HASH, 
        suppressEvent: true 
    }, 

    TARGET_CONFIG = { 
        key: _TARGET, 
        suppressEvent: true 
    }, 

    EMPHASIS_CONFIG = { 
        key: _EMPHASIS, 
        value: false, 
        validator: Lang.isBoolean, 
        suppressEvent: true, 
        supercedes: [_TEXT]
    }, 

    STRONG_EMPHASIS_CONFIG = { 
        key: _STRONG_EMPHASIS, 
        value: false, 
        validator: Lang.isBoolean, 
        suppressEvent: true,
        supercedes: [_TEXT]
    },

    CHECKED_CONFIG = { 
        key: _CHECKED, 
        value: false, 
        validator: Lang.isBoolean, 
        suppressEvent: true, 
        supercedes: [_DISABLED, _SELECTED]
    }, 

    SUBMENU_CONFIG = { 
        key: _SUBMENU,
        suppressEvent: true,
        supercedes: [_DISABLED, _SELECTED]
    },

    DISABLED_CONFIG = { 
        key: _DISABLED, 
        value: false, 
        validator: Lang.isBoolean, 
        suppressEvent: true,
        supercedes: [_TEXT, _SELECTED]
    },

    SELECTED_CONFIG = { 
        key: _SELECTED, 
        value: false, 
        validator: Lang.isBoolean, 
        suppressEvent: true
    },

    ONCLICK_CONFIG = { 
        key: _ONCLICK,
        suppressEvent: true
    },

    CLASS_NAME_CONFIG = { 
        key: _CLASSNAME, 
        value: null, 
        validator: Lang.isString,
        suppressEvent: true
    },
    
    KEY_LISTENER_CONFIG = {
        key: "keylistener", 
        value: null, 
        suppressEvent: true
    },

    m_oMenuItemTemplate = null,

    CLASS_NAMES = {};


/**
 * @method getClassNameForState
 * @description Returns a class name for the specified prefix and state. If the
 *              class name does not yet exist, it is created and stored in the
 *              CLASS_NAMES object to increase performance.
 * @private
 * @param {String}
 *            prefix String representing the prefix for the class name
 * @param {String}
 *            state String representing a state - "disabled," "checked," etc.
 */  
var getClassNameForState = function (prefix, state) {

    var oClassNames = CLASS_NAMES[prefix];
    
    if (!oClassNames) {
        CLASS_NAMES[prefix] = {};
        oClassNames = CLASS_NAMES[prefix];
    }


    var sClassName = oClassNames[state];

    if (!sClassName) {
        sClassName = prefix + _HYPHEN + state;
        oClassNames[state] = sClassName;
    }

    return sClassName;
    
};


/**
 * @method addClassNameForState
 * @description Applies a class name to a MenuItem instance's &#60;LI&#62; and
 *              &#60;A&#62; elements that represents a MenuItem's state -
 *              "disabled," "checked," etc.
 * @private
 * @param {String}
 *            state String representing a state - "disabled," "checked," etc.
 */  
var addClassNameForState = function (state) {

    Dom.addClass(this.element, getClassNameForState(this.CSS_CLASS_NAME, state));
    Dom.addClass(this._oAnchor, getClassNameForState(this.CSS_LABEL_CLASS_NAME, state));

};

/**
 * @method removeClassNameForState
 * @description Removes a class name from a MenuItem instance's &#60;LI&#62; and
 *              &#60;A&#62; elements that represents a MenuItem's state -
 *              "disabled," "checked," etc.
 * @private
 * @param {String}
 *            state String representing a state - "disabled," "checked," etc.
 */  
var removeClassNameForState = function (state) {

    Dom.removeClass(this.element, getClassNameForState(this.CSS_CLASS_NAME, state));
    Dom.removeClass(this._oAnchor, getClassNameForState(this.CSS_LABEL_CLASS_NAME, state));

};


MenuItem.prototype = {

    /**
	 * @property CSS_CLASS_NAME
	 * @description String representing the CSS class(es) to be applied to the
	 *              <code>&#60;li&#62;</code> element of the menu item.
	 * @default "yuimenuitem"
	 * @final
	 * @type String
	 */
    CSS_CLASS_NAME: "yuimenuitem",


    /**
	 * @property CSS_LABEL_CLASS_NAME
	 * @description String representing the CSS class(es) to be applied to the
	 *              menu item's <code>&#60;a&#62;</code> element.
	 * @default "yuimenuitemlabel"
	 * @final
	 * @type String
	 */
    CSS_LABEL_CLASS_NAME: "yuimenuitemlabel",


    /**
	 * @property SUBMENU_TYPE
	 * @description Object representing the type of menu to instantiate and add
	 *              when parsing the child nodes of the menu item's source HTML
	 *              element.
	 * @final
	 * @type YAHOO.widget.Menu
	 */
    SUBMENU_TYPE: null,



    // Private member variables
    

    /**
	 * @property _oAnchor
	 * @description Object reference to the menu item's <code>&#60;a&#62;</code>
	 *              element.
	 * @default null
	 * @private
	 * @type <a href="http://www.w3.org/TR/2000/WD-DOM-Level-1-20000929/level-
	 *       one-html.html#ID-48250443">HTMLAnchorElement</a>
	 */
    _oAnchor: null,
    
    
    /**
	 * @property _oHelpTextEM
	 * @description Object reference to the menu item's help text
	 *              <code>&#60;em&#62;</code> element.
	 * @default null
	 * @private
	 * @type <a href="http://www.w3.org/TR/2000/WD-DOM-Level-1-20000929/level-
	 *       one-html.html#ID-58190037">HTMLElement</a>
	 */
    _oHelpTextEM: null,
    
    
    /**
	 * @property _oSubmenu
	 * @description Object reference to the menu item's submenu.
	 * @default null
	 * @private
	 * @type YAHOO.widget.Menu
	 */
    _oSubmenu: null,


    /**
	 * @property _oOnclickAttributeValue
	 * @description Object reference to the menu item's current value for the
	 *              "onclick" configuration attribute.
	 * @default null
	 * @private
	 * @type Object
	 */
    _oOnclickAttributeValue: null,


    /**
	 * @property _sClassName
	 * @description The current value of the "classname" configuration
	 *              attribute.
	 * @default null
	 * @private
	 * @type String
	 */
    _sClassName: null,



    // Public properties


    /**
	 * @property constructor
	 * @description Object reference to the menu item's constructor function.
	 * @default YAHOO.widget.MenuItem
	 * @type YAHOO.widget.MenuItem
	 */
    constructor: MenuItem,


    /**
	 * @property index
	 * @description Number indicating the ordinal position of the menu item in
	 *              its group.
	 * @default null
	 * @type Number
	 */
    index: null,


    /**
	 * @property groupIndex
	 * @description Number indicating the index of the group to which the menu
	 *              item belongs.
	 * @default null
	 * @type Number
	 */
    groupIndex: null,


    /**
	 * @property parent
	 * @description Object reference to the menu item's parent menu.
	 * @default null
	 * @type YAHOO.widget.Menu
	 */
    parent: null,


    /**
	 * @property element
	 * @description Object reference to the menu item's
	 *              <code>&#60;li&#62;</code> element.
	 * @default <a href="http://www.w3.org/TR/2000/WD-DOM-Level-1-20000929/level
	 *          -one-html.html#ID-74680021">HTMLLIElement</a>
	 * @type <a href="http://www.w3.org/TR/2000/WD-DOM-Level-1-20000929/level-
	 *       one-html.html#ID-74680021">HTMLLIElement</a>
	 */
    element: null,


    /**
	 * @property srcElement
	 * @description Object reference to the HTML element (either
	 *              <code>&#60;li&#62;</code>,
	 *              <code>&#60;optgroup&#62;</code> or
	 *              <code>&#60;option&#62;</code>) used create the menu item.
	 * @default <a href="http://www.w3.org/TR/2000/WD-DOM-Level-1-20000929/
	 *          level-one-html.html#ID-74680021">HTMLLIElement</a>|<a
	 *          href="http://www.
	 *          w3.org/TR/2000/WD-DOM-Level-1-20000929/level-one-html.html#ID-38450247"
	 *          >HTMLOptGroupElement</a>|<a
	 *          href="http://www.w3.org/TR/2000/WD-DOM-
	 *          Level-1-20000929/level-one-html.html#ID-70901257">HTMLOptionElement</a>
	 * @type <a href="http://www.w3.org/TR/2000/WD-DOM-Level-1-20000929/level-
	 *       one-html.html#ID-74680021">HTMLLIElement</a>|<a
	 *       href="http://www.w3.
	 *       org/TR/2000/WD-DOM-Level-1-20000929/level-one-html.html#ID-38450247">
	 *       HTMLOptGroupElement</a>|<a
	 *       href="http://www.w3.org/TR/2000/WD-DOM-
	 *       Level-1-20000929/level-one-html.html#ID-70901257">HTMLOptionElement</a>
	 */
    srcElement: null,


    /**
	 * @property value
	 * @description Object reference to the menu item's value.
	 * @default null
	 * @type Object
	 */
    value: null,


    /**
	 * @property browser
	 * @deprecated Use YAHOO.env.ua
	 * @description String representing the browser.
	 * @type String
	 */
    browser: Module.prototype.browser,


    /**
	 * @property id
	 * @description Id of the menu item's root <code>&#60;li&#62;</code>
	 *              element. This property should be set via the constructor
	 *              using the configuration object literal. If an id is not
	 *              specified, then one will be created using the "generateId"
	 *              method of the Dom utility.
	 * @default null
	 * @type String
	 */
    id: null,



    // Events


    /**
	 * @event destroyEvent
	 * @description Fires when the menu item's <code>&#60;li&#62;</code>
	 *              element is removed from its parent <code>&#60;ul&#62;</code>
	 *              element.
	 * @type YAHOO.util.CustomEvent
	 */


    /**
	 * @event mouseOverEvent
	 * @description Fires when the mouse has entered the menu item. Passes back
	 *              the DOM Event object as an argument.
	 * @type YAHOO.util.CustomEvent
	 */


    /**
	 * @event mouseOutEvent
	 * @description Fires when the mouse has left the menu item. Passes back the
	 *              DOM Event object as an argument.
	 * @type YAHOO.util.CustomEvent
	 */


    /**
	 * @event mouseDownEvent
	 * @description Fires when the user mouses down on the menu item. Passes
	 *              back the DOM Event object as an argument.
	 * @type YAHOO.util.CustomEvent
	 */


    /**
	 * @event mouseUpEvent
	 * @description Fires when the user releases a mouse button while the mouse
	 *              is over the menu item. Passes back the DOM Event object as
	 *              an argument.
	 * @type YAHOO.util.CustomEvent
	 */


    /**
	 * @event clickEvent
	 * @description Fires when the user clicks the on the menu item. Passes back
	 *              the DOM Event object as an argument.
	 * @type YAHOO.util.CustomEvent
	 */


    /**
	 * @event keyPressEvent
	 * @description Fires when the user presses an alphanumeric key when the
	 *              menu item has focus. Passes back the DOM Event object as an
	 *              argument.
	 * @type YAHOO.util.CustomEvent
	 */


    /**
	 * @event keyDownEvent
	 * @description Fires when the user presses a key when the menu item has
	 *              focus. Passes back the DOM Event object as an argument.
	 * @type YAHOO.util.CustomEvent
	 */


    /**
	 * @event keyUpEvent
	 * @description Fires when the user releases a key when the menu item has
	 *              focus. Passes back the DOM Event object as an argument.
	 * @type YAHOO.util.CustomEvent
	 */


    /**
	 * @event focusEvent
	 * @description Fires when the menu item receives focus.
	 * @type YAHOO.util.CustomEvent
	 */


    /**
	 * @event blurEvent
	 * @description Fires when the menu item loses the input focus.
	 * @type YAHOO.util.CustomEvent
	 */


    /**
	 * @method init
	 * @description The MenuItem class's initialization method. This method is
	 *              automatically called by the constructor, and sets up all DOM
	 *              references for pre-existing markup, and creates required
	 *              markup if it is not already present.
	 * @param {HTML}
	 *            p_oObject Markup for the menu item content. The markup is
	 *            inserted into the DOM as HTML, and should be escaped by the
	 *            implementor if coming from an external source.
	 * @param {
	 *            <a
	 *            href="http://www.w3.org/TR/2000/WD-DOM-Level-1-20000929/level-
	 *            one-html.html#ID-74680021">HTMLLIElement</a>} p_oObject
	 *            Object specifying the <code>&#60;li&#62;</code> element of
	 *            the menu item.
	 * @param {
	 *            <a
	 *            href="http://www.w3.org/TR/2000/WD-DOM-Level-1-20000929/level-
	 *            one-html.html#ID-38450247">HTMLOptGroupElement</a>} p_oObject
	 *            Object specifying the <code>&#60;optgroup&#62;</code>
	 *            element of the menu item.
	 * @param {
	 *            <a
	 *            href="http://www.w3.org/TR/2000/WD-DOM-Level-1-20000929/level-
	 *            one-html.html#ID-70901257">HTMLOptionElement</a>} p_oObject
	 *            Object specifying the <code>&#60;option&#62;</code> element
	 *            of the menu item.
	 * @param {Object}
	 *            p_oConfig Optional. Object literal specifying the
	 *            configuration for the menu item. See configuration class
	 *            documentation for more details.
	 */
    init: function (p_oObject, p_oConfig) {


        if (!this.SUBMENU_TYPE) {
    
            this.SUBMENU_TYPE = Menu;
    
        }


        // Create the config object

        this.cfg = new YAHOO.util.Config(this);

        this.initDefaultConfig();

        var oConfig = this.cfg,
            sURL = _HASH,
            oCustomEvent,
            aEventData,
            oAnchor,
            sTarget,
            sText,
            sId,
            i;


        if (Lang.isString(p_oObject)) {

            this._createRootNodeStructure();

            oConfig.queueProperty(_TEXT, p_oObject);

        }
        else if (p_oObject && p_oObject.tagName) {

            switch(p_oObject.tagName.toUpperCase()) {

                case _OPTION:

                    this._createRootNodeStructure();

                    oConfig.queueProperty(_TEXT, p_oObject.text);
                    oConfig.queueProperty(_DISABLED, p_oObject.disabled);

                    this.value = p_oObject.value;

                    this.srcElement = p_oObject;

                break;

                case _OPTGROUP:

                    this._createRootNodeStructure();

                    oConfig.queueProperty(_TEXT, p_oObject.label);
                    oConfig.queueProperty(_DISABLED, p_oObject.disabled);

                    this.srcElement = p_oObject;

                    this._initSubTree();

                break;

                case _LI_UPPERCASE:

                    // Get the anchor node (if it exists)
                    
                    oAnchor = Dom.getFirstChild(p_oObject);


                    // Capture the "text" and/or the "URL"

                    if (oAnchor) {

                        sURL = oAnchor.getAttribute(_HREF, 2);
                        sTarget = oAnchor.getAttribute(_TARGET);

                        sText = oAnchor.innerHTML;

                    }

                    this.srcElement = p_oObject;
                    this.element = p_oObject;
                    this._oAnchor = oAnchor;

                    /*
					 * Set these properties silently to sync up the
					 * configuration object without making changes to the
					 * element's DOM
					 */ 

                    oConfig.setProperty(_TEXT, sText, true);
                    oConfig.setProperty(_URL, sURL, true);
                    oConfig.setProperty(_TARGET, sTarget, true);

                    this._initSubTree();

                break;

            }            

        }


        if (this.element) {

            sId = (this.srcElement || this.element).id;

            if (!sId) {

                sId = this.id || Dom.generateId();

                this.element.id = sId;

            }

            this.id = sId;


            Dom.addClass(this.element, this.CSS_CLASS_NAME);
            Dom.addClass(this._oAnchor, this.CSS_LABEL_CLASS_NAME);


            i = EVENT_TYPES.length - 1;

            do {

                aEventData = EVENT_TYPES[i];

                oCustomEvent = this.createEvent(aEventData[1]);
                oCustomEvent.signature = CustomEvent.LIST;
                
                this[aEventData[0]] = oCustomEvent;

            }
            while (i--);


            if (p_oConfig) {
    
                oConfig.applyConfig(p_oConfig);
    
            }        

            oConfig.fireQueue();

        }

    },



    // Private methods

    /**
	 * @method _createRootNodeStructure
	 * @description Creates the core DOM structure for the menu item.
	 * @private
	 */
    _createRootNodeStructure: function () {

        var oElement,
            oAnchor;

        if (!m_oMenuItemTemplate) {

            m_oMenuItemTemplate = document.createElement(_LI_LOWERCASE);
            m_oMenuItemTemplate.innerHTML = _ANCHOR_TEMPLATE;

        }

        oElement = m_oMenuItemTemplate.cloneNode(true);
        oElement.className = this.CSS_CLASS_NAME;

        oAnchor = oElement.firstChild;
        oAnchor.className = this.CSS_LABEL_CLASS_NAME;

        this.element = oElement;
        this._oAnchor = oAnchor;

    },


    /**
	 * @method _initSubTree
	 * @description Iterates the source element's childNodes collection and uses
	 *              the child nodes to instantiate other menus.
	 * @private
	 */
    _initSubTree: function () {

        var oSrcEl = this.srcElement,
            oConfig = this.cfg,
            oNode,
            aOptions,
            nOptions,
            oMenu,
            n;


        if (oSrcEl.childNodes.length > 0) {

            if (this.parent.lazyLoad && this.parent.srcElement && 
                this.parent.srcElement.tagName.toUpperCase() == _SELECT) {

                oConfig.setProperty(
                        _SUBMENU, 
                        { id: Dom.generateId(), itemdata: oSrcEl.childNodes }
                    );

            }
            else {

                oNode = oSrcEl.firstChild;
                aOptions = [];
    
                do {
    
                    if (oNode && oNode.tagName) {
    
                        switch(oNode.tagName.toUpperCase()) {
                
                            case _DIV:
                
                                oConfig.setProperty(_SUBMENU, oNode);
                
                            break;
         
                            case _OPTION:
        
                                aOptions[aOptions.length] = oNode;
        
                            break;
               
                        }
                    
                    }
                
                }        
                while((oNode = oNode.nextSibling));
    
    
                nOptions = aOptions.length;
    
                if (nOptions > 0) {
    
                    oMenu = new this.SUBMENU_TYPE(Dom.generateId());
                    
                    oConfig.setProperty(_SUBMENU, oMenu);
    
                    for(n=0; n<nOptions; n++) {
        
                        oMenu.addItem((new oMenu.ITEM_TYPE(aOptions[n])));
        
                    }
        
                }
            
            }

        }

    },



    // Event handlers for configuration properties


    /**
	 * @method configText
	 * @description Event handler for when the "text" configuration property of
	 *              the menu item changes.
	 * @param {String}
	 *            p_sType String representing the name of the event that was
	 *            fired.
	 * @param {Array}
	 *            p_aArgs Array of arguments sent when the event was fired.
	 * @param {YAHOO.widget.MenuItem}
	 *            p_oItem Object representing the menu item that fired the
	 *            event.
	 */
    configText: function (p_sType, p_aArgs, p_oItem) {

        var sText = p_aArgs[0],
            oConfig = this.cfg,
            oAnchor = this._oAnchor,
            sHelpText = oConfig.getProperty(_HELP_TEXT),
            sHelpTextHTML = _EMPTY_STRING,
            sEmphasisStartTag = _EMPTY_STRING,
            sEmphasisEndTag = _EMPTY_STRING;


        if (sText) {


            if (sHelpText) {
                    
                sHelpTextHTML = _START_HELP_TEXT + sHelpText + _END_EM;
            
            }


            if (oConfig.getProperty(_EMPHASIS)) {

                sEmphasisStartTag = _START_EM;
                sEmphasisEndTag = _END_EM;

            }


            if (oConfig.getProperty(_STRONG_EMPHASIS)) {

                sEmphasisStartTag = _START_STRONG;
                sEmphasisEndTag = _END_STRONG;
            
            }


            oAnchor.innerHTML = (sEmphasisStartTag + sText + sEmphasisEndTag + sHelpTextHTML);

        }

    },


    /**
	 * @method configHelpText
	 * @description Event handler for when the "helptext" configuration property
	 *              of the menu item changes.
	 * @param {String}
	 *            p_sType String representing the name of the event that was
	 *            fired.
	 * @param {Array}
	 *            p_aArgs Array of arguments sent when the event was fired.
	 * @param {YAHOO.widget.MenuItem}
	 *            p_oItem Object representing the menu item that fired the
	 *            event.
	 */    
    configHelpText: function (p_sType, p_aArgs, p_oItem) {

        this.cfg.refireEvent(_TEXT);

    },


    /**
	 * @method configURL
	 * @description Event handler for when the "url" configuration property of
	 *              the menu item changes.
	 * @param {String}
	 *            p_sType String representing the name of the event that was
	 *            fired.
	 * @param {Array}
	 *            p_aArgs Array of arguments sent when the event was fired.
	 * @param {YAHOO.widget.MenuItem}
	 *            p_oItem Object representing the menu item that fired the
	 *            event.
	 */    
    configURL: function (p_sType, p_aArgs, p_oItem) {

        var sURL = p_aArgs[0];

        if (!sURL) {

            sURL = _HASH;

        }

        var oAnchor = this._oAnchor;

        if (UA.opera) {

            oAnchor.removeAttribute(_HREF);
        
        }

        oAnchor.setAttribute(_HREF, sURL);

    },


    /**
	 * @method configTarget
	 * @description Event handler for when the "target" configuration property
	 *              of the menu item changes.
	 * @param {String}
	 *            p_sType String representing the name of the event that was
	 *            fired.
	 * @param {Array}
	 *            p_aArgs Array of arguments sent when the event was fired.
	 * @param {YAHOO.widget.MenuItem}
	 *            p_oItem Object representing the menu item that fired the
	 *            event.
	 */    
    configTarget: function (p_sType, p_aArgs, p_oItem) {

        var sTarget = p_aArgs[0],
            oAnchor = this._oAnchor;

        if (sTarget && sTarget.length > 0) {

            oAnchor.setAttribute(_TARGET, sTarget);

        }
        else {

            oAnchor.removeAttribute(_TARGET);
        
        }

    },


    /**
	 * @method configEmphasis
	 * @description Event handler for when the "emphasis" configuration property
	 *              of the menu item changes.
	 * @param {String}
	 *            p_sType String representing the name of the event that was
	 *            fired.
	 * @param {Array}
	 *            p_aArgs Array of arguments sent when the event was fired.
	 * @param {YAHOO.widget.MenuItem}
	 *            p_oItem Object representing the menu item that fired the
	 *            event.
	 */    
    configEmphasis: function (p_sType, p_aArgs, p_oItem) {

        var bEmphasis = p_aArgs[0],
            oConfig = this.cfg;


        if (bEmphasis && oConfig.getProperty(_STRONG_EMPHASIS)) {

            oConfig.setProperty(_STRONG_EMPHASIS, false);

        }


        oConfig.refireEvent(_TEXT);

    },


    /**
	 * @method configStrongEmphasis
	 * @description Event handler for when the "strongemphasis" configuration
	 *              property of the menu item changes.
	 * @param {String}
	 *            p_sType String representing the name of the event that was
	 *            fired.
	 * @param {Array}
	 *            p_aArgs Array of arguments sent when the event was fired.
	 * @param {YAHOO.widget.MenuItem}
	 *            p_oItem Object representing the menu item that fired the
	 *            event.
	 */    
    configStrongEmphasis: function (p_sType, p_aArgs, p_oItem) {

        var bStrongEmphasis = p_aArgs[0],
            oConfig = this.cfg;


        if (bStrongEmphasis && oConfig.getProperty(_EMPHASIS)) {

            oConfig.setProperty(_EMPHASIS, false);

        }

        oConfig.refireEvent(_TEXT);

    },


    /**
	 * @method configChecked
	 * @description Event handler for when the "checked" configuration property
	 *              of the menu item changes.
	 * @param {String}
	 *            p_sType String representing the name of the event that was
	 *            fired.
	 * @param {Array}
	 *            p_aArgs Array of arguments sent when the event was fired.
	 * @param {YAHOO.widget.MenuItem}
	 *            p_oItem Object representing the menu item that fired the
	 *            event.
	 */    
    configChecked: function (p_sType, p_aArgs, p_oItem) {

        var bChecked = p_aArgs[0],
            oConfig = this.cfg;


        if (bChecked) {

            addClassNameForState.call(this, _CHECKED);

        }
        else {

            removeClassNameForState.call(this, _CHECKED);
        }


        oConfig.refireEvent(_TEXT);


        if (oConfig.getProperty(_DISABLED)) {

            oConfig.refireEvent(_DISABLED);

        }


        if (oConfig.getProperty(_SELECTED)) {

            oConfig.refireEvent(_SELECTED);

        }

    },



    /**
	 * @method configDisabled
	 * @description Event handler for when the "disabled" configuration property
	 *              of the menu item changes.
	 * @param {String}
	 *            p_sType String representing the name of the event that was
	 *            fired.
	 * @param {Array}
	 *            p_aArgs Array of arguments sent when the event was fired.
	 * @param {YAHOO.widget.MenuItem}
	 *            p_oItem Object representing the menu item that fired the
	 *            event.
	 */    
    configDisabled: function (p_sType, p_aArgs, p_oItem) {

        var bDisabled = p_aArgs[0],
            oConfig = this.cfg,
            oSubmenu = oConfig.getProperty(_SUBMENU),
            bChecked = oConfig.getProperty(_CHECKED);


        if (bDisabled) {

            if (oConfig.getProperty(_SELECTED)) {

                oConfig.setProperty(_SELECTED, false);

            }


            addClassNameForState.call(this, _DISABLED);


            if (oSubmenu) {

                addClassNameForState.call(this, _HAS_SUBMENU_DISABLED);
            
            }
            

            if (bChecked) {

                addClassNameForState.call(this, _CHECKED_DISABLED);

            }

        }
        else {

            removeClassNameForState.call(this, _DISABLED);


            if (oSubmenu) {

                removeClassNameForState.call(this, _HAS_SUBMENU_DISABLED);
            
            }
            

            if (bChecked) {

                removeClassNameForState.call(this, _CHECKED_DISABLED);

            }

        }

    },


    /**
	 * @method configSelected
	 * @description Event handler for when the "selected" configuration property
	 *              of the menu item changes.
	 * @param {String}
	 *            p_sType String representing the name of the event that was
	 *            fired.
	 * @param {Array}
	 *            p_aArgs Array of arguments sent when the event was fired.
	 * @param {YAHOO.widget.MenuItem}
	 *            p_oItem Object representing the menu item that fired the
	 *            event.
	 */    
    configSelected: function (p_sType, p_aArgs, p_oItem) {

        var oConfig = this.cfg,
            oAnchor = this._oAnchor,
            
            bSelected = p_aArgs[0],
            bChecked = oConfig.getProperty(_CHECKED),
            oSubmenu = oConfig.getProperty(_SUBMENU);


        if (UA.opera) {

            oAnchor.blur();
        
        }


        if (bSelected && !oConfig.getProperty(_DISABLED)) {

            addClassNameForState.call(this, _SELECTED);


            if (oSubmenu) {

                addClassNameForState.call(this, _HAS_SUBMENU_SELECTED);
            
            }


            if (bChecked) {

                addClassNameForState.call(this, _CHECKED_SELECTED);

            }

        }
        else {

            removeClassNameForState.call(this, _SELECTED);


            if (oSubmenu) {

                removeClassNameForState.call(this, _HAS_SUBMENU_SELECTED);
            
            }


            if (bChecked) {

                removeClassNameForState.call(this, _CHECKED_SELECTED);

            }

        }


        if (this.hasFocus() && UA.opera) {
        
            oAnchor.focus();
        
        }

    },


    /**
	 * @method _onSubmenuBeforeHide
	 * @description "beforehide" Custom Event handler for a submenu.
	 * @private
	 * @param {String}
	 *            p_sType String representing the name of the event that was
	 *            fired.
	 * @param {Array}
	 *            p_aArgs Array of arguments sent when the event was fired.
	 */
    _onSubmenuBeforeHide: function (p_sType, p_aArgs) {

        var oItem = this.parent,
            oMenu;

        function onHide() {

            oItem._oAnchor.blur();
            oMenu.beforeHideEvent.unsubscribe(onHide);
        
        }


        if (oItem.hasFocus()) {

            oMenu = oItem.parent;

            oMenu.beforeHideEvent.subscribe(onHide);
        
        }
    
    },


    /**
	 * @method configSubmenu
	 * @description Event handler for when the "submenu" configuration property
	 *              of the menu item changes.
	 * @param {String}
	 *            p_sType String representing the name of the event that was
	 *            fired.
	 * @param {Array}
	 *            p_aArgs Array of arguments sent when the event was fired.
	 * @param {YAHOO.widget.MenuItem}
	 *            p_oItem Object representing the menu item that fired the
	 *            event.
	 */
    configSubmenu: function (p_sType, p_aArgs, p_oItem) {

        var oSubmenu = p_aArgs[0],
            oConfig = this.cfg,
            bLazyLoad = this.parent && this.parent.lazyLoad,
            oMenu,
            sSubmenuId,
            oSubmenuConfig;


        if (oSubmenu) {

            if (oSubmenu instanceof Menu) {

                oMenu = oSubmenu;
                oMenu.parent = this;
                oMenu.lazyLoad = bLazyLoad;

            }
            else if (Lang.isObject(oSubmenu) && oSubmenu.id && !oSubmenu.nodeType) {

                sSubmenuId = oSubmenu.id;
                oSubmenuConfig = oSubmenu;

                oSubmenuConfig.lazyload = bLazyLoad;
                oSubmenuConfig.parent = this;

                oMenu = new this.SUBMENU_TYPE(sSubmenuId, oSubmenuConfig);


                // Set the value of the property to the Menu instance

                oConfig.setProperty(_SUBMENU, oMenu, true);

            }
            else {

                oMenu = new this.SUBMENU_TYPE(oSubmenu, { lazyload: bLazyLoad, parent: this });


                // Set the value of the property to the Menu instance
                
                oConfig.setProperty(_SUBMENU, oMenu, true);

            }


            if (oMenu) {

                oMenu.cfg.setProperty(_PREVENT_CONTEXT_OVERLAP, true);

                addClassNameForState.call(this, _HAS_SUBMENU);


                if (oConfig.getProperty(_URL) === _HASH) {
                
                    oConfig.setProperty(_URL, (_HASH + oMenu.id));
                
                }


                this._oSubmenu = oMenu;


                if (UA.opera) {
                
                    oMenu.beforeHideEvent.subscribe(this._onSubmenuBeforeHide);               
                
                }
            
            }

        }
        else {

            removeClassNameForState.call(this, _HAS_SUBMENU);

            if (this._oSubmenu) {

                this._oSubmenu.destroy();

            }

        }


        if (oConfig.getProperty(_DISABLED)) {

            oConfig.refireEvent(_DISABLED);

        }


        if (oConfig.getProperty(_SELECTED)) {

            oConfig.refireEvent(_SELECTED);

        }

    },


    /**
	 * @method configOnClick
	 * @description Event handler for when the "onclick" configuration property
	 *              of the menu item changes.
	 * @param {String}
	 *            p_sType String representing the name of the event that was
	 *            fired.
	 * @param {Array}
	 *            p_aArgs Array of arguments sent when the event was fired.
	 * @param {YAHOO.widget.MenuItem}
	 *            p_oItem Object representing the menu item that fired the
	 *            event.
	 */
    configOnClick: function (p_sType, p_aArgs, p_oItem) {

        var oObject = p_aArgs[0];

        /*
		 * Remove any existing listeners if a "click" event handler has already
		 * been specified.
		 */

        if (this._oOnclickAttributeValue && (this._oOnclickAttributeValue != oObject)) {

            this.clickEvent.unsubscribe(this._oOnclickAttributeValue.fn, 
                                this._oOnclickAttributeValue.obj);

            this._oOnclickAttributeValue = null;

        }


        if (!this._oOnclickAttributeValue && Lang.isObject(oObject) && 
            Lang.isFunction(oObject.fn)) {
            
            this.clickEvent.subscribe(oObject.fn, 
                ((_OBJ in oObject) ? oObject.obj : this), 
                ((_SCOPE in oObject) ? oObject.scope : null) );

            this._oOnclickAttributeValue = oObject;

        }
    
    },


    /**
	 * @method configClassName
	 * @description Event handler for when the "classname" configuration
	 *              property of a menu item changes.
	 * @param {String}
	 *            p_sType String representing the name of the event that was
	 *            fired.
	 * @param {Array}
	 *            p_aArgs Array of arguments sent when the event was fired.
	 * @param {YAHOO.widget.MenuItem}
	 *            p_oItem Object representing the menu item that fired the
	 *            event.
	 */
    configClassName: function (p_sType, p_aArgs, p_oItem) {
    
        var sClassName = p_aArgs[0];
    
        if (this._sClassName) {
    
            Dom.removeClass(this.element, this._sClassName);
    
        }
    
        Dom.addClass(this.element, sClassName);
        this._sClassName = sClassName;
    
    },


    /**
	 * @method _dispatchClickEvent
	 * @description Dispatches a DOM "click" event to the anchor element of a
	 *              MenuItem instance.
	 * @private
	 */
    _dispatchClickEvent: function () {

        var oMenuItem = this,
            oAnchor;

        if (!oMenuItem.cfg.getProperty(_DISABLED)) {
            oAnchor = Dom.getFirstChild(oMenuItem.element);

            // Dispatch a "click" event to the MenuItem's anchor so that its
            // "click" event handlers will get called in response to the user
            // pressing the keyboard shortcut defined by the "keylistener"
            // configuration property.

            this._dispatchDOMClick(oAnchor);
        }
    },

    /**
	 * Utility method to dispatch a DOM click event on the HTMLElement passed in
	 * 
	 * @method _dispatchDOMClick
	 * @protected
	 * @param {HTMLElement}
	 *            el
	 */    
    _dispatchDOMClick : function(el) {
        var oEvent;

        // Choose the standards path for IE9
        if (UA.ie && UA.ie < 9) {
            el.fireEvent(_ONCLICK);
        } else {
            if ((UA.gecko && UA.gecko >= 1.9) || UA.opera || UA.webkit) {
                oEvent = document.createEvent("HTMLEvents");
                oEvent.initEvent(_CLICK, true, true);
            } else {
                oEvent = document.createEvent("MouseEvents");
                oEvent.initMouseEvent(_CLICK, true, true, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);
            }
            el.dispatchEvent(oEvent);
        }
    },

    /**
	 * @method _createKeyListener
	 * @description "show" event handler for a Menu instance - responsible for
	 *              setting up the KeyListener instance for a MenuItem.
	 * @private
	 * @param {String}
	 *            type String representing the name of the event that was fired.
	 * @param {Array}
	 *            args Array of arguments sent when the event was fired.
	 * @param {Array}
	 *            keyData Array of arguments sent when the event was fired.
	 */
    _createKeyListener: function (type, args, keyData) {

        var oMenuItem = this,
            oMenu = oMenuItem.parent;

        var oKeyListener = new YAHOO.util.KeyListener(
                                        oMenu.element.ownerDocument, 
                                        keyData, 
                                        {
                                            fn: oMenuItem._dispatchClickEvent, 
                                            scope: oMenuItem, 
                                            correctScope: true });


        if (oMenu.cfg.getProperty(_VISIBLE)) {
            oKeyListener.enable();
        }


        oMenu.subscribe(_SHOW, oKeyListener.enable, null, oKeyListener);
        oMenu.subscribe(_HIDE, oKeyListener.disable, null, oKeyListener);
        
        oMenuItem._keyListener = oKeyListener;
        
        oMenu.unsubscribe(_SHOW, oMenuItem._createKeyListener, keyData);
        
    },


    /**
	 * @method configKeyListener
	 * @description Event handler for when the "keylistener" configuration
	 *              property of a menu item changes.
	 * @param {String}
	 *            p_sType String representing the name of the event that was
	 *            fired.
	 * @param {Array}
	 *            p_aArgs Array of arguments sent when the event was fired.
	 */
    configKeyListener: function (p_sType, p_aArgs) {

        var oKeyData = p_aArgs[0],
            oMenuItem = this,
            oMenu = oMenuItem.parent;

        if (oMenuItem._keyData) {

            // Unsubscribe from the "show" event in case the keylistener
            // config was changed before the Menu was ever made visible.

            oMenu.unsubscribe(_SHOW, 
                    oMenuItem._createKeyListener, oMenuItem._keyData);

            oMenuItem._keyData = null;					
                    
        }


        // Tear down for the previous value of the "keylistener" property

        if (oMenuItem._keyListener) {

            oMenu.unsubscribe(_SHOW, oMenuItem._keyListener.enable);
            oMenu.unsubscribe(_HIDE, oMenuItem._keyListener.disable);

            oMenuItem._keyListener.disable();
            oMenuItem._keyListener = null;

        }


        if (oKeyData) {
    
            oMenuItem._keyData = oKeyData;

            // Defer the creation of the KeyListener instance until the
            // parent Menu is visible. This is necessary since the
            // KeyListener instance needs to be bound to the document the
            // Menu has been rendered into. Deferring creation of the
            // KeyListener instance also improves performance.

            oMenu.subscribe(_SHOW, oMenuItem._createKeyListener, 
                oKeyData, oMenuItem);
        }
    
    },


    // Public methods


    /**
	 * @method initDefaultConfig
	 * @description Initializes an item's configurable properties.
	 */
    initDefaultConfig : function () {

        var oConfig = this.cfg;


        // Define the configuration attributes

        /**
		 * @config text
		 * @description String or markup specifying the text label for the menu
		 *              item. When building a menu from existing HTML the value
		 *              of this property will be interpreted from the menu's
		 *              markup. The text is inserted into the DOM as HTML, and
		 *              should be escaped by the implementor if coming from an
		 *              external source.
		 * @default ""
		 * @type HTML
		 */
        oConfig.addProperty(
            TEXT_CONFIG.key, 
            { 
                handler: this.configText, 
                value: TEXT_CONFIG.value, 
                validator: TEXT_CONFIG.validator, 
                suppressEvent: TEXT_CONFIG.suppressEvent 
            }
        );
        

        /**
		 * @config helptext
		 * @description String or markup specifying additional instructional
		 *              text to accompany the text for the menu item. The
		 *              helptext is inserted into the DOM as HTML, and should be
		 *              escaped by the implementor if coming from an external
		 *              source.
		 * @deprecated Use "text" configuration property to add help text
		 *             markup. For example:
		 *             <code>oMenuItem.cfg.setProperty("text", "Copy &#60;em 
        * class=\"helptext\"&#62;Ctrl + C&#60;/em&#62;");</code>
		 * @default null
		 * @type HTML|<a href="http://www.w3.org/TR/
		 *       2000/WD-DOM-Level-1-20000929/level-one-html.html#ID-58190037">
		 *       HTMLElement</a>
		 */
        oConfig.addProperty(
            HELP_TEXT_CONFIG.key,
            {
                handler: this.configHelpText, 
                supercedes: HELP_TEXT_CONFIG.supercedes,
                suppressEvent: HELP_TEXT_CONFIG.suppressEvent 
            }
        );


        /**
		 * @config url
		 * @description String specifying the URL for the menu item's anchor's
		 *              "href" attribute. When building a menu from existing
		 *              HTML the value of this property will be interpreted from
		 *              the menu's markup. Markup for the menu item content. The
		 *              url is inserted into the DOM as an attribute value, and
		 *              should be escaped by the implementor if coming from an
		 *              external source.
		 * @default "#"
		 * @type String
		 */        
        oConfig.addProperty(
            URL_CONFIG.key, 
            {
                handler: this.configURL, 
                value: URL_CONFIG.value, 
                suppressEvent: URL_CONFIG.suppressEvent
            }
        );


        /**
		 * @config target
		 * @description String specifying the value for the "target" attribute
		 *              of the menu item's anchor element. <strong>Specifying a
		 *              target will require the user to click directly on the
		 *              menu item's anchor node in order to cause the browser to
		 *              navigate to the specified URL.</strong> When building a
		 *              menu from existing HTML the value of this property will
		 *              be interpreted from the menu's markup. The target is
		 *              inserted into the DOM as an attribute value, and should
		 *              be escaped by the implementor if coming from an external
		 *              source.
		 * @default null
		 * @type String
		 */        
        oConfig.addProperty(
            TARGET_CONFIG.key, 
            {
                handler: this.configTarget, 
                suppressEvent: TARGET_CONFIG.suppressEvent
            }
        );


        /**
		 * @config emphasis
		 * @description Boolean indicating if the text of the menu item will be
		 *              rendered with emphasis.
		 * @deprecated Use the "text" configuration property to add emphasis.
		 *             For example:
		 *             <code>oMenuItem.cfg.setProperty("text", "&#60;em&#62;Some 
        * Text&#60;/em&#62;");</code>
		 * @default false
		 * @type Boolean
		 */
        oConfig.addProperty(
            EMPHASIS_CONFIG.key, 
            { 
                handler: this.configEmphasis, 
                value: EMPHASIS_CONFIG.value, 
                validator: EMPHASIS_CONFIG.validator, 
                suppressEvent: EMPHASIS_CONFIG.suppressEvent,
                supercedes: EMPHASIS_CONFIG.supercedes
            }
        );


        /**
		 * @config strongemphasis
		 * @description Boolean indicating if the text of the menu item will be
		 *              rendered with strong emphasis.
		 * @deprecated Use the "text" configuration property to add strong
		 *             emphasis. For example:
		 *             <code>oMenuItem.cfg.setProperty("text", "&#60;strong&#62; 
        * Some Text&#60;/strong&#62;");</code>
		 * @default false
		 * @type Boolean
		 */
        oConfig.addProperty(
            STRONG_EMPHASIS_CONFIG.key,
            {
                handler: this.configStrongEmphasis,
                value: STRONG_EMPHASIS_CONFIG.value,
                validator: STRONG_EMPHASIS_CONFIG.validator,
                suppressEvent: STRONG_EMPHASIS_CONFIG.suppressEvent,
                supercedes: STRONG_EMPHASIS_CONFIG.supercedes
            }
        );


        /**
		 * @config checked
		 * @description Boolean indicating if the menu item should be rendered
		 *              with a checkmark.
		 * @default false
		 * @type Boolean
		 */
        oConfig.addProperty(
            CHECKED_CONFIG.key, 
            {
                handler: this.configChecked, 
                value: CHECKED_CONFIG.value, 
                validator: CHECKED_CONFIG.validator, 
                suppressEvent: CHECKED_CONFIG.suppressEvent,
                supercedes: CHECKED_CONFIG.supercedes
            } 
        );


        /**
		 * @config disabled
		 * @description Boolean indicating if the menu item should be disabled.
		 *              (Disabled menu items are dimmed and will not respond to
		 *              user input or fire events.)
		 * @default false
		 * @type Boolean
		 */
        oConfig.addProperty(
            DISABLED_CONFIG.key,
            {
                handler: this.configDisabled,
                value: DISABLED_CONFIG.value,
                validator: DISABLED_CONFIG.validator,
                suppressEvent: DISABLED_CONFIG.suppressEvent
            }
        );


        /**
		 * @config selected
		 * @description Boolean indicating if the menu item should be
		 *              highlighted.
		 * @default false
		 * @type Boolean
		 */
        oConfig.addProperty(
            SELECTED_CONFIG.key,
            {
                handler: this.configSelected,
                value: SELECTED_CONFIG.value,
                validator: SELECTED_CONFIG.validator,
                suppressEvent: SELECTED_CONFIG.suppressEvent
            }
        );


        /**
		 * @config submenu
		 * @description Object specifying the submenu to be appended to the menu
		 *              item. The value can be one of the following:
		 *              <ul>
		 *              <li>Object specifying a Menu instance.</li>
		 *              <li>Object literal specifying the menu to be created.
		 *              Format: <code>{ id: [menu id], itemdata: 
        * [<a href="YAHOO.widget.Menu.html#itemData">array of values for 
        * items</a>] }</code>.</li>
		 *              <li>String specifying the id attribute of the
		 *              <code>&#60;div&#62;</code> element of the menu.</li>
		 *              <li> Object specifying the <code>&#60;div&#62;</code>
		 *              element of the menu.</li>
		 *              </ul>
		 * @default null
		 * @type Menu|String|Object|<a href="http://www.w3.org/TR/2000/
		 *       WD-DOM-Level-1-20000929/level-one-html.html#ID-58190037">
		 *       HTMLElement</a>
		 */
        oConfig.addProperty(
            SUBMENU_CONFIG.key, 
            {
                handler: this.configSubmenu, 
                supercedes: SUBMENU_CONFIG.supercedes,
                suppressEvent: SUBMENU_CONFIG.suppressEvent
            }
        );


        /**
		 * @config onclick
		 * @description Object literal representing the code to be executed when
		 *              the item is clicked. Format:<br>
		 *              <code> {<br> 
        * <strong>fn:</strong> Function,   &#47;&#47; The handler to call when 
        * the event fires.<br> <strong>obj:</strong> Object, &#47;&#47; An 
        * object to  pass back to the handler.<br> <strong>scope:</strong> 
        * Object &#47;&#47; The object to use for the scope of the handler.
        * <br> } </code>
		 * @type Object
		 * @default null
		 */
        oConfig.addProperty(
            ONCLICK_CONFIG.key, 
            {
                handler: this.configOnClick, 
                suppressEvent: ONCLICK_CONFIG.suppressEvent 
            }
        );


        /**
		 * @config classname
		 * @description CSS class to be applied to the menu item's root
		 *              <code>&#60;li&#62;</code> element. The specified
		 *              class(es) are appended in addition to the default class
		 *              as specified by the menu item's CSS_CLASS_NAME constant.
		 * @default null
		 * @type String
		 */
        oConfig.addProperty(
            CLASS_NAME_CONFIG.key, 
            { 
                handler: this.configClassName,
                value: CLASS_NAME_CONFIG.value, 
                validator: CLASS_NAME_CONFIG.validator,
                suppressEvent: CLASS_NAME_CONFIG.suppressEvent 
            }
        );


        /**
		 * @config keylistener
		 * @description Object literal representing the key(s) that can be used
		 *              to trigger the MenuItem's "click" event. Possible
		 *              attributes are shift (boolean), alt (boolean), ctrl
		 *              (boolean) and keys (either an int or an array of ints
		 *              representing keycodes).
		 * @default null
		 * @type Object
		 */
        oConfig.addProperty(
            KEY_LISTENER_CONFIG.key, 
            { 
                handler: this.configKeyListener,
                value: KEY_LISTENER_CONFIG.value, 
                suppressEvent: KEY_LISTENER_CONFIG.suppressEvent 
            }
        );

    },

    /**
	 * @method getNextSibling
	 * @description Finds the menu item's next sibling.
	 * @return YAHOO.widget.MenuItem
	 */
    getNextSibling: function () {
    
        var isUL = function (el) {
                return (el.nodeName.toLowerCase() === "ul");
            },
    
            menuitemEl = this.element,
            next = Dom.getNextSibling(menuitemEl),
            parent,
            sibling,
            list;
        
        if (!next) {
            
            parent = menuitemEl.parentNode;
            sibling = Dom.getNextSiblingBy(parent, isUL);
            
            if (sibling) {
                list = sibling;
            }
            else {
                list = Dom.getFirstChildBy(parent.parentNode, isUL);
            }
            
            next = Dom.getFirstChild(list);
            
        }

        return YAHOO.widget.MenuManager.getMenuItem(next.id);

    },

    /**
	 * @method getNextEnabledSibling
	 * @description Finds the menu item's next enabled sibling.
	 * @return YAHOO.widget.MenuItem
	 */
    getNextEnabledSibling: function () {
        
        var next = this.getNextSibling();
        
        return (next.cfg.getProperty(_DISABLED) || next.element.style.display == _NONE) ? next.getNextEnabledSibling() : next;
        
    },


    /**
	 * @method getPreviousSibling
	 * @description Finds the menu item's previous sibling.
	 * @return {YAHOO.widget.MenuItem}
	 */	
    getPreviousSibling: function () {

        var isUL = function (el) {
                return (el.nodeName.toLowerCase() === "ul");
            },

            menuitemEl = this.element,
            next = Dom.getPreviousSibling(menuitemEl),
            parent,
            sibling,
            list;
        
        if (!next) {
            
            parent = menuitemEl.parentNode;
            sibling = Dom.getPreviousSiblingBy(parent, isUL);
            
            if (sibling) {
                list = sibling;
            }
            else {
                list = Dom.getLastChildBy(parent.parentNode, isUL);
            }
            
            next = Dom.getLastChild(list);
            
        }

        return YAHOO.widget.MenuManager.getMenuItem(next.id);
        
    },


    /**
	 * @method getPreviousEnabledSibling
	 * @description Finds the menu item's previous enabled sibling.
	 * @return {YAHOO.widget.MenuItem}
	 */
    getPreviousEnabledSibling: function () {
        
        var next = this.getPreviousSibling();
        
        return (next.cfg.getProperty(_DISABLED) || next.element.style.display == _NONE) ? next.getPreviousEnabledSibling() : next;
        
    },


    /**
	 * @method focus
	 * @description Causes the menu item to receive the focus and fires the
	 *              focus event.
	 */
    focus: function () {

        var oParent = this.parent,
            oAnchor = this._oAnchor,
            oActiveItem = oParent.activeItem;


        function setFocus() {

            try {

                if (!(UA.ie && !document.hasFocus())) {
                
                    if (oActiveItem) {
        
                        oActiveItem.blurEvent.fire();
        
                    }
    
                    oAnchor.focus();
                    
                    this.focusEvent.fire();
                
                }

            }
            catch(e) {
            
            }

        }


        if (!this.cfg.getProperty(_DISABLED) && oParent && oParent.cfg.getProperty(_VISIBLE) && 
            this.element.style.display != _NONE) {


            /*
			 * Setting focus via a timer fixes a race condition in Firefox, IE
			 * and Opera where the browser viewport jumps as it trys to position
			 * and focus the menu.
			 */

            Lang.later(0, this, setFocus);

        }

    },


    /**
	 * @method blur
	 * @description Causes the menu item to lose focus and fires the blur event.
	 */    
    blur: function () {

        var oParent = this.parent;

        if (!this.cfg.getProperty(_DISABLED) && oParent && oParent.cfg.getProperty(_VISIBLE)) {

            Lang.later(0, this, function () {

                try {
    
                    this._oAnchor.blur();
                    this.blurEvent.fire();    

                } 
                catch (e) {
                
                }
                
            }, 0);

        }

    },


    /**
	 * @method hasFocus
	 * @description Returns a boolean indicating whether or not the menu item
	 *              has focus.
	 * @return {Boolean}
	 */
    hasFocus: function () {
    
        return (YAHOO.widget.MenuManager.getFocusedMenuItem() == this);
    
    },


    /**
	 * @method destroy
	 * @description Removes the menu item's <code>&#60;li&#62;</code> element
	 *              from its parent <code>&#60;ul&#62;</code> element.
	 */
    destroy: function () {

        var oEl = this.element,
            oSubmenu,
            oParentNode,
            aEventData,
            i;


        if (oEl) {


            // If the item has a submenu, destroy it first

            oSubmenu = this.cfg.getProperty(_SUBMENU);

            if (oSubmenu) {
            
                oSubmenu.destroy();
            
            }


            // Remove the element from the parent node

            oParentNode = oEl.parentNode;

            if (oParentNode) {

                oParentNode.removeChild(oEl);

                this.destroyEvent.fire();

            }


            // Remove CustomEvent listeners

            i = EVENT_TYPES.length - 1;

            do {

                aEventData = EVENT_TYPES[i];
                
                this[aEventData[0]].unsubscribeAll();

            }
            while (i--);
            
            
            this.cfg.configChangedEvent.unsubscribeAll();

        }

    },


    /**
	 * @method toString
	 * @description Returns a string representing the menu item.
	 * @return {String}
	 */
    toString: function () {

        var sReturnVal = _MENUITEM,
            sId = this.id;

        if (sId) {
    
            sReturnVal += (_SPACE + sId);
        
        }

        return sReturnVal;
    
    }

};

Lang.augmentProto(MenuItem, YAHOO.util.EventProvider);

})();
(function () {

    var _XY = "xy",
        _MOUSEDOWN = "mousedown",
        _CONTEXTMENU = "ContextMenu",
        _SPACE = " ";

/**
 * Creates a list of options or commands which are made visible in response to
 * an HTML element's "contextmenu" event ("mousedown" for Opera).
 * 
 * @param {String}
 *            p_oElement String specifying the id attribute of the
 *            <code>&#60;div&#62;</code> element of the context menu.
 * @param {String}
 *            p_oElement String specifying the id attribute of the
 *            <code>&#60;select&#62;</code> element to be used as the data
 *            source for the context menu.
 * @param {
 *            <a
 *            href="http://www.w3.org/TR/2000/WD-DOM-Level-1-20000929/level-one-
 *            html.html#ID-22445964">HTMLDivElement</a>} p_oElement Object
 *            specifying the <code>&#60;div&#62;</code> element of the context
 *            menu.
 * @param {
 *            <a
 *            href="http://www.w3.org/TR/2000/WD-DOM-Level-1-20000929/level-one-
 *            html.html#ID-94282980">HTMLSelectElement</a>} p_oElement Object
 *            specifying the <code>&#60;select&#62;</code> element to be used
 *            as the data source for the context menu.
 * @param {Object}
 *            p_oConfig Optional. Object literal specifying the configuration
 *            for the context menu. See configuration class documentation for
 *            more details.
 * @class ContextMenu
 * @constructor
 * @extends YAHOO.widget.Menu
 * @namespace YAHOO.widget
 */
YAHOO.widget.ContextMenu = function(p_oElement, p_oConfig) {
    YAHOO.widget.ContextMenu.superclass.constructor.call(this, p_oElement, p_oConfig);
};


var Event = YAHOO.util.Event,
    UA = YAHOO.env.ua,
    ContextMenu = YAHOO.widget.ContextMenu,



    /**
	 * Constant representing the name of the ContextMenu's events
	 * 
	 * @property EVENT_TYPES
	 * @private
	 * @final
	 * @type Object
	 */
    EVENT_TYPES = {

        "TRIGGER_CONTEXT_MENU": "triggerContextMenu",
        "CONTEXT_MENU": (UA.opera ? _MOUSEDOWN : "contextmenu"),
        "CLICK": "click"

    },
    
    
    /**
	 * Constant representing the ContextMenu's configuration properties
	 * 
	 * @property DEFAULT_CONFIG
	 * @private
	 * @final
	 * @type Object
	 */
    TRIGGER_CONFIG = { 
        key: "trigger",
        suppressEvent: true
    };


/**
 * @method position
 * @description "beforeShow" event handler used to position the contextmenu.
 * @private
 * @param {String}
 *            p_sType String representing the name of the event that was fired.
 * @param {Array}
 *            p_aArgs Array of arguments sent when the event was fired.
 * @param {Array}
 *            p_aPos Array representing the xy position for the context menu.
 */
function position(p_sType, p_aArgs, p_aPos) {
    this.cfg.setProperty(_XY, p_aPos);
    this.beforeShowEvent.unsubscribe(position, p_aPos);
}


YAHOO.lang.extend(ContextMenu, YAHOO.widget.Menu, {



// Private properties


/**
 * @property _oTrigger
 * @description Object reference to the current value of the "trigger"
 *              configuration property.
 * @default null
 * @private
 * @type String|<a href="http://www.w3.org/TR/2000/WD-DOM-Level-1-20000929/leve
 *       l-one-html.html#ID-58190037">HTMLElement</a>|Array
 */
_oTrigger: null,


/**
 * @property _bCancelled
 * @description Boolean indicating if the display of the context menu should be
 *              cancelled.
 * @default false
 * @private
 * @type Boolean
 */
_bCancelled: false,



// Public properties


/**
 * @property contextEventTarget
 * @description Object reference for the HTML element that was the target of the
 *              "contextmenu" DOM event ("mousedown" for Opera) that triggered
 *              the display of the context menu.
 * @default null
 * @type <a href="http://www.w3.org/TR/2000/WD-DOM-Level-1-20000929/level-one-
 *       html.html#ID-58190037">HTMLElement</a>
 */
contextEventTarget: null,



// Events


/**
 * @event triggerContextMenuEvent
 * @param type
 *            {String} The name of the event, "triggerContextMenu"
 * @param args
 *            {Array} The array of event arguments. For this event, the
 *            underlying DOM event is the only argument, available from args[0].
 * @description Custom Event wrapper for the "contextmenu" DOM event
 *              ("mousedown" for Opera) fired by the element(s) that trigger the
 *              display of the context menu.
 */
triggerContextMenuEvent: null,



/**
 * @method init
 * @description The ContextMenu class's initialization method. This method is
 *              automatically called by the constructor, and sets up all DOM
 *              references for pre-existing markup, and creates required markup
 *              if it is not already present.
 * @param {String}
 *            p_oElement String specifying the id attribute of the
 *            <code>&#60;div&#62;</code> element of the context menu.
 * @param {String}
 *            p_oElement String specifying the id attribute of the
 *            <code>&#60;select&#62;</code> element to be used as the data
 *            source for the context menu.
 * @param {
 *            <a
 *            href="http://www.w3.org/TR/2000/WD-DOM-Level-1-20000929/level-one-
 *            html.html#ID-22445964">HTMLDivElement</a>} p_oElement Object
 *            specifying the <code>&#60;div&#62;</code> element of the context
 *            menu.
 * @param {
 *            <a
 *            href="http://www.w3.org/TR/2000/WD-DOM-Level-1-20000929/level-one-
 *            html.html#ID-94282980">HTMLSelectElement</a>} p_oElement Object
 *            specifying the <code>&#60;select&#62;</code> element to be used
 *            as the data source for the context menu.
 * @param {Object}
 *            p_oConfig Optional. Object literal specifying the configuration
 *            for the context menu. See configuration class documentation for
 *            more details.
 */
init: function(p_oElement, p_oConfig) {


    // Call the init of the superclass (YAHOO.widget.Menu)
    
    ContextMenu.superclass.init.call(this, p_oElement);

    this.beforeInitEvent.fire(ContextMenu);

    if (p_oConfig) {
        this.cfg.applyConfig(p_oConfig, true);
    }

    this.initEvent.fire(ContextMenu);
},


/**
 * @method initEvents
 * @description Initializes the custom events for the context menu.
 */
initEvents: function() {
    ContextMenu.superclass.initEvents.call(this);

    // Create custom events
    this.triggerContextMenuEvent = this.createEvent(EVENT_TYPES.TRIGGER_CONTEXT_MENU);
    this.triggerContextMenuEvent.signature = YAHOO.util.CustomEvent.LIST;
},

/**
 * @method cancel
 * @description Cancels the display of the context menu.
 */
cancel: function() {
    this._bCancelled = true;
},

// Private methods


/**
 * @method _removeEventHandlers
 * @description Removes all of the DOM event handlers from the HTML element(s)
 *              whose "context menu" event ("click" for Opera) trigger the
 *              display of the context menu.
 * @private
 */
_removeEventHandlers: function() {

    var oTrigger = this._oTrigger;

    // Remove the event handlers from the trigger(s)
    if (oTrigger) {
        Event.removeListener(oTrigger, EVENT_TYPES.CONTEXT_MENU, this._onTriggerContextMenu);    

        if (UA.opera) {
            Event.removeListener(oTrigger, EVENT_TYPES.CLICK, this._onTriggerClick);
        }
    }

},

// Private event handlers

/**
 * @method _onTriggerClick
 * @description "click" event handler for the HTML element(s) identified as the
 *              "trigger" for the context menu. Used to cancel default behaviors
 *              in Opera.
 * @private
 * @param {Event}
 *            p_oEvent Object representing the DOM event object passed back by
 *            the event utility (YAHOO.util.Event).
 * @param {YAHOO.widget.ContextMenu}
 *            p_oMenu Object representing the context menu that is handling the
 *            event.
 */
_onTriggerClick: function(p_oEvent, p_oMenu) {

    if (p_oEvent.ctrlKey) {
        Event.stopEvent(p_oEvent);
    }
    
},


/**
 * @method _onTriggerContextMenu
 * @description "contextmenu" event handler ("mousedown" for Opera) for the HTML
 *              element(s) that trigger the display of the context menu.
 * @private
 * @param {Event}
 *            p_oEvent Object representing the DOM event object passed back by
 *            the event utility (YAHOO.util.Event).
 * @param {YAHOO.widget.ContextMenu}
 *            p_oMenu Object representing the context menu that is handling the
 *            event.
 */
_onTriggerContextMenu: function(p_oEvent, p_oMenu) {

    var aXY;

    if (!(p_oEvent.type == _MOUSEDOWN && !p_oEvent.ctrlKey)) {
    
        this.contextEventTarget = Event.getTarget(p_oEvent);
    
        this.triggerContextMenuEvent.fire(p_oEvent);
        
    
        if (!this._bCancelled) {

            /*
			 * Prevent the browser's default context menu from appearing and
			 * stop the propagation of the "contextmenu" event so that other
			 * ContextMenu instances are not displayed.
			 */

            Event.stopEvent(p_oEvent);


            // Hide any other Menu instances that might be visible

            YAHOO.widget.MenuManager.hideVisible();
            
    

            // Position and display the context menu
    
            aXY = Event.getXY(p_oEvent);
    
    
            if (!YAHOO.util.Dom.inDocument(this.element)) {
    
                this.beforeShowEvent.subscribe(position, aXY);
    
            }
            else {
    
                this.cfg.setProperty(_XY, aXY);
            
            }
    
    
            this.show();
    
        }
    
        this._bCancelled = false;

    }

},



// Public methods


/**
 * @method toString
 * @description Returns a string representing the context menu.
 * @return {String}
 */
toString: function() {

    var sReturnVal = _CONTEXTMENU,
        sId = this.id;

    if (sId) {

        sReturnVal += (_SPACE + sId);
    
    }

    return sReturnVal;

},


/**
 * @method initDefaultConfig
 * @description Initializes the class's configurable properties which can be
 *              changed using the context menu's Config object ("cfg").
 */
initDefaultConfig: function() {

    ContextMenu.superclass.initDefaultConfig.call(this);

    /**
	 * @config trigger
	 * @description The HTML element(s) whose "contextmenu" event ("mousedown"
	 *              for Opera) trigger the display of the context menu. Can be a
	 *              string representing the id attribute of the HTML element, an
	 *              object reference for the HTML element, or an array of
	 *              strings or HTML element references.
	 * @default null
	 * @type String|<a href="http://www.w3.org/TR/2000/WD-DOM-Level-1-20000929/
	 *       level-one-html.html#ID-58190037">HTMLElement</a>|Array
	 */
    this.cfg.addProperty(TRIGGER_CONFIG.key, 
        {
            handler: this.configTrigger, 
            suppressEvent: TRIGGER_CONFIG.suppressEvent 
        }
    );

},


/**
 * @method destroy
 * @description Removes the context menu's <code>&#60;div&#62;</code> element
 *              (and accompanying child nodes) from the document.
 * @param {boolean}
 *            shallowPurge If true, only the parent element's DOM event
 *            listeners are purged. If false, or not provided, all children are
 *            also purged of DOM event listeners. NOTE: The flag is a
 *            "shallowPurge" flag, as opposed to what may be a more intuitive
 *            "purgeChildren" flag to maintain backwards compatibility with
 *            behavior prior to 2.9.0.
 */
destroy: function(shallowPurge) {

    // Remove the DOM event handlers from the current trigger(s)

    this._removeEventHandlers();


    // Continue with the superclass implementation of this method

    ContextMenu.superclass.destroy.call(this, shallowPurge);

},



// Public event handlers for configuration properties


/**
 * @method configTrigger
 * @description Event handler for when the value of the "trigger" configuration
 *              property changes.
 * @param {String}
 *            p_sType String representing the name of the event that was fired.
 * @param {Array}
 *            p_aArgs Array of arguments sent when the event was fired.
 * @param {YAHOO.widget.ContextMenu}
 *            p_oMenu Object representing the context menu that fired the event.
 */
configTrigger: function(p_sType, p_aArgs, p_oMenu) {
    
    var oTrigger = p_aArgs[0];

    if (oTrigger) {

        /*
		 * If there is a current "trigger" - remove the event handlers from that
		 * element(s) before assigning new ones
		 */

        if (this._oTrigger) {
        
            this._removeEventHandlers();

        }

        this._oTrigger = oTrigger;


        /*
		 * Listen for the "mousedown" event in Opera b/c it does not support the
		 * "contextmenu" event
		 */ 
  
        Event.on(oTrigger, EVENT_TYPES.CONTEXT_MENU, this._onTriggerContextMenu, this, true);


        /*
		 * Assign a "click" event handler to the trigger element(s) for Opera to
		 * prevent default browser behaviors.
		 */

        if (UA.opera) {
        
            Event.on(oTrigger, EVENT_TYPES.CLICK, this._onTriggerClick, this, true);

        }

    }
    else {
   
        this._removeEventHandlers();
    
    }
    
}

}); // END YAHOO.lang.extend

}());



/**
 * Creates an item for a context menu.
 * 
 * @param {String}
 *            p_oObject String specifying the text of the context menu item.
 * @param {
 *            <a href="http://www.w3.org/TR/2000/WD-DOM-Level-1-20000929/level-
 *            one-html.html#ID-74680021">HTMLLIElement</a>} p_oObject Object
 *            specifying the <code>&#60;li&#62;</code> element of the context
 *            menu item.
 * @param {
 *            <a href="http://www.w3.org/TR/2000/WD-DOM-Level-1-20000929/level-
 *            one-html.html#ID-38450247">HTMLOptGroupElement</a>} p_oObject
 *            Object specifying the <code>&#60;optgroup&#62;</code> element of
 *            the context menu item.
 * @param {
 *            <a href="http://www.w3.org/TR/2000/WD-DOM-Level-1-20000929/level-
 *            one-html.html#ID-70901257">HTMLOptionElement</a>} p_oObject
 *            Object specifying the <code>&#60;option&#62;</code> element of
 *            the context menu item.
 * @param {Object}
 *            p_oConfig Optional. Object literal specifying the configuration
 *            for the context menu item. See configuration class documentation
 *            for more details.
 * @class ContextMenuItem
 * @constructor
 * @extends YAHOO.widget.MenuItem
 * @deprecated As of version 2.4.0 items for YAHOO.widget.ContextMenu instances
 *             are of type YAHOO.widget.MenuItem.
 */
YAHOO.widget.ContextMenuItem = YAHOO.widget.MenuItem;
(function () {

    var Lang = YAHOO.lang,

        // String constants
    
        _STATIC = "static",
        _DYNAMIC_STATIC = "dynamic," + _STATIC,
        _DISABLED = "disabled",
        _SELECTED = "selected",
        _AUTO_SUBMENU_DISPLAY = "autosubmenudisplay",
        _SUBMENU = "submenu",
        _VISIBLE = "visible",
        _SPACE = " ",
        _SUBMENU_TOGGLE_REGION = "submenutoggleregion",
        _MENUBAR = "MenuBar";

/**
 * Horizontal collection of items, each of which can contain a submenu.
 * 
 * @param {String}
 *            p_oElement String specifying the id attribute of the
 *            <code>&#60;div&#62;</code> element of the menu bar.
 * @param {String}
 *            p_oElement String specifying the id attribute of the
 *            <code>&#60;select&#62;</code> element to be used as the data
 *            source for the menu bar.
 * @param {
 *            <a href="http://www.w3.org/TR/2000/WD-DOM-Level-1-20000929/level-
 *            one-html.html#ID-22445964">HTMLDivElement</a>} p_oElement Object
 *            specifying the <code>&#60;div&#62;</code> element of the menu
 *            bar.
 * @param {
 *            <a href="http://www.w3.org/TR/2000/WD-DOM-Level-1-20000929/level-
 *            one-html.html#ID-94282980">HTMLSelectElement</a>} p_oElement
 *            Object specifying the <code>&#60;select&#62;</code> element to
 *            be used as the data source for the menu bar.
 * @param {Object}
 *            p_oConfig Optional. Object literal specifying the configuration
 *            for the menu bar. See configuration class documentation for more
 *            details.
 * @class MenuBar
 * @constructor
 * @extends YAHOO.widget.Menu
 * @namespace YAHOO.widget
 */
YAHOO.widget.MenuBar = function(p_oElement, p_oConfig) {

    YAHOO.widget.MenuBar.superclass.constructor.call(this, p_oElement, p_oConfig);

};


/**
 * @method checkPosition
 * @description Checks to make sure that the value of the "position" property is
 *              one of the supported strings. Returns true if the position is
 *              supported.
 * @private
 * @param {Object}
 *            p_sPosition String specifying the position of the menu.
 * @return {Boolean}
 */
function checkPosition(p_sPosition) {

    var returnVal = false;

    if (Lang.isString(p_sPosition)) {

        returnVal = (_DYNAMIC_STATIC.indexOf((p_sPosition.toLowerCase())) != -1);

    }
    
    return returnVal;

}


var Event = YAHOO.util.Event,
    MenuBar = YAHOO.widget.MenuBar,

    POSITION_CONFIG =  { 
        key: "position", 
        value: _STATIC, 
        validator: checkPosition, 
        supercedes: [_VISIBLE] 
    }, 

    SUBMENU_ALIGNMENT_CONFIG =  { 
        key: "submenualignment", 
        value: ["tl","bl"]
    },

    AUTO_SUBMENU_DISPLAY_CONFIG =  { 
        key: _AUTO_SUBMENU_DISPLAY, 
        value: false, 
        validator: Lang.isBoolean,
        suppressEvent: true
    },
    
    SUBMENU_TOGGLE_REGION_CONFIG = {
        key: _SUBMENU_TOGGLE_REGION, 
        value: false, 
        validator: Lang.isBoolean
    };



Lang.extend(MenuBar, YAHOO.widget.Menu, {

/**
 * @method init
 * @description The MenuBar class's initialization method. This method is
 *              automatically called by the constructor, and sets up all DOM
 *              references for pre-existing markup, and creates required markup
 *              if it is not already present.
 * @param {String}
 *            p_oElement String specifying the id attribute of the
 *            <code>&#60;div&#62;</code> element of the menu bar.
 * @param {String}
 *            p_oElement String specifying the id attribute of the
 *            <code>&#60;select&#62;</code> element to be used as the data
 *            source for the menu bar.
 * @param {
 *            <a href="http://www.w3.org/TR/2000/WD-DOM-Level-1-20000929/level-
 *            one-html.html#ID-22445964">HTMLDivElement</a>} p_oElement Object
 *            specifying the <code>&#60;div&#62;</code> element of the menu
 *            bar.
 * @param {
 *            <a href="http://www.w3.org/TR/2000/WD-DOM-Level-1-20000929/level-
 *            one-html.html#ID-94282980">HTMLSelectElement</a>} p_oElement
 *            Object specifying the <code>&#60;select&#62;</code> element to
 *            be used as the data source for the menu bar.
 * @param {Object}
 *            p_oConfig Optional. Object literal specifying the configuration
 *            for the menu bar. See configuration class documentation for more
 *            details.
 */
init: function(p_oElement, p_oConfig) {

    if(!this.ITEM_TYPE) {

        this.ITEM_TYPE = YAHOO.widget.MenuBarItem;

    }


    // Call the init of the superclass (YAHOO.widget.Menu)

    MenuBar.superclass.init.call(this, p_oElement);


    this.beforeInitEvent.fire(MenuBar);


    if(p_oConfig) {

        this.cfg.applyConfig(p_oConfig, true);

    }

    this.initEvent.fire(MenuBar);

},



// Constants


/**
 * @property CSS_CLASS_NAME
 * @description String representing the CSS class(es) to be applied to the menu
 *              bar's <code>&#60;div&#62;</code> element.
 * @default "yuimenubar"
 * @final
 * @type String
 */
CSS_CLASS_NAME: "yuimenubar",


/**
 * @property SUBMENU_TOGGLE_REGION_WIDTH
 * @description Width (in pixels) of the area of a MenuBarItem that, when
 *              pressed, will toggle the display of the MenuBarItem's submenu.
 * @default 20
 * @final
 * @type Number
 */
SUBMENU_TOGGLE_REGION_WIDTH: 20,


// Protected event handlers


/**
 * @method _onKeyDown
 * @description "keydown" Custom Event handler for the menu bar.
 * @private
 * @param {String}
 *            p_sType String representing the name of the event that was fired.
 * @param {Array}
 *            p_aArgs Array of arguments sent when the event was fired.
 * @param {YAHOO.widget.MenuBar}
 *            p_oMenuBar Object representing the menu bar that fired the event.
 */
_onKeyDown: function(p_sType, p_aArgs, p_oMenuBar) {

    var oEvent = p_aArgs[0],
        oItem = p_aArgs[1],
        oSubmenu,
        oItemCfg,
        oNextItem;


    if(oItem && !oItem.cfg.getProperty(_DISABLED)) {

        oItemCfg = oItem.cfg;

        switch(oEvent.keyCode) {
    
            case 37:    // Left arrow
            case 39:    // Right arrow
    
                if(oItem == this.activeItem && !oItemCfg.getProperty(_SELECTED)) {
    
                    oItemCfg.setProperty(_SELECTED, true);
    
                }
                else {
    
                    oNextItem = (oEvent.keyCode == 37) ? 
                        oItem.getPreviousEnabledSibling() : 
                        oItem.getNextEnabledSibling();
            
                    if(oNextItem) {
    
                        this.clearActiveItem();
    
                        oNextItem.cfg.setProperty(_SELECTED, true);
                        
                        oSubmenu = oNextItem.cfg.getProperty(_SUBMENU);
                        
                        if(oSubmenu) {
                    
                            oSubmenu.show();
                            oSubmenu.setInitialFocus();
                        
                        }
                        else {
                            oNextItem.focus();  
                        }
    
                    }
    
                }
    
                Event.preventDefault(oEvent);
    
            break;
    
            case 40:    // Down arrow
    
                if(this.activeItem != oItem) {
    
                    this.clearActiveItem();
    
                    oItemCfg.setProperty(_SELECTED, true);
                    oItem.focus();
                
                }
    
                oSubmenu = oItemCfg.getProperty(_SUBMENU);
    
                if(oSubmenu) {
    
                    if(oSubmenu.cfg.getProperty(_VISIBLE)) {
    
                        oSubmenu.setInitialSelection();
                        oSubmenu.setInitialFocus();
                    
                    }
                    else {
    
                        oSubmenu.show();
                        oSubmenu.setInitialFocus();
                    
                    }
    
                }
    
                Event.preventDefault(oEvent);
    
            break;
    
        }

    }


    if(oEvent.keyCode == 27 && this.activeItem) { // Esc key

        oSubmenu = this.activeItem.cfg.getProperty(_SUBMENU);

        if(oSubmenu && oSubmenu.cfg.getProperty(_VISIBLE)) {
        
            oSubmenu.hide();
            this.activeItem.focus();
        
        }
        else {

            this.activeItem.cfg.setProperty(_SELECTED, false);
            this.activeItem.blur();
    
        }

        Event.preventDefault(oEvent);
    
    }

},


/**
 * @method _onClick
 * @description "click" event handler for the menu bar.
 * @protected
 * @param {String}
 *            p_sType String representing the name of the event that was fired.
 * @param {Array}
 *            p_aArgs Array of arguments sent when the event was fired.
 * @param {YAHOO.widget.MenuBar}
 *            p_oMenuBar Object representing the menu bar that fired the event.
 */
_onClick: function(p_sType, p_aArgs, p_oMenuBar) {

    MenuBar.superclass._onClick.call(this, p_sType, p_aArgs, p_oMenuBar);

    var oItem = p_aArgs[1],
        bReturnVal = true,
        oItemEl,
        oEvent,
        oTarget,
        oActiveItem,
        oConfig,
        oSubmenu,
        nMenuItemX,
        nToggleRegion;


    var toggleSubmenuDisplay = function () {

        if(oSubmenu.cfg.getProperty(_VISIBLE)) {
        
            oSubmenu.hide();
        
        }
        else {
        
            oSubmenu.show();                    
        
        }
    
    };
    

    if(oItem && !oItem.cfg.getProperty(_DISABLED)) {

        oEvent = p_aArgs[0];
        oTarget = Event.getTarget(oEvent);
        oActiveItem = this.activeItem;
        oConfig = this.cfg;


        // Hide any other submenus that might be visible
    
        if(oActiveItem && oActiveItem != oItem) {
    
            this.clearActiveItem();
    
        }

    
        oItem.cfg.setProperty(_SELECTED, true);
    

        // Show the submenu for the item
    
        oSubmenu = oItem.cfg.getProperty(_SUBMENU);


        if(oSubmenu) {

            oItemEl = oItem.element;
            nMenuItemX = YAHOO.util.Dom.getX(oItemEl);
            nToggleRegion = nMenuItemX + (oItemEl.offsetWidth - this.SUBMENU_TOGGLE_REGION_WIDTH);

            if (oConfig.getProperty(_SUBMENU_TOGGLE_REGION)) {

                if (Event.getPageX(oEvent) > nToggleRegion) {

                    toggleSubmenuDisplay();

                    Event.preventDefault(oEvent);

                    /*
					 * Return false so that other click event handlers are not
					 * called when the user clicks inside the toggle region.
					 */
                    bReturnVal = false;
                
                }
        
            }
            else {

                toggleSubmenuDisplay();
            
            }
        
        }
    
    }


    return bReturnVal;

},



// Public methods

/**
 * @method configSubmenuToggle
 * @description Event handler for when the "submenutoggleregion" configuration
 *              property of a MenuBar changes.
 * @param {String}
 *            p_sType The name of the event that was fired.
 * @param {Array}
 *            p_aArgs Collection of arguments sent when the event was fired.
 */
configSubmenuToggle: function (p_sType, p_aArgs) {

    var bSubmenuToggle = p_aArgs[0];
    
    if (bSubmenuToggle) {
    
        this.cfg.setProperty(_AUTO_SUBMENU_DISPLAY, false);
    
    }

},


/**
 * @method toString
 * @description Returns a string representing the menu bar.
 * @return {String}
 */
toString: function() {

    var sReturnVal = _MENUBAR,
        sId = this.id;

    if(sId) {

        sReturnVal += (_SPACE + sId);
    
    }

    return sReturnVal;

},


/**
 * @description Initializes the class's configurable properties which can be
 *              changed using the menu bar's Config object ("cfg").
 * @method initDefaultConfig
 */
initDefaultConfig: function() {

    MenuBar.superclass.initDefaultConfig.call(this);

    var oConfig = this.cfg;

    // Add configuration properties


    /*
	 * Set the default value for the "position" configuration property to
	 * "static" by re-adding the property.
	 */


    /**
	 * @config position
	 * @description String indicating how a menu bar should be positioned on the
	 *              screen. Possible values are "static" and "dynamic." Static
	 *              menu bars are visible by default and reside in the normal
	 *              flow of the document (CSS position: static). Dynamic menu
	 *              bars are hidden by default, reside out of the normal flow of
	 *              the document (CSS position: absolute), and can overlay other
	 *              elements on the screen.
	 * @default static
	 * @type String
	 */
    oConfig.addProperty(
        POSITION_CONFIG.key, 
        {
            handler: this.configPosition, 
            value: POSITION_CONFIG.value, 
            validator: POSITION_CONFIG.validator,
            supercedes: POSITION_CONFIG.supercedes
        }
    );


    /*
	 * Set the default value for the "submenualignment" configuration property
	 * to ["tl","bl"] by re-adding the property.
	 */

    /**
	 * @config submenualignment
	 * @description Array defining how submenus should be aligned to their
	 *              parent menu bar item. The format is: [itemCorner,
	 *              submenuCorner].
	 * @default ["tl","bl"]
	 * @type Array
	 */
    oConfig.addProperty(
        SUBMENU_ALIGNMENT_CONFIG.key, 
        {
            value: SUBMENU_ALIGNMENT_CONFIG.value,
            suppressEvent: SUBMENU_ALIGNMENT_CONFIG.suppressEvent
        }
    );


    /*
	 * Change the default value for the "autosubmenudisplay" configuration
	 * property to "false" by re-adding the property.
	 */

    /**
	 * @config autosubmenudisplay
	 * @description Boolean indicating if submenus are automatically made
	 *              visible when the user mouses over the menu bar's items.
	 * @default false
	 * @type Boolean
	 */
    oConfig.addProperty(
       AUTO_SUBMENU_DISPLAY_CONFIG.key, 
       {
           value: AUTO_SUBMENU_DISPLAY_CONFIG.value, 
           validator: AUTO_SUBMENU_DISPLAY_CONFIG.validator,
           suppressEvent: AUTO_SUBMENU_DISPLAY_CONFIG.suppressEvent
       } 
    );


    /**
	 * @config submenutoggleregion
	 * @description Boolean indicating if only a specific region of a
	 *              MenuBarItem should toggle the display of a submenu. The
	 *              default width of the region is determined by the value of
	 *              the SUBMENU_TOGGLE_REGION_WIDTH property. If set to true,
	 *              the autosubmenudisplay configuration property will be set to
	 *              false, and any click event listeners will not be called when
	 *              the user clicks inside the submenu toggle region of a
	 *              MenuBarItem. If the user clicks outside of the submenu
	 *              toggle region, the MenuBarItem will maintain its standard
	 *              behavior.
	 * @default false
	 * @type Boolean
	 */
    oConfig.addProperty(
       SUBMENU_TOGGLE_REGION_CONFIG.key, 
       {
           value: SUBMENU_TOGGLE_REGION_CONFIG.value, 
           validator: SUBMENU_TOGGLE_REGION_CONFIG.validator,
           handler: this.configSubmenuToggle
       } 
    );

}
 
}); // END YAHOO.lang.extend

}());



/**
 * Creates an item for a menu bar.
 * 
 * @param {HTML}
 *            p_oObject Markup for the menu item content. The markup is inserted
 *            into the DOM as HTML, and should be escaped by the implementor if
 *            coming from an external source.
 * @param {
 *            <a href="http://www.w3.org/TR/2000/WD-DOM-Level-1-20000929/level-
 *            one-html.html#ID-74680021">HTMLLIElement</a>} p_oObject Object
 *            specifying the <code>&#60;li&#62;</code> element of the menu bar
 *            item.
 * @param {
 *            <a href="http://www.w3.org/TR/2000/WD-DOM-Level-1-20000929/level-
 *            one-html.html#ID-38450247">HTMLOptGroupElement</a>} p_oObject
 *            Object specifying the <code>&#60;optgroup&#62;</code> element of
 *            the menu bar item.
 * @param {
 *            <a href="http://www.w3.org/TR/2000/WD-DOM-Level-1-20000929/level-
 *            one-html.html#ID-70901257">HTMLOptionElement</a>} p_oObject
 *            Object specifying the <code>&#60;option&#62;</code> element of
 *            the menu bar item.
 * @param {Object}
 *            p_oConfig Optional. Object literal specifying the configuration
 *            for the menu bar item. See configuration class documentation for
 *            more details.
 * @class MenuBarItem
 * @constructor
 * @extends YAHOO.widget.MenuItem
 */
YAHOO.widget.MenuBarItem = function(p_oObject, p_oConfig) {

    YAHOO.widget.MenuBarItem.superclass.constructor.call(this, p_oObject, p_oConfig);

};

YAHOO.lang.extend(YAHOO.widget.MenuBarItem, YAHOO.widget.MenuItem, {



/**
 * @method init
 * @description The MenuBarItem class's initialization method. This method is
 *              automatically called by the constructor, and sets up all DOM
 *              references for pre-existing markup, and creates required markup
 *              if it is not already present.
 * @param {HTML}
 *            p_oObject Markup for the menu item content. The markup is inserted
 *            into the DOM as HTML, and should be escaped by the implementor if
 *            coming from an external source.
 * @param {
 *            <a href="http://www.w3.org/TR/2000/WD-DOM-Level-1-20000929/level-
 *            one-html.html#ID-74680021">HTMLLIElement</a>} p_oObject Object
 *            specifying the <code>&#60;li&#62;</code> element of the menu bar
 *            item.
 * @param {
 *            <a href="http://www.w3.org/TR/2000/WD-DOM-Level-1-20000929/level-
 *            one-html.html#ID-38450247">HTMLOptGroupElement</a>} p_oObject
 *            Object specifying the <code>&#60;optgroup&#62;</code> element of
 *            the menu bar item.
 * @param {
 *            <a href="http://www.w3.org/TR/2000/WD-DOM-Level-1-20000929/level-
 *            one-html.html#ID-70901257">HTMLOptionElement</a>} p_oObject
 *            Object specifying the <code>&#60;option&#62;</code> element of
 *            the menu bar item.
 * @param {Object}
 *            p_oConfig Optional. Object literal specifying the configuration
 *            for the menu bar item. See configuration class documentation for
 *            more details.
 */
init: function(p_oObject, p_oConfig) {

    if(!this.SUBMENU_TYPE) {

        this.SUBMENU_TYPE = YAHOO.widget.Menu;

    }


    /*
	 * Call the init of the superclass (YAHOO.widget.MenuItem) Note: We don't
	 * pass the user config in here yet because we only want it executed once,
	 * at the lowest subclass level.
	 */ 

    YAHOO.widget.MenuBarItem.superclass.init.call(this, p_oObject);  


    var oConfig = this.cfg;

    if(p_oConfig) {

        oConfig.applyConfig(p_oConfig, true);

    }

    oConfig.fireQueue();

},



// Constants


/**
 * @property CSS_CLASS_NAME
 * @description String representing the CSS class(es) to be applied to the
 *              <code>&#60;li&#62;</code> element of the menu bar item.
 * @default "yuimenubaritem"
 * @final
 * @type String
 */
CSS_CLASS_NAME: "yuimenubaritem",


/**
 * @property CSS_LABEL_CLASS_NAME
 * @description String representing the CSS class(es) to be applied to the menu
 *              bar item's <code>&#60;a&#62;</code> element.
 * @default "yuimenubaritemlabel"
 * @final
 * @type String
 */
CSS_LABEL_CLASS_NAME: "yuimenubaritemlabel",



// Public methods


/**
 * @method toString
 * @description Returns a string representing the menu bar item.
 * @return {String}
 */
toString: function() {

    var sReturnVal = "MenuBarItem";

    if(this.cfg && this.cfg.getProperty("text")) {

        sReturnVal += (": " + this.cfg.getProperty("text"));

    }

    return sReturnVal;

}
    
}); // END YAHOO.lang.extend
YAHOO.register("menu", YAHOO.widget.Menu, {version: "2.9.0", build: "2800"});
/*
 * Copyright (c) 2011, Yahoo! Inc. All rights reserved. Code licensed under the
 * BSD License: http://developer.yahoo.com/yui/license.html version: 2.9.0
 */
/**
 * @module button
 * @description
 *         <p>
 *         The Button Control enables the creation of rich, graphical buttons
 *         that function like traditional HTML form buttons. <em>Unlike</em>
 *         traditional HTML form buttons, buttons created with the Button
 *         Control can have a label that is different from its value. With the
 *         inclusion of the optional <a href="module_menu.html">Menu Control</a>,
 *         the Button Control can also be used to create menu buttons and split
 *         buttons, controls that are not available natively in HTML. The Button
 *         Control can also be thought of as a way to create more visually
 *         engaging implementations of the browser's default radio-button and
 *         check-box controls.
 *         </p>
 *         <p>
 *         The Button Control supports the following types:
 *         </p>
 *         <dl>
 *         <dt>push</dt>
 *         <dd>Basic push button that can execute a user-specified command when
 *         pressed.</dd>
 *         <dt>link</dt>
 *         <dd>Navigates to a specified url when pressed.</dd>
 *         <dt>submit</dt>
 *         <dd>Submits the parent form when pressed.</dd>
 *         <dt>reset</dt>
 *         <dd>Resets the parent form when pressed.</dd>
 *         <dt>checkbox</dt>
 *         <dd>Maintains a "checked" state that can be toggled on and off.</dd>
 *         <dt>radio</dt>
 *         <dd>Maintains a "checked" state that can be toggled on and off. Use
 *         with the ButtonGroup class to create a set of controls that are
 *         mutually exclusive; checking one button in the set will uncheck all
 *         others in the group.</dd>
 *         <dt>menu</dt>
 *         <dd>When pressed will show/hide a menu.</dd>
 *         <dt>split</dt>
 *         <dd>Can execute a user-specified command or display a menu when
 *         pressed.</dd>
 *         </dl>
 * @title Button
 * @namespace YAHOO.widget
 * @requires yahoo, dom, element, event
 * @optional container, menu
 */


(function () {


    /**
	 * The Button class creates a rich, graphical button.
	 * 
	 * @param {String}
	 *            p_oElement String specifying the id attribute of the
	 *            <code>&#60;input&#62;</code>, <code>&#60;button&#62;</code>,
	 *            <code>&#60;a&#62;</code>, or <code>&#60;span&#62;</code>
	 *            element to be used to create the button.
	 * @param {
	 *            <a
	 *            href="http://www.w3.org/TR/2000/WD-DOM-Level-1-20000929/level-
	 *            one-html.html#ID-6043025">HTMLInputElement</a>|<a
	 *            href="http://www.w3.org
	 *            /TR/2000/WD-DOM-Level-1-20000929/level-one-html.html#ID-34812697">
	 *            HTMLButtonElement</a>|<a href="
	 *            http://www.w3.org/TR/2000/WD-DOM-Level-1-20000929/level-one-html.html#
	 *            ID-33759296">HTMLElement</a>} p_oElement Object reference for
	 *            the <code>&#60;input&#62;</code>,
	 *            <code>&#60;button&#62;</code>, <code>&#60;a&#62;</code>,
	 *            or <code>&#60;span&#62;</code> element to be used to create
	 *            the button.
	 * @param {Object}
	 *            p_oElement Object literal specifying a set of configuration
	 *            attributes used to create the button.
	 * @param {Object}
	 *            p_oAttributes Optional. Object literal specifying a set of
	 *            configuration attributes used to create the button.
	 * @namespace YAHOO.widget
	 * @class Button
	 * @constructor
	 * @extends YAHOO.util.Element
	 */



    // Shorthard for utilities

    var Dom = YAHOO.util.Dom,
        Event = YAHOO.util.Event,
        Lang = YAHOO.lang,
        UA = YAHOO.env.ua,
        Overlay = YAHOO.widget.Overlay,
        Menu = YAHOO.widget.Menu,
    
    
        // Private member variables
    
        m_oButtons = {},    // Collection of all Button instances
        m_oOverlayManager = null,   // YAHOO.widget.OverlayManager instance
        m_oSubmitTrigger = null,    // The button that submitted the form
        m_oFocusedButton = null;    // The button that has focus



    // Private methods

    
    
    /**
	 * @method createInputElement
	 * @description Creates an <code>&#60;input&#62;</code> element of the
	 *              specified type.
	 * @private
	 * @param {String}
	 *            p_sType String specifying the type of
	 *            <code>&#60;input&#62;</code> element to create.
	 * @param {String}
	 *            p_sName String specifying the name of
	 *            <code>&#60;input&#62;</code> element to create.
	 * @param {String}
	 *            p_sValue String specifying the value of
	 *            <code>&#60;input&#62;</code> element to create.
	 * @param {String}
	 *            p_bChecked Boolean specifying if the
	 *            <code>&#60;input&#62;</code> element is to be checked.
	 * @return {<a
	 *         href="http://www.w3.org/TR/2000/WD-DOM-Level-1-20000929/level-
	 *         one-html.html#ID-6043025">HTMLInputElement</a>}
	 */
    function createInputElement(p_sType, p_sName, p_sValue, p_bChecked) {
    
        var oInput,
            sInput;
    
        if (Lang.isString(p_sType) && Lang.isString(p_sName)) {
        
            if (UA.ie && (UA.ie < 9)) {
        
                /*
				 * For IE it is necessary to create the element with the "type,"
				 * "name," "value," and "checked" properties set all at once.
				 */
            
                sInput = "<input type=\"" + p_sType + "\" name=\"" + 
                    p_sName + "\"";
        
                if (p_bChecked) {
        
                    sInput += " checked";
                
                }
                
                sInput += ">";
        
                oInput = document.createElement(sInput);
        
                oInput.value = p_sValue;

            } else {
            
                oInput = document.createElement("input");
                oInput.name = p_sName;
                oInput.type = p_sType;
                oInput.value = p_sValue;
        
                if (p_bChecked) {
        
                    oInput.checked = true;
                
                }
        
            }
        
        
        }

		return oInput;
    
    }
    
    
    /**
	 * @method setAttributesFromSrcElement
	 * @description Gets the values for all the attributes of the source element
	 *              (either <code>&#60;input&#62;</code> or
	 *              <code>&#60;a&#62;</code>) that map to Button
	 *              configuration attributes and sets them into a collection
	 *              that is passed to the Button constructor.
	 * @private
	 * @param {
	 *            <a
	 *            href="http://www.w3.org/TR/2000/WD-DOM-Level-1-20000929/level-
	 *            one-html.html#ID-6043025">HTMLInputElement</a>|<a
	 *            href="http://www.w3.org/
	 *            TR/2000/WD-DOM-Level-1-20000929/level-one-html.html#ID-
	 *            48250443">HTMLAnchorElement</a>} p_oElement Object reference
	 *            to the HTML element (either <code>&#60;input&#62;</code> or
	 *            <code>&#60;span&#62;
    * </code>) used to create the button.
	 * @param {Object}
	 *            p_oAttributes Object reference for the collection of
	 *            configuration attributes used to create the button.
	 */
    function setAttributesFromSrcElement(p_oElement, p_oAttributes) {
    
        var sSrcElementNodeName = p_oElement.nodeName.toUpperCase(),
			sClass = (this.CLASS_NAME_PREFIX + this.CSS_CLASS_NAME),
            me = this,
            oAttribute,
            oRootNode,
            sText;
            
    
        /**
		 * @method setAttributeFromDOMAttribute
		 * @description Gets the value of the specified DOM attribute and sets
		 *              it into the collection of configuration attributes used
		 *              to configure the button.
		 * @private
		 * @param {String}
		 *            p_sAttribute String representing the name of the attribute
		 *            to retrieve from the DOM element.
		 */
        function setAttributeFromDOMAttribute(p_sAttribute) {
    
            if (!(p_sAttribute in p_oAttributes)) {
    
                /*
				 * Need to use "getAttributeNode" instead of "getAttribute"
				 * because using "getAttribute," IE will return the innerText of
				 * a <code>&#60;button&#62;</code> for the value attribute
				 * rather than the value of the "value" attribute.
				 */
        
                oAttribute = p_oElement.getAttributeNode(p_sAttribute);
        
    
                if (oAttribute && ("value" in oAttribute)) {
    
    
                    p_oAttributes[p_sAttribute] = oAttribute.value;
    
                }
    
            }
        
        }
    
    
        /**
		 * @method setFormElementProperties
		 * @description Gets the value of the attributes from the form element
		 *              and sets them into the collection of configuration
		 *              attributes used to configure the button.
		 * @private
		 */
        function setFormElementProperties() {
    
            setAttributeFromDOMAttribute("type");
    
            if (p_oAttributes.type == "button") {
            
                p_oAttributes.type = "push";
            
            }
    
            if (!("disabled" in p_oAttributes)) {
    
                p_oAttributes.disabled = p_oElement.disabled;
    
            }
    
            setAttributeFromDOMAttribute("name");
            setAttributeFromDOMAttribute("value");
            setAttributeFromDOMAttribute("title");
    
        }

    
        switch (sSrcElementNodeName) {
        
        case "A":
            
            p_oAttributes.type = "link";
            
            setAttributeFromDOMAttribute("href");
            setAttributeFromDOMAttribute("target");
        
            break;
    
        case "INPUT":

            setFormElementProperties();

            if (!("checked" in p_oAttributes)) {
    
                p_oAttributes.checked = p_oElement.checked;
    
            }

            break;

        case "BUTTON":

            setFormElementProperties();

            oRootNode = p_oElement.parentNode.parentNode;

            if (Dom.hasClass(oRootNode, sClass + "-checked")) {
            
                p_oAttributes.checked = true;
            
            }

            if (Dom.hasClass(oRootNode, sClass + "-disabled")) {

                p_oAttributes.disabled = true;
            
            }

            p_oElement.removeAttribute("value");

            p_oElement.setAttribute("type", "button");

            break;
        
        }

        p_oElement.removeAttribute("id");
        p_oElement.removeAttribute("name");
        
        if (!("tabindex" in p_oAttributes)) {

            p_oAttributes.tabindex = p_oElement.tabIndex;

        }
    
        if (!("label" in p_oAttributes)) {
    
            // Set the "label" property
        
            sText = sSrcElementNodeName == "INPUT" ? 
                            p_oElement.value : p_oElement.innerHTML;
        
    
            if (sText && sText.length > 0) {
                
                p_oAttributes.label = sText;
                
            } 
    
        }
    
    }
    
    
    /**
	 * @method initConfig
	 * @description Initializes the set of configuration attributes that are
	 *              used to instantiate the button.
	 * @private
	 * @param {Object}
	 *            Object representing the button's set of configuration
	 *            attributes.
	 */
    function initConfig(p_oConfig) {
    
        var oAttributes = p_oConfig.attributes,
            oSrcElement = oAttributes.srcelement,
            sSrcElementNodeName = oSrcElement.nodeName.toUpperCase(),
            me = this;
    
    
        if (sSrcElementNodeName == this.NODE_NAME) {
    
            p_oConfig.element = oSrcElement;
            p_oConfig.id = oSrcElement.id;

            Dom.getElementsBy(function (p_oElement) {
            
                switch (p_oElement.nodeName.toUpperCase()) {
                
                case "BUTTON":
                case "A":
                case "INPUT":

                    setAttributesFromSrcElement.call(me, p_oElement, 
                        oAttributes);

                    break;                        
                
                }
            
            }, "*", oSrcElement);
        
        }
        else {
    
            switch (sSrcElementNodeName) {

            case "BUTTON":
            case "A":
            case "INPUT":

                setAttributesFromSrcElement.call(this, oSrcElement, 
                    oAttributes);

                break;

            }
        
        }
    
    }



    // Constructor

    YAHOO.widget.Button = function (p_oElement, p_oAttributes) {
    
		if (!Overlay && YAHOO.widget.Overlay) {
		
			Overlay = YAHOO.widget.Overlay;
		
		}


		if (!Menu && YAHOO.widget.Menu) {
		
			Menu = YAHOO.widget.Menu;
		
		}


        var fnSuperClass = YAHOO.widget.Button.superclass.constructor,
            oConfig,
            oElement;
    

        if (arguments.length == 1 && !Lang.isString(p_oElement) && !p_oElement.nodeName) {
    
            if (!p_oElement.id) {
    
                p_oElement.id = Dom.generateId();
    
    
            }
    
    
            fnSuperClass.call(this, (this.createButtonElement(p_oElement.type)), p_oElement);
    
        }
        else {
    
            oConfig = { element: null, attributes: (p_oAttributes || {}) };
    
    
            if (Lang.isString(p_oElement)) {
    
                oElement = Dom.get(p_oElement);
    
                if (oElement) {

                    if (!oConfig.attributes.id) {
                    
                        oConfig.attributes.id = p_oElement;
                    
                    }
    
                
                
                    oConfig.attributes.srcelement = oElement;
                
                    initConfig.call(this, oConfig);
                
                
                    if (!oConfig.element) {
                
                
                        oConfig.element = this.createButtonElement(oConfig.attributes.type);
                
                    }
                
                    fnSuperClass.call(this, oConfig.element, oConfig.attributes);
    
                }
    
            }
            else if (p_oElement.nodeName) {
    
                if (!oConfig.attributes.id) {
    
                    if (p_oElement.id) {
        
                        oConfig.attributes.id = p_oElement.id;
                    
                    }
                    else {
        
                        oConfig.attributes.id = Dom.generateId();
        
        
                    }
    
                }
    
    
    
                oConfig.attributes.srcelement = p_oElement;
        
                initConfig.call(this, oConfig);
        
        
                if (!oConfig.element) {
    
            
                    oConfig.element = this.createButtonElement(oConfig.attributes.type);
            
                }
            
                fnSuperClass.call(this, oConfig.element, oConfig.attributes);
            
            }
    
        }
    
    };



    YAHOO.extend(YAHOO.widget.Button, YAHOO.util.Element, {
    
    
        // Protected properties
        
        
        /**
		 * @property _button
		 * @description Object reference to the button's internal
		 *              <code>&#60;a&#62;</code> or
		 *              <code>&#60;button&#62;</code> element.
		 * @default null
		 * @protected
		 * @type <a href="http://www.w3.org/TR/2000/WD-DOM-Level-1-20000929/
		 *       level-one-html.html#ID-48250443">HTMLAnchorElement</a>|<a
		 *       href="
		 *       http://www.w3.org/TR/2000/WD-DOM-Level-1-20000929/level-one-html.html
		 *       #ID-34812697">HTMLButtonElement</a>
		 */
        _button: null,
        
        
        /**
		 * @property _menu
		 * @description Object reference to the button's menu.
		 * @default null
		 * @protected
		 * @type {<a href="YAHOO.widget.Overlay.html">YAHOO.widget.Overlay</a>|
		 *       <a href="YAHOO.widget.Menu.html">YAHOO.widget.Menu</a>}
		 */
        _menu: null,
        
        
        /**
		 * @property _hiddenFields
		 * @description Object reference to the <code>&#60;input&#62;</code>
		 *              element, or array of HTML form elements used to
		 *              represent the button when its parent form is submitted.
		 * @default null
		 * @protected
		 * @type <a href="http://www.w3.org/TR/2000/WD-DOM-Level-1-20000929/
		 *       level-one-html.html#ID-6043025">HTMLInputElement</a>|Array
		 */
        _hiddenFields: null,
        
        
        /**
		 * @property _onclickAttributeValue
		 * @description Object reference to the button's current value for the
		 *              "onclick" configuration attribute.
		 * @default null
		 * @protected
		 * @type Object
		 */
        _onclickAttributeValue: null,
        
        
        /**
		 * @property _activationKeyPressed
		 * @description Boolean indicating if the key(s) that toggle the
		 *              button's "active" state have been pressed.
		 * @default false
		 * @protected
		 * @type Boolean
		 */
        _activationKeyPressed: false,
        
        
        /**
		 * @property _activationButtonPressed
		 * @description Boolean indicating if the mouse button that toggles the
		 *              button's "active" state has been pressed.
		 * @default false
		 * @protected
		 * @type Boolean
		 */
        _activationButtonPressed: false,
        
        
        /**
		 * @property _hasKeyEventHandlers
		 * @description Boolean indicating if the button's "blur", "keydown" and
		 *              "keyup" event handlers are assigned
		 * @default false
		 * @protected
		 * @type Boolean
		 */
        _hasKeyEventHandlers: false,
        
        
        /**
		 * @property _hasMouseEventHandlers
		 * @description Boolean indicating if the button's "mouseout,"
		 *              "mousedown," and "mouseup" event handlers are assigned
		 * @default false
		 * @protected
		 * @type Boolean
		 */
        _hasMouseEventHandlers: false,


        /**
		 * @property _nOptionRegionX
		 * @description Number representing the X coordinate of the leftmost
		 *              edge of the Button's option region. Applies only to
		 *              Buttons of type "split".
		 * @default 0
		 * @protected
		 * @type Number
		 */        
        _nOptionRegionX: 0,
        


        // Constants

        /**
		 * @property CLASS_NAME_PREFIX
		 * @description Prefix used for all class names applied to a Button.
		 * @default "yui-"
		 * @final
		 * @type String
		 */
        CLASS_NAME_PREFIX: "yui-",
        
        
        /**
		 * @property NODE_NAME
		 * @description The name of the node to be used for the button's root
		 *              element.
		 * @default "SPAN"
		 * @final
		 * @type String
		 */
        NODE_NAME: "SPAN",
        
        
        /**
		 * @property CHECK_ACTIVATION_KEYS
		 * @description Array of numbers representing keys that (when pressed)
		 *              toggle the button's "checked" attribute.
		 * @default [32]
		 * @final
		 * @type Array
		 */
        CHECK_ACTIVATION_KEYS: [32],
        
        
        /**
		 * @property ACTIVATION_KEYS
		 * @description Array of numbers representing keys that (when presed)
		 *              toggle the button's "active" state.
		 * @default [13, 32]
		 * @final
		 * @type Array
		 */
        ACTIVATION_KEYS: [13, 32],
        
        
        /**
		 * @property OPTION_AREA_WIDTH
		 * @description Width (in pixels) of the area of a split button that
		 *              when pressed will display a menu.
		 * @default 20
		 * @final
		 * @type Number
		 */
        OPTION_AREA_WIDTH: 20,
        
        
        /**
		 * @property CSS_CLASS_NAME
		 * @description String representing the CSS class(es) to be applied to
		 *              the button's root element.
		 * @default "button"
		 * @final
		 * @type String
		 */
        CSS_CLASS_NAME: "button",
        
        
        
        // Protected attribute setter methods
        
        
        /**
		 * @method _setType
		 * @description Sets the value of the button's "type" attribute.
		 * @protected
		 * @param {String}
		 *            p_sType String indicating the value for the button's
		 *            "type" attribute.
		 */
        _setType: function (p_sType) {
        
            if (p_sType == "split") {
        
                this.on("option", this._onOption);
        
            }
        
        },
        
        
        /**
		 * @method _setLabel
		 * @description Sets the value of the button's "label" attribute.
		 * @protected
		 * @param {HTML}
		 *            p_sLabel String indicating the value for the button's
		 *            "label" attribute.
		 */
        _setLabel: function (p_sLabel) {

            this._button.innerHTML = p_sLabel;

            
            /*
			 * Remove and add the default class name from the root element for
			 * Gecko to ensure that the button shrinkwraps to the label. Without
			 * this the button will not be rendered at the correct width when
			 * the label changes. The most likely cause for this bug is button's
			 * use of the Gecko-specific CSS display type of "-moz-inline-box"
			 * to simulate "inline-block" supported by IE, Safari and Opera.
			 */
            
            var sClass,
                nGeckoVersion = UA.gecko;
				
            
            if (nGeckoVersion && nGeckoVersion < 1.9 && Dom.inDocument(this.get("element"))) {
            
                sClass = (this.CLASS_NAME_PREFIX + this.CSS_CLASS_NAME);

                this.removeClass(sClass);
                
                Lang.later(0, this, this.addClass, sClass);

            }
        
        },
        
        
        /**
		 * @method _setTabIndex
		 * @description Sets the value of the button's "tabindex" attribute.
		 * @protected
		 * @param {Number}
		 *            p_nTabIndex Number indicating the value for the button's
		 *            "tabindex" attribute.
		 */
        _setTabIndex: function (p_nTabIndex) {
        
            this._button.tabIndex = p_nTabIndex;
        
        },
        
        
        /**
		 * @method _setTitle
		 * @description Sets the value of the button's "title" attribute.
		 * @protected
		 * @param {String}
		 *            p_nTabIndex Number indicating the value for the button's
		 *            "title" attribute.
		 */
        _setTitle: function (p_sTitle) {
        
            if (this.get("type") != "link") {
        
                this._button.title = p_sTitle;
        
            }
        
        },
        
        
        /**
		 * @method _setDisabled
		 * @description Sets the value of the button's "disabled" attribute.
		 * @protected
		 * @param {Boolean}
		 *            p_bDisabled Boolean indicating the value for the button's
		 *            "disabled" attribute.
		 */
        _setDisabled: function (p_bDisabled) {
        
            if (this.get("type") != "link") {
        
                if (p_bDisabled) {
        
                    if (this._menu) {
        
                        this._menu.hide();
        
                    }
        
                    if (this.hasFocus()) {
                    
                        this.blur();
                    
                    }
        
                    this._button.setAttribute("disabled", "disabled");
        
                    this.addStateCSSClasses("disabled");

                    this.removeStateCSSClasses("hover");
                    this.removeStateCSSClasses("active");
                    this.removeStateCSSClasses("focus");
        
                }
                else {
        
                    this._button.removeAttribute("disabled");
        
                    this.removeStateCSSClasses("disabled");
                
                }
        
            }
        
        },

        
        /**
		 * @method _setHref
		 * @description Sets the value of the button's "href" attribute.
		 * @protected
		 * @param {String}
		 *            p_sHref String indicating the value for the button's
		 *            "href" attribute.
		 */
        _setHref: function (p_sHref) {
        
            if (this.get("type") == "link") {
        
                this._button.href = p_sHref;
            
            }
        
        },
        
        
        /**
		 * @method _setTarget
		 * @description Sets the value of the button's "target" attribute.
		 * @protected
		 * @param {String}
		 *            p_sTarget String indicating the value for the button's
		 *            "target" attribute.
		 */
        _setTarget: function (p_sTarget) {
        
            if (this.get("type") == "link") {
        
                this._button.setAttribute("target", p_sTarget);
            
            }
        
        },
        
        
        /**
		 * @method _setChecked
		 * @description Sets the value of the button's "target" attribute.
		 * @protected
		 * @param {Boolean}
		 *            p_bChecked Boolean indicating the value for the button's
		 *            "checked" attribute.
		 */
        _setChecked: function (p_bChecked) {
        
            var sType = this.get("type");
        
            if (sType == "checkbox" || sType == "radio") {
        
                if (p_bChecked) {
                    this.addStateCSSClasses("checked");
                }
                else {
                    this.removeStateCSSClasses("checked");
                }
        
            }
        
        },

        
        /**
		 * @method _setMenu
		 * @description Sets the value of the button's "menu" attribute.
		 * @protected
		 * @param {Object}
		 *            p_oMenu Object indicating the value for the button's
		 *            "menu" attribute.
		 */
        _setMenu: function (p_oMenu) {

            var bLazyLoad = this.get("lazyloadmenu"),
                oButtonElement = this.get("element"),
                sMenuCSSClassName,
        
                /*
				 * Boolean indicating if the value of p_oMenu is an instance of
				 * YAHOO.widget.Menu or YAHOO.widget.Overlay.
				 */
        
                bInstance = false,
                oMenu,
                oMenuElement,
                oSrcElement;
        

			function onAppendTo() {

				oMenu.render(oButtonElement.parentNode);
				
				this.removeListener("appendTo", onAppendTo);
			
			}
			
			
			function setMenuContainer() {

				oMenu.cfg.queueProperty("container", oButtonElement.parentNode);
				
				this.removeListener("appendTo", setMenuContainer);
			
			}


			function initMenu() {
		
				var oContainer;
		
				if (oMenu) {

					Dom.addClass(oMenu.element, this.get("menuclassname"));
					Dom.addClass(oMenu.element, this.CLASS_NAME_PREFIX + this.get("type") + "-button-menu");

					oMenu.showEvent.subscribe(this._onMenuShow, null, this);
					oMenu.hideEvent.subscribe(this._onMenuHide, null, this);
					oMenu.renderEvent.subscribe(this._onMenuRender, null, this);


					if (Menu && oMenu instanceof Menu) {

						if (bLazyLoad) {

							oContainer = this.get("container");

							if (oContainer) {

								oMenu.cfg.queueProperty("container", oContainer);

							}
							else {

								this.on("appendTo", setMenuContainer);

							}

						}

						oMenu.cfg.queueProperty("clicktohide", false);

						oMenu.keyDownEvent.subscribe(this._onMenuKeyDown, this, true);
						oMenu.subscribe("click", this._onMenuClick, this, true);

						this.on("selectedMenuItemChange", this._onSelectedMenuItemChange);
		
						oSrcElement = oMenu.srcElement;
		
						if (oSrcElement && oSrcElement.nodeName.toUpperCase() == "SELECT") {

							oSrcElement.style.display = "none";
							oSrcElement.parentNode.removeChild(oSrcElement);
		
						}
		
					}
					else if (Overlay && oMenu instanceof Overlay) {
		
						if (!m_oOverlayManager) {
		
							m_oOverlayManager = new YAHOO.widget.OverlayManager();
						
						}
						
						m_oOverlayManager.register(oMenu);
						
					}
		
		
					this._menu = oMenu;

		
					if (!bInstance && !bLazyLoad) {
		
						if (Dom.inDocument(oButtonElement)) {
	
							oMenu.render(oButtonElement.parentNode);
						
						}
						else {
		
							this.on("appendTo", onAppendTo);
						
						}
					
					}
		
				}
		
			}

        
            if (Overlay) {
        
				if (Menu) {
				
					sMenuCSSClassName = Menu.prototype.CSS_CLASS_NAME;
				
				}
			
				if (p_oMenu && Menu && (p_oMenu instanceof Menu)) {
			
					oMenu = p_oMenu;
					bInstance = true;
			
					initMenu.call(this);
			
				}
				else if (Overlay && p_oMenu && (p_oMenu instanceof Overlay)) {
			
					oMenu = p_oMenu;
					bInstance = true;
			
					oMenu.cfg.queueProperty("visible", false);
			
					initMenu.call(this);
			
				}
				else if (Menu && Lang.isArray(p_oMenu)) {

					oMenu = new Menu(Dom.generateId(), { lazyload: bLazyLoad, itemdata: p_oMenu });
						
					this._menu = oMenu;
			
					this.on("appendTo", initMenu);
			
				}
				else if (Lang.isString(p_oMenu)) {
			
					oMenuElement = Dom.get(p_oMenu);
			
					if (oMenuElement) {
			
						if (Menu && Dom.hasClass(oMenuElement, sMenuCSSClassName) || 
							oMenuElement.nodeName.toUpperCase() == "SELECT") {
				
							oMenu = new Menu(p_oMenu, { lazyload: bLazyLoad });
				
							initMenu.call(this);
				
						}
						else if (Overlay) {
			
							oMenu = new Overlay(p_oMenu, { visible: false });
				
							initMenu.call(this);
				
						}
			
					}
			
				}
				else if (p_oMenu && p_oMenu.nodeName) {
			
					if (Menu && Dom.hasClass(p_oMenu, sMenuCSSClassName) || 
							p_oMenu.nodeName.toUpperCase() == "SELECT") {
			
						oMenu = new Menu(p_oMenu, { lazyload: bLazyLoad });
					
						initMenu.call(this);
			
					}
					else if (Overlay) {
			
						if (!p_oMenu.id) {
						
							Dom.generateId(p_oMenu);
						
						}
			
						oMenu = new Overlay(p_oMenu, { visible: false });
			
						initMenu.call(this);
					
					}
				
				}
            
            }
        
        },
        
        
        /**
		 * @method _setOnClick
		 * @description Sets the value of the button's "onclick" attribute.
		 * @protected
		 * @param {Object}
		 *            p_oObject Object indicating the value for the button's
		 *            "onclick" attribute.
		 */
        _setOnClick: function (p_oObject) {
        
            /*
			 * Remove any existing listeners if a "click" event handler has
			 * already been specified.
			 */
        
            if (this._onclickAttributeValue && 
                (this._onclickAttributeValue != p_oObject)) {
        
                this.removeListener("click", this._onclickAttributeValue.fn);
        
                this._onclickAttributeValue = null;
        
            }
        
        
            if (!this._onclickAttributeValue && 
                Lang.isObject(p_oObject) && 
                Lang.isFunction(p_oObject.fn)) {
        
                this.on("click", p_oObject.fn, p_oObject.obj, p_oObject.scope);
        
                this._onclickAttributeValue = p_oObject;
        
            }
        
        },

        
        
        // Protected methods

        
        
        /**
		 * @method _isActivationKey
		 * @description Determines if the specified keycode is one that toggles
		 *              the button's "active" state.
		 * @protected
		 * @param {Number}
		 *            p_nKeyCode Number representing the keycode to be
		 *            evaluated.
		 * @return {Boolean}
		 */
        _isActivationKey: function (p_nKeyCode) {
        
            var sType = this.get("type"),
                aKeyCodes = (sType == "checkbox" || sType == "radio") ? 
                    this.CHECK_ACTIVATION_KEYS : this.ACTIVATION_KEYS,
        
                nKeyCodes = aKeyCodes.length,
                bReturnVal = false,
                i;
        

            if (nKeyCodes > 0) {
        
                i = nKeyCodes - 1;
        
                do {
        
                    if (p_nKeyCode == aKeyCodes[i]) {
        
                        bReturnVal = true;
                        break;
        
                    }
        
                }
                while (i--);
            
            }
            
            return bReturnVal;
        
        },
        
        
        /**
		 * @method _isSplitButtonOptionKey
		 * @description Determines if the specified keycode is one that toggles
		 *              the display of the split button's menu.
		 * @protected
		 * @param {Event}
		 *            p_oEvent Object representing the DOM event object passed
		 *            back by the event utility (YAHOO.util.Event).
		 * @return {Boolean}
		 */
        _isSplitButtonOptionKey: function (p_oEvent) {

			var bShowMenu = (Event.getCharCode(p_oEvent) == 40);


			var onKeyPress = function (p_oEvent) {

				Event.preventDefault(p_oEvent);

				this.removeListener("keypress", onKeyPress);
			
			};


			// Prevent the browser from scrolling the window
			if (bShowMenu) {

				if (UA.opera) {
	
					this.on("keypress", onKeyPress);
	
				}

				Event.preventDefault(p_oEvent);
			}

            return bShowMenu;
        
        },
        
        
        /**
		 * @method _addListenersToForm
		 * @description Adds event handlers to the button's form.
		 * @protected
		 */
        _addListenersToForm: function () {
        
            var oForm = this.getForm(),
                onFormKeyPress = YAHOO.widget.Button.onFormKeyPress,
                bHasKeyPressListener,
                oSrcElement,
                aListeners,
                nListeners,
                i;
        
        
            if (oForm) {
        
                Event.on(oForm, "reset", this._onFormReset, null, this);
                Event.on(oForm, "submit", this._onFormSubmit, null, this);
        
                oSrcElement = this.get("srcelement");
        
        
                if (this.get("type") == "submit" || 
                    (oSrcElement && oSrcElement.type == "submit")) 
                {
                
                    aListeners = Event.getListeners(oForm, "keypress");
                    bHasKeyPressListener = false;
            
                    if (aListeners) {
            
                        nListeners = aListeners.length;
        
                        if (nListeners > 0) {
            
                            i = nListeners - 1;
                            
                            do {
               
                                if (aListeners[i].fn == onFormKeyPress) {
                
                                    bHasKeyPressListener = true;
                                    break;
                                
                                }
                
                            }
                            while (i--);
                        
                        }
                    
                    }
            
            
                    if (!bHasKeyPressListener) {
               
                        Event.on(oForm, "keypress", onFormKeyPress);
            
                    }
        
                }
            
            }
        
        },
        
        
        
        /**
		 * @method _showMenu
		 * @description Shows the button's menu.
		 * @protected
		 * @param {Event}
		 *            p_oEvent Object representing the DOM event object passed
		 *            back by the event utility (YAHOO.util.Event) that
		 *            triggered the display of the menu.
		 */
        _showMenu: function (p_oEvent) {

            if (YAHOO.widget.MenuManager) {
                YAHOO.widget.MenuManager.hideVisible();
            }

        
            if (m_oOverlayManager) {
                m_oOverlayManager.hideAll();
            }


            var oMenu = this._menu,
            	aMenuAlignment = this.get("menualignment"),
            	bFocusMenu = this.get("focusmenu"),
				fnFocusMethod;


			if (this._renderedMenu) {

				oMenu.cfg.setProperty("context", 
								[this.get("element"), aMenuAlignment[0], aMenuAlignment[1]]);
	
				oMenu.cfg.setProperty("preventcontextoverlap", true);
				oMenu.cfg.setProperty("constraintoviewport", true);

			}
			else {

				oMenu.cfg.queueProperty("context", 
								[this.get("element"), aMenuAlignment[0], aMenuAlignment[1]]);
	
				oMenu.cfg.queueProperty("preventcontextoverlap", true);
				oMenu.cfg.queueProperty("constraintoviewport", true);
			
			}


			/*
			 * Refocus the Button before showing its Menu in case the call to
			 * YAHOO.widget.MenuManager.hideVisible() resulted in another
			 * element in the DOM being focused after another Menu was hidden.
			 */
			
			this.focus();


            if (Menu && oMenu && (oMenu instanceof Menu)) {

				// Since Menus automatically focus themselves when made visible,
				// temporarily
				// replace the Menu focus method so that the value of the
				// Button's "focusmenu"
				// attribute determines if the Menu should be focus when made
				// visible.

				fnFocusMethod = oMenu.focus;

				oMenu.focus = function () {};

				if (this._renderedMenu) {

					oMenu.cfg.setProperty("minscrollheight", this.get("menuminscrollheight"));
					oMenu.cfg.setProperty("maxheight", this.get("menumaxheight"));
				
				}
				else {

					oMenu.cfg.queueProperty("minscrollheight", this.get("menuminscrollheight"));
					oMenu.cfg.queueProperty("maxheight", this.get("menumaxheight"));
				
				}


                oMenu.show();

        		oMenu.focus = fnFocusMethod;

				oMenu.align();
        

                /*
				 * Stop the propagation of the event so that the MenuManager
				 * doesn't blur the menu after it gets focus.
				 */
        
                if (p_oEvent.type == "mousedown") {
                    Event.stopPropagation(p_oEvent);
                }

        
                if (bFocusMenu) { 
                    oMenu.focus();
                }

            }
            else if (Overlay && oMenu && (oMenu instanceof Overlay)) {

				if (!this._renderedMenu) {
		            oMenu.render(this.get("element").parentNode);
				}

                oMenu.show();
				oMenu.align();

            }
        
        },
        
        
        /**
		 * @method _hideMenu
		 * @description Hides the button's menu.
		 * @protected
		 */
        _hideMenu: function () {
        
            var oMenu = this._menu;
        
            if (oMenu) {
        
                oMenu.hide();
        
            }
        
        },
        
        
        
        
        // Protected event handlers
        
        
        /**
		 * @method _onMouseOver
		 * @description "mouseover" event handler for the button.
		 * @protected
		 * @param {Event}
		 *            p_oEvent Object representing the DOM event object passed
		 *            back by the event utility (YAHOO.util.Event).
		 */
        _onMouseOver: function (p_oEvent) {
        
        	var sType = this.get("type"),
        		oElement,
				nOptionRegionX;


			if (sType === "split") {

				oElement = this.get("element");
				nOptionRegionX = 
					(Dom.getX(oElement) + (oElement.offsetWidth - this.OPTION_AREA_WIDTH));
					
				this._nOptionRegionX = nOptionRegionX;
			
			}
        

            if (!this._hasMouseEventHandlers) {
        
				if (sType === "split") {
        
	        		this.on("mousemove", this._onMouseMove);

        		}

                this.on("mouseout", this._onMouseOut);
        
                this._hasMouseEventHandlers = true;
        
            }
        

            this.addStateCSSClasses("hover");


			if (sType === "split" && (Event.getPageX(p_oEvent) > nOptionRegionX)) {
	
				this.addStateCSSClasses("hoveroption");
	
			}

        
            if (this._activationButtonPressed) {
        
                this.addStateCSSClasses("active");
        
            }
        
        
            if (this._bOptionPressed) {
        
                this.addStateCSSClasses("activeoption");
            
            }


            if (this._activationButtonPressed || this._bOptionPressed) {
        
                Event.removeListener(document, "mouseup", this._onDocumentMouseUp);
        
            }

        },


        /**
		 * @method _onMouseMove
		 * @description "mousemove" event handler for the button.
		 * @protected
		 * @param {Event}
		 *            p_oEvent Object representing the DOM event object passed
		 *            back by the event utility (YAHOO.util.Event).
		 */        
        _onMouseMove: function (p_oEvent) {
        
        	var nOptionRegionX = this._nOptionRegionX;
        
        	if (nOptionRegionX) {

				if (Event.getPageX(p_oEvent) > nOptionRegionX) {
					
					this.addStateCSSClasses("hoveroption");
	
				}
				else {

					this.removeStateCSSClasses("hoveroption");
				
				}
				
        	}
        
        },
        
        /**
		 * @method _onMouseOut
		 * @description "mouseout" event handler for the button.
		 * @protected
		 * @param {Event}
		 *            p_oEvent Object representing the DOM event object passed
		 *            back by the event utility (YAHOO.util.Event).
		 */
        _onMouseOut: function (p_oEvent) {

			var sType = this.get("type");
        
            this.removeStateCSSClasses("hover");
        

            if (sType != "menu") {
        
                this.removeStateCSSClasses("active");
        
            }
        

            if (this._activationButtonPressed || this._bOptionPressed) {
        
                Event.on(document, "mouseup", this._onDocumentMouseUp, null, this);
        
            }


			if (sType === "split" && (Event.getPageX(p_oEvent) > this._nOptionRegionX)) {
			
				this.removeStateCSSClasses("hoveroption");
	
			}
            
        },
        
        
        /**
		 * @method _onDocumentMouseUp
		 * @description "mouseup" event handler for the button.
		 * @protected
		 * @param {Event}
		 *            p_oEvent Object representing the DOM event object passed
		 *            back by the event utility (YAHOO.util.Event).
		 */
        _onDocumentMouseUp: function (p_oEvent) {
        
            this._activationButtonPressed = false;
            this._bOptionPressed = false;
        
            var sType = this.get("type"),
                oTarget,
                oMenuElement;
        
            if (sType == "menu" || sType == "split") {

                oTarget = Event.getTarget(p_oEvent);
                oMenuElement = this._menu.element;
        
                if (oTarget != oMenuElement && 
                    !Dom.isAncestor(oMenuElement, oTarget)) {

                    this.removeStateCSSClasses((sType == "menu" ? 
                        "active" : "activeoption"));
            
                    this._hideMenu();

                }
        
            }
        
            Event.removeListener(document, "mouseup", this._onDocumentMouseUp);
        
        },
        
        
        /**
		 * @method _onMouseDown
		 * @description "mousedown" event handler for the button.
		 * @protected
		 * @param {Event}
		 *            p_oEvent Object representing the DOM event object passed
		 *            back by the event utility (YAHOO.util.Event).
		 */
        _onMouseDown: function (p_oEvent) {

            var sType,
            	bReturnVal = true;
        
        
            function onMouseUp() {
            
                this._hideMenu();
                this.removeListener("mouseup", onMouseUp);
            
            }
        
        
            if ((p_oEvent.which || p_oEvent.button) == 1) {
        
        
                if (!this.hasFocus()) {
                    Lang.later(0, this, this.focus);
                    // this.focus();
                }
        
        
                sType = this.get("type");
        
        
                if (sType == "split") {
                
                    if (Event.getPageX(p_oEvent) > this._nOptionRegionX) {
                        
                        this.fireEvent("option", p_oEvent);
						bReturnVal = false;
        
                    }
                    else {
        
                        this.addStateCSSClasses("active");
        
                        this._activationButtonPressed = true;
        
                    }
        
                }
                else if (sType == "menu") {
        
                    if (this.isActive()) {
        
                        this._hideMenu();
        
                        this._activationButtonPressed = false;
        
                    }
                    else {
        
                        this._showMenu(p_oEvent);
        
                        this._activationButtonPressed = true;
                    
                    }
        
                }
                else {
        
                    this.addStateCSSClasses("active");
        
                    this._activationButtonPressed = true;
                
                }
        
        
        
                if (sType == "split" || sType == "menu") {

                    this._hideMenuTimer = Lang.later(250, this, this.on, ["mouseup", onMouseUp]);
        
                }
        
            }
            
            return bReturnVal;
            
        },
        
        
        /**
		 * @method _onMouseUp
		 * @description "mouseup" event handler for the button.
		 * @protected
		 * @param {Event}
		 *            p_oEvent Object representing the DOM event object passed
		 *            back by the event utility (YAHOO.util.Event).
		 */
        _onMouseUp: function (p_oEvent) {
            this.inMouseDown = false;
        
            var sType = this.get("type"),
            	oHideMenuTimer = this._hideMenuTimer,
            	bReturnVal = true;
        
        
            if (oHideMenuTimer) {
  
  				oHideMenuTimer.cancel();
        
            }
        
        
            if (sType == "checkbox" || sType == "radio") {
                if ((p_oEvent.which || p_oEvent.button) != 1) {
                    return;
                }

                this.set("checked", !(this.get("checked")));
            
            }
        
        
            this._activationButtonPressed = false;
            
        
            if (sType != "menu") {
        
                this.removeStateCSSClasses("active");
            
            }

                
			if (sType == "split" && Event.getPageX(p_oEvent) > this._nOptionRegionX) {
				
				bReturnVal = false;

			}

			return bReturnVal;
            
        },
        
        
        /**
		 * @method _onFocus
		 * @description "focus" event handler for the button.
		 * @protected
		 * @param {Event}
		 *            p_oEvent Object representing the DOM event object passed
		 *            back by the event utility (YAHOO.util.Event).
		 */
        _onFocus: function (p_oEvent) {
        
            var oElement;
        
            this.addStateCSSClasses("focus");
        
            if (this._activationKeyPressed) {
        
                this.addStateCSSClasses("active");
           
            }
        
            m_oFocusedButton = this;
        
        
            if (!this._hasKeyEventHandlers) {
        
                oElement = this._button;
        
                Event.on(oElement, "blur", this._onBlur, null, this);
                Event.on(oElement, "keydown", this._onKeyDown, null, this);
                Event.on(oElement, "keyup", this._onKeyUp, null, this);
        
                this._hasKeyEventHandlers = true;
        
            }
        
        
            this.fireEvent("focus", p_oEvent);
        
        },
        
        
        /**
		 * @method _onBlur
		 * @description "blur" event handler for the button.
		 * @protected
		 * @param {Event}
		 *            p_oEvent Object representing the DOM event object passed
		 *            back by the event utility (YAHOO.util.Event).
		 */
        _onBlur: function (p_oEvent) {
        
            this.removeStateCSSClasses("focus");
        
            if (this.get("type") != "menu") {
        
                this.removeStateCSSClasses("active");

            }    
        
            if (this._activationKeyPressed) {
        
                Event.on(document, "keyup", this._onDocumentKeyUp, null, this);
        
            }
        
        
            m_oFocusedButton = null;
        
            this.fireEvent("blur", p_oEvent);
           
        },
        
        
        /**
		 * @method _onDocumentKeyUp
		 * @description "keyup" event handler for the document.
		 * @protected
		 * @param {Event}
		 *            p_oEvent Object representing the DOM event object passed
		 *            back by the event utility (YAHOO.util.Event).
		 */
        _onDocumentKeyUp: function (p_oEvent) {
        
            if (this._isActivationKey(Event.getCharCode(p_oEvent))) {
        
                this._activationKeyPressed = false;
                
                Event.removeListener(document, "keyup", this._onDocumentKeyUp);
            
            }
        
        },
        
        
        /**
		 * @method _onKeyDown
		 * @description "keydown" event handler for the button.
		 * @protected
		 * @param {Event}
		 *            p_oEvent Object representing the DOM event object passed
		 *            back by the event utility (YAHOO.util.Event).
		 */
        _onKeyDown: function (p_oEvent) {
        
            var oMenu = this._menu;
        
        
            if (this.get("type") == "split" && 
                this._isSplitButtonOptionKey(p_oEvent)) {
        
                this.fireEvent("option", p_oEvent);
        
            }
            else if (this._isActivationKey(Event.getCharCode(p_oEvent))) {
        
                if (this.get("type") == "menu") {
        
                    this._showMenu(p_oEvent);
        
                }
                else {
        
                    this._activationKeyPressed = true;
                    
                    this.addStateCSSClasses("active");
                
                }
            
            }
        
        
            if (oMenu && oMenu.cfg.getProperty("visible") && 
                Event.getCharCode(p_oEvent) == 27) {
            
                oMenu.hide();
                this.focus();
            
            }
        
        },
        
        
        /**
		 * @method _onKeyUp
		 * @description "keyup" event handler for the button.
		 * @protected
		 * @param {Event}
		 *            p_oEvent Object representing the DOM event object passed
		 *            back by the event utility (YAHOO.util.Event).
		 */
        _onKeyUp: function (p_oEvent) {
        
            var sType;
        
            if (this._isActivationKey(Event.getCharCode(p_oEvent))) {
        
                sType = this.get("type");
        
                if (sType == "checkbox" || sType == "radio") {
        
                    this.set("checked", !(this.get("checked")));
                
                }
        
                this._activationKeyPressed = false;
        
                if (this.get("type") != "menu") {
        
                    this.removeStateCSSClasses("active");
        
                }
        
            }
        
        },
        
        
        /**
		 * @method _onClick
		 * @description "click" event handler for the button.
		 * @protected
		 * @param {Event}
		 *            p_oEvent Object representing the DOM event object passed
		 *            back by the event utility (YAHOO.util.Event).
		 */
        _onClick: function (p_oEvent) {
        
            var sType = this.get("type"),
                oForm,
                oSrcElement,
                bReturnVal;
        

			switch (sType) {

			case "submit":

				if (p_oEvent.returnValue !== false) {

					this.submitForm();

				}

				break;

			case "reset":

				oForm = this.getForm();

				if (oForm) {

					oForm.reset();

				}

				break;


			case "split":

				if (this._nOptionRegionX > 0 && 
						(Event.getPageX(p_oEvent) > this._nOptionRegionX)) {

					bReturnVal = false;

				}
				else {

					this._hideMenu();

					oSrcElement = this.get("srcelement");

					if (oSrcElement && oSrcElement.type == "submit" && 
							p_oEvent.returnValue !== false) {

						this.submitForm();

					}

				}

				break;

			}

			return bReturnVal;
        
        },
        
        
        /**
		 * @method _onDblClick
		 * @description "dblclick" event handler for the button.
		 * @protected
		 * @param {Event}
		 *            p_oEvent Object representing the DOM event object passed
		 *            back by the event utility (YAHOO.util.Event).
		 */
        _onDblClick: function (p_oEvent) {
        
            var bReturnVal = true;
    
			if (this.get("type") == "split" && Event.getPageX(p_oEvent) > this._nOptionRegionX) {

				bReturnVal = false;
			
			}
        
        	return bReturnVal;
        
        },        
        
        
        /**
		 * @method _onAppendTo
		 * @description "appendTo" event handler for the button.
		 * @protected
		 * @param {Event}
		 *            p_oEvent Object representing the DOM event object passed
		 *            back by the event utility (YAHOO.util.Event).
		 */
        _onAppendTo: function (p_oEvent) {
        
            /*
			 * It is necessary to call "_addListenersToForm" using "setTimeout"
			 * to make sure that the button's "form" property returns a node
			 * reference. Sometimes, if you try to get the reference immediately
			 * after appending the field, it is null.
			 */
        
            Lang.later(0, this, this._addListenersToForm);
        
        },
        
        
        /**
		 * @method _onFormReset
		 * @description "reset" event handler for the button's form.
		 * @protected
		 * @param {Event}
		 *            p_oEvent Object representing the DOM event object passed
		 *            back by the event utility (YAHOO.util.Event).
		 */
        _onFormReset: function (p_oEvent) {
        
            var sType = this.get("type"),
                oMenu = this._menu;
        
            if (sType == "checkbox" || sType == "radio") {
        
                this.resetValue("checked");
        
            }
        
        
            if (Menu && oMenu && (oMenu instanceof Menu)) {
        
                this.resetValue("selectedMenuItem");
        
            }
        
        },


        /**
		 * @method _onFormSubmit
		 * @description "submit" event handler for the button's form.
		 * @protected
		 * @param {Event}
		 *            p_oEvent Object representing the DOM event object passed
		 *            back by the event utility (YAHOO.util.Event).
		 */        
        _onFormSubmit: function (p_oEvent) {
        
        	this.createHiddenFields();
        
        },
        
        
        /**
		 * @method _onDocumentMouseDown
		 * @description "mousedown" event handler for the document.
		 * @protected
		 * @param {Event}
		 *            p_oEvent Object representing the DOM event object passed
		 *            back by the event utility (YAHOO.util.Event).
		 */
        _onDocumentMouseDown: function (p_oEvent) {

            var oTarget = Event.getTarget(p_oEvent),
                oButtonElement = this.get("element"),
                oMenuElement = this._menu.element;
           
            function findTargetInSubmenus(aSubmenus) {
                var i, iMax, oSubmenuElement;
                if (!aSubmenus) {
                    return true;
                }
                for (i = 0, iMax = aSubmenus.length; i < iMax; i++) {
                    oSubmenuElement = aSubmenus[i].element;
                    if (oTarget == oSubmenuElement || Dom.isAncestor(oSubmenuElement, oTarget)) {
                        return true;
                    }
                    if (aSubmenus[i] && aSubmenus[i].getSubmenus) {
                        if (findTargetInSubmenus(aSubmenus[i].getSubmenus())) {
                            return true;
                        }
                    }
                }
        
                return false;
            }

            if (oTarget != oButtonElement && 
                !Dom.isAncestor(oButtonElement, oTarget) && 
                oTarget != oMenuElement && 
                !Dom.isAncestor(oMenuElement, oTarget)) {
                
                
                if (this._menu  && this._menu.getSubmenus) {
                    if (!findTargetInSubmenus(this._menu.getSubmenus())) {
                        return;
                    }
                }
                

                this._hideMenu();

				// In IE when the user mouses down on a focusable element
				// that element will be focused and become the "activeElement".
				// (http://msdn.microsoft.com/en-us/library/ms533065(VS.85).aspx)
				// However, there is a bug in IE where if there is a
				// positioned element with a focused descendant that is
				// hidden in response to the mousedown event, the target of
				// the mousedown event will appear to have focus, but will
				// not be set as the activeElement. This will result
				// in the element not firing key events, even though it
				// appears to have focus. The following call to "setActive"
				// fixes this bug.

                if (UA.ie && (UA.ie < 9) && oTarget.focus) {
					oTarget.setActive();
				}
        
                Event.removeListener(document, "mousedown", 
                    this._onDocumentMouseDown);    
            
            }
        
        },
        
        
        /**
		 * @method _onOption
		 * @description "option" event handler for the button.
		 * @protected
		 * @param {Event}
		 *            p_oEvent Object representing the DOM event object passed
		 *            back by the event utility (YAHOO.util.Event).
		 */
        _onOption: function (p_oEvent) {
        
            if (this.hasClass(this.CLASS_NAME_PREFIX + "split-button-activeoption")) {
        
                this._hideMenu();
        
                this._bOptionPressed = false;
        
            }
            else {
        
                this._showMenu(p_oEvent);    
        
                this._bOptionPressed = true;
        
            }
        
        },
        
        
        /**
		 * @method _onMenuShow
		 * @description "show" event handler for the button's menu.
		 * @private
		 * @param {String}
		 *            p_sType String representing the name of the event that was
		 *            fired.
		 */
        _onMenuShow: function (p_sType) {
        
            Event.on(document, "mousedown", this._onDocumentMouseDown, 
                null, this);
        
            var sState = (this.get("type") == "split") ? "activeoption" : "active";
        
            this.addStateCSSClasses(sState);
        
        },
        
        
        /**
		 * @method _onMenuHide
		 * @description "hide" event handler for the button's menu.
		 * @private
		 * @param {String}
		 *            p_sType String representing the name of the event that was
		 *            fired.
		 */
        _onMenuHide: function (p_sType) {
            
            var sState = (this.get("type") == "split") ? "activeoption" : "active";
        
            this.removeStateCSSClasses(sState);
        
        
            if (this.get("type") == "split") {
        
                this._bOptionPressed = false;
            
            }
        
        },
        
        
        /**
		 * @method _onMenuKeyDown
		 * @description "keydown" event handler for the button's menu.
		 * @private
		 * @param {String}
		 *            p_sType String representing the name of the event that was
		 *            fired.
		 * @param {Array}
		 *            p_aArgs Array of arguments sent when the event was fired.
		 */
        _onMenuKeyDown: function (p_sType, p_aArgs) {
        
            var oEvent = p_aArgs[0];
        
            if (Event.getCharCode(oEvent) == 27) {
        
                this.focus();
        
                if (this.get("type") == "split") {
                
                    this._bOptionPressed = false;
                
                }
        
            }
        
        },
        
        
        /**
		 * @method _onMenuRender
		 * @description "render" event handler for the button's menu.
		 * @private
		 * @param {String}
		 *            p_sType String representing the name of the event thatwas
		 *            fired.
		 */
        _onMenuRender: function (p_sType) {
        
            var oButtonElement = this.get("element"),
                oButtonParent = oButtonElement.parentNode,
				oMenu = this._menu,
                oMenuElement = oMenu.element,
				oSrcElement = oMenu.srcElement,
				oItem;
        
        
            if (oButtonParent != oMenuElement.parentNode) {
        
                oButtonParent.appendChild(oMenuElement);
            
            }

			this._renderedMenu = true;

			// If the user has designated an <option> of the Menu's source
			// <select> element to be selected, sync the selectedIndex with
			// the "selectedMenuItem" Attribute.

			if (oSrcElement && 
					oSrcElement.nodeName.toLowerCase() === "select" && 
					oSrcElement.value) {
				
				
				oItem = oMenu.getItem(oSrcElement.selectedIndex);
				
				// Set the value of the "selectedMenuItem" attribute
				// silently since this is the initial set--synchronizing
				// the value of the source <SELECT> element in the DOM with
				// its corresponding Menu instance.

				this.set("selectedMenuItem", oItem, true);
				
				// Call the "_onSelectedMenuItemChange" method since the
				// attribute was set silently.

				this._onSelectedMenuItemChange({ newValue: oItem });
				
			}

        },

        
        
        /**
		 * @method _onMenuClick
		 * @description "click" event handler for the button's menu.
		 * @private
		 * @param {String}
		 *            p_sType String representing the name of the event that was
		 *            fired.
		 * @param {Array}
		 *            p_aArgs Array of arguments sent when the event was fired.
		 */
        _onMenuClick: function (p_sType, p_aArgs) {

            var oItem = p_aArgs[1],
                oSrcElement;
        
            if (oItem) {
        
				this.set("selectedMenuItem", oItem);

                oSrcElement = this.get("srcelement");
            
                if (oSrcElement && oSrcElement.type == "submit") {
        
                    this.submitForm();
            
                }
            
                this._hideMenu();
            
            }
        
        },


        /**
		 * @method _onSelectedMenuItemChange
		 * @description "selectedMenuItemChange" event handler for the Button's
		 *              "selectedMenuItem" attribute.
		 * @param {Event}
		 *            event Object representing the DOM event object passed back
		 *            by the event utility (YAHOO.util.Event).
		 */
		_onSelectedMenuItemChange: function (event) {
		
			var oSelected = event.prevValue,
				oItem = event.newValue,
				sPrefix = this.CLASS_NAME_PREFIX;

			if (oSelected) {
				Dom.removeClass(oSelected.element, (sPrefix + "button-selectedmenuitem"));
			}
			
			if (oItem) {
				Dom.addClass(oItem.element, (sPrefix + "button-selectedmenuitem"));
			}
			
		},        
        

        /**
		 * @method _onLabelClick
		 * @description "click" event handler for the Button's
		 *              <code>&#60;label&#62;</code> element.
		 * @param {Event}
		 *            event Object representing the DOM event object passed back
		 *            by the event utility (YAHOO.util.Event).
		 */
		_onLabelClick: function (event) {

			this.focus();

			var sType = this.get("type");

			if (sType == "radio" || sType == "checkbox") {
				this.set("checked", (!this.get("checked")));						
			}
			
		},

        
        // Public methods
        
        
        /**
		 * @method createButtonElement
		 * @description Creates the button's HTML elements.
		 * @param {String}
		 *            p_sType String indicating the type of element to create.
		 * @return {<a href="http://www.w3.org/TR/2000/WD-DOM-Level-1-20000929/
		 *         level-one-html.html#ID-58190037">HTMLElement</a>}
		 */
        createButtonElement: function (p_sType) {
        
            var sNodeName = this.NODE_NAME,
                oElement = document.createElement(sNodeName);
        
            oElement.innerHTML =  "<" + sNodeName + " class=\"first-child\">" + 
                (p_sType == "link" ? "<a></a>" : 
                "<button type=\"button\"></button>") + "</" + sNodeName + ">";
        
            return oElement;
        
        },

        
        /**
		 * @method addStateCSSClasses
		 * @description Appends state-specific CSS classes to the button's root
		 *              DOM element.
		 */
        addStateCSSClasses: function (p_sState) {
        
            var sType = this.get("type"),
				sPrefix = this.CLASS_NAME_PREFIX;
        
            if (Lang.isString(p_sState)) {
        
                if (p_sState != "activeoption" && p_sState != "hoveroption") {
        
                    this.addClass(sPrefix + this.CSS_CLASS_NAME + ("-" + p_sState));
        
                }
        
                this.addClass(sPrefix + sType + ("-button-" + p_sState));
            
            }
        
        },
        
        
        /**
		 * @method removeStateCSSClasses
		 * @description Removes state-specific CSS classes to the button's root
		 *              DOM element.
		 */
        removeStateCSSClasses: function (p_sState) {
        
            var sType = this.get("type"),
				sPrefix = this.CLASS_NAME_PREFIX;
        
            if (Lang.isString(p_sState)) {
        
                this.removeClass(sPrefix + this.CSS_CLASS_NAME + ("-" + p_sState));
                this.removeClass(sPrefix + sType + ("-button-" + p_sState));
            
            }
        
        },
        
        
        /**
		 * @method createHiddenFields
		 * @description Creates the button's hidden form field and appends it to
		 *              its parent form.
		 * @return {<a href="http://www.w3.org/TR/2000/WD-DOM-Level-1-20000929/
		 *         level-one-html.html#ID-6043025">HTMLInputElement</a>|Array}
		 */
        createHiddenFields: function () {
        
            this.removeHiddenFields();
        
            var oForm = this.getForm(),
                oButtonField,
                sType,
                bCheckable,
                oMenu,
                oMenuItem,
                sButtonName,
                oValue,
                oMenuField,
                oReturnVal,
				sMenuFieldName,
				oMenuSrcElement,
				bMenuSrcElementIsSelect = false;
        
        
            if (oForm && !this.get("disabled")) {
        
                sType = this.get("type");
                bCheckable = (sType == "checkbox" || sType == "radio");
        
        
                if ((bCheckable && this.get("checked")) || (m_oSubmitTrigger == this)) {
                
        
                    oButtonField = createInputElement((bCheckable ? sType : "hidden"),
                                    this.get("name"), this.get("value"), this.get("checked"));
            
            
                    if (oButtonField) {
            
                        if (bCheckable) {
            
                            oButtonField.style.display = "none";
            
                        }
            
                        oForm.appendChild(oButtonField);
            
                    }
        
                }
                    
        
                oMenu = this._menu;
            
            
                if (Menu && oMenu && (oMenu instanceof Menu)) {
        
        
                    oMenuItem = this.get("selectedMenuItem");
					oMenuSrcElement = oMenu.srcElement;
					bMenuSrcElementIsSelect = (oMenuSrcElement && 
												oMenuSrcElement.nodeName.toUpperCase() == "SELECT");

                    if (oMenuItem) {

						oValue = (oMenuItem.value === null || oMenuItem.value === "") ? 
									oMenuItem.cfg.getProperty("text") : oMenuItem.value;

						sButtonName = this.get("name");


						if (bMenuSrcElementIsSelect) {
						
							sMenuFieldName = oMenuSrcElement.name;
						
						}
						else if (sButtonName) {

							sMenuFieldName = (sButtonName + "_options");
						
						}
						

						if (oValue && sMenuFieldName) {
		
							oMenuField = createInputElement("hidden", sMenuFieldName, oValue);
							oForm.appendChild(oMenuField);
		
						}
                    
                    }
                    else if (bMenuSrcElementIsSelect) {
					
						oMenuField = oForm.appendChild(oMenuSrcElement);
                    
                    }
        
                }
            
            
                if (oButtonField && oMenuField) {
        
                    this._hiddenFields = [oButtonField, oMenuField];
        
                }
                else if (!oButtonField && oMenuField) {
        
                    this._hiddenFields = oMenuField;
                
                }
                else if (oButtonField && !oMenuField) {
        
                    this._hiddenFields = oButtonField;
                
                }
        
        		oReturnVal = this._hiddenFields;
        
            }

			return oReturnVal;
        
        },
        
        
        /**
		 * @method removeHiddenFields
		 * @description Removes the button's hidden form field(s) from its
		 *              parent form.
		 */
        removeHiddenFields: function () {
        
            var oField = this._hiddenFields,
                nFields,
                i;
        
            function removeChild(p_oElement) {
        
                if (Dom.inDocument(p_oElement)) {
        
                    p_oElement.parentNode.removeChild(p_oElement);

                }
                
            }
            
        
            if (oField) {
        
                if (Lang.isArray(oField)) {
        
                    nFields = oField.length;
                    
                    if (nFields > 0) {
                    
                        i = nFields - 1;
                        
                        do {
        
                            removeChild(oField[i]);
        
                        }
                        while (i--);
                    
                    }
                
                }
                else {
        
                    removeChild(oField);
        
                }
        
                this._hiddenFields = null;
            
            }
        
        },
        
        
        /**
		 * @method submitForm
		 * @description Submits the form to which the button belongs. Returns
		 *              true if the form was submitted successfully, false if
		 *              the submission was cancelled.
		 * @protected
		 * @return {Boolean}
		 */
        submitForm: function () {
        
            var oForm = this.getForm(),
        
                oSrcElement = this.get("srcelement"),
        
                /*
				 * Boolean indicating if the event fired successfully (was not
				 * cancelled by any handlers)
				 */
        
                bSubmitForm = false,
                
                oEvent;
        
        
            if (oForm) {
        
                if (this.get("type") == "submit" || (oSrcElement && oSrcElement.type == "submit")) {
        
                    m_oSubmitTrigger = this;
                    
                }
        
        
                if (UA.ie && (UA.ie < 9)) {
        
                    bSubmitForm = oForm.fireEvent("onsubmit");
        
                }
                else {  // Gecko, Opera, and Safari
        
                    oEvent = document.createEvent("HTMLEvents");
                    oEvent.initEvent("submit", true, true);
        
                    bSubmitForm = oForm.dispatchEvent(oEvent);
        
                }
        
        
                /*
				 * In IE and Safari, dispatching a "submit" event to a form WILL
				 * cause the form's "submit" event to fire, but WILL NOT submit
				 * the form. Therefore, we need to call the "submit" method as
				 * well.
				 */
              
                if ((UA.ie || UA.webkit) && bSubmitForm) {
        
                    oForm.submit();
                
                }
            
            }
        
            return bSubmitForm;
            
        },
        
        
        /**
		 * @method init
		 * @description The Button class's initialization method.
		 * @param {String}
		 *            p_oElement String specifying the id attribute of the
		 *            <code>&#60;input&#62;</code>,
		 *            <code>&#60;button&#62;</code>, <code>&#60;a&#62;</code>,
		 *            or <code>&#60;span&#62;</code> element to be used to
		 *            create the button.
		 * @param {
		 *            <a
		 *            href="http://www.w3.org/TR/2000/WD-DOM-Level-1-20000929/
		 *            level-one-html.html#ID-6043025">HTMLInputElement</a>|<a
		 *            href="http://
		 *            www.w3.org/TR/2000/WD-DOM-Level-1-20000929/level-one-html.html
		 *            #ID-34812697">HTMLButtonElement</a>|<a
		 *            href="http://www.w3.org/TR
		 *            /2000/WD-DOM-Level-1-20000929/level-one-html.html#ID-33759296">
		 *            HTMLElement</a>} p_oElement Object reference for the
		 *            <code>&#60;input&#62;</code>,
		 *            <code>&#60;button&#62;</code>, <code>&#60;a&#62;</code>,
		 *            or <code>&#60;span&#62;</code> element to be used to
		 *            create the button.
		 * @param {Object}
		 *            p_oElement Object literal specifying a set of
		 *            configuration attributes used to create the button.
		 * @param {Object}
		 *            p_oAttributes Optional. Object literal specifying a set of
		 *            configuration attributes used to create the button.
		 */
        init: function (p_oElement, p_oAttributes) {
        
            var sNodeName = p_oAttributes.type == "link" ? "a" : "button",
                oSrcElement = p_oAttributes.srcelement,
                oButton = p_oElement.getElementsByTagName(sNodeName)[0],
                oInput;


            if (!oButton) {

                oInput = p_oElement.getElementsByTagName("input")[0];


                if (oInput) {

                    oButton = document.createElement("button");
                    oButton.setAttribute("type", "button");

                    oInput.parentNode.replaceChild(oButton, oInput);
                
                }

            }

            this._button = oButton;


            YAHOO.widget.Button.superclass.init.call(this, p_oElement, p_oAttributes);


			var sId = this.get("id"),
				sButtonId = sId + "-button";


        	oButton.id = sButtonId;


			var aLabels,
				oLabel;


        	var hasLabel = function (element) {
        	
				return (element.htmlFor === sId);

        	};


			var setLabel = function () {

				oLabel.setAttribute((UA.ie ? "htmlFor" : "for"), sButtonId);
			
			};


			if (oSrcElement && this.get("type") != "link") {

				aLabels = Dom.getElementsBy(hasLabel, "label");

				if (Lang.isArray(aLabels) && aLabels.length > 0) {
				
					oLabel = aLabels[0];
				
				}

			}
        

            m_oButtons[sId] = this;

        	var sPrefix = this.CLASS_NAME_PREFIX;

            this.addClass(sPrefix + this.CSS_CLASS_NAME);
            this.addClass(sPrefix + this.get("type") + "-button");
        
            Event.on(this._button, "focus", this._onFocus, null, this);
            this.on("mouseover", this._onMouseOver);
			this.on("mousedown", this._onMouseDown);
			this.on("mouseup", this._onMouseUp);
            this.on("click", this._onClick);

			// Need to reset the value of the "onclick" Attribute so that any
			// handlers registered via the "onclick" Attribute are fired after
			// Button's default "_onClick" listener.

			var fnOnClick = this.get("onclick");

			this.set("onclick", null);
			this.set("onclick", fnOnClick);

            this.on("dblclick", this._onDblClick);


			var oParentNode;

            if (oLabel) {
            
				if (this.get("replaceLabel")) {

					this.set("label", oLabel.innerHTML);
					
					oParentNode = oLabel.parentNode;
					
					oParentNode.removeChild(oLabel);
					
				}
				else {

					this.on("appendTo", setLabel); 

					Event.on(oLabel, "click", this._onLabelClick, null, this);

					this._label = oLabel;
					
				}
            
            }
            
            this.on("appendTo", this._onAppendTo);
       
        

            var oContainer = this.get("container"),
                oElement = this.get("element"),
                bElInDoc = Dom.inDocument(oElement);


            if (oContainer) {
        
                if (oSrcElement && oSrcElement != oElement) {
                
                    oParentNode = oSrcElement.parentNode;

                    if (oParentNode) {
                    
                        oParentNode.removeChild(oSrcElement);
                    
                    }

                }
        
                if (Lang.isString(oContainer)) {
        
                    Event.onContentReady(oContainer, this.appendTo, oContainer, this);
        
                }
                else {
        
        			this.on("init", function () {
        			
        				Lang.later(0, this, this.appendTo, oContainer);
        			
        			});
        
                }
        
            }
            else if (!bElInDoc && oSrcElement && oSrcElement != oElement) {

                oParentNode = oSrcElement.parentNode;
        
                if (oParentNode) {
        
                    this.fireEvent("beforeAppendTo", {
                        type: "beforeAppendTo",
                        target: oParentNode
                    });
            
                    oParentNode.replaceChild(oElement, oSrcElement);
            
                    this.fireEvent("appendTo", {
                        type: "appendTo",
                        target: oParentNode
                    });
                
                }
        
            }
            else if (this.get("type") != "link" && bElInDoc && oSrcElement && 
                oSrcElement == oElement) {
        
                this._addListenersToForm();
        
            }
        
        

			this.fireEvent("init", {
				type: "init",
				target: this
			});        
        
        },
        
        
        /**
		 * @method initAttributes
		 * @description Initializes all of the configuration attributes used to
		 *              create the button.
		 * @param {Object}
		 *            p_oAttributes Object literal specifying a set of
		 *            configuration attributes used to create the button.
		 */
        initAttributes: function (p_oAttributes) {
        
            var oAttributes = p_oAttributes || {};
        
            YAHOO.widget.Button.superclass.initAttributes.call(this, 
                oAttributes);
        
        
            /**
			 * @attribute type
			 * @description String specifying the button's type. Possible values
			 *              are: "push," "link," "submit," "reset," "checkbox,"
			 *              "radio," "menu," and "split."
			 * @default "push"
			 * @type String
			 * @writeonce
			 */
            this.setAttributeConfig("type", {
        
                value: (oAttributes.type || "push"),
                validator: Lang.isString,
                writeOnce: true,
                method: this._setType

            });
        
        
            /**
			 * @attribute label
			 * @description {HTML} specifying the button's text label or
			 *              innerHTML.
			 * @default null
			 * @type String
			 */
            this.setAttributeConfig("label", {
        
                value: oAttributes.label,
                validator: Lang.isString,
                method: this._setLabel
        
            });
        
        
            /**
			 * @attribute value
			 * @description Object specifying the value for the button.
			 * @default null
			 * @type Object
			 */
            this.setAttributeConfig("value", {
        
                value: oAttributes.value
        
            });
        
        
            /**
			 * @attribute name
			 * @description String specifying the name for the button.
			 * @default null
			 * @type String
			 */
            this.setAttributeConfig("name", {
        
                value: oAttributes.name,
                validator: Lang.isString
        
            });
        
        
            /**
			 * @attribute tabindex
			 * @description Number specifying the tabindex for the button.
			 * @default null
			 * @type Number
			 */
            this.setAttributeConfig("tabindex", {
        
                value: oAttributes.tabindex,
                validator: Lang.isNumber,
                method: this._setTabIndex
        
            });
        
        
            /**
			 * @attribute title
			 * @description String specifying the title for the button.
			 * @default null
			 * @type String
			 */
            this.configureAttribute("title", {
        
                value: oAttributes.title,
                validator: Lang.isString,
                method: this._setTitle
        
            });
        
        
            /**
			 * @attribute disabled
			 * @description Boolean indicating if the button should be disabled.
			 *              (Disabled buttons are dimmed and will not respond to
			 *              user input or fire events. Does not apply to
			 *              button's of type "link.")
			 * @default false
			 * @type Boolean
			 */
            this.setAttributeConfig("disabled", {
        
                value: (oAttributes.disabled || false),
                validator: Lang.isBoolean,
                method: this._setDisabled
        
            });
        
        
            /**
			 * @attribute href
			 * @description String specifying the href for the button. Applies
			 *              only to buttons of type "link."
			 * @type String
			 */
            this.setAttributeConfig("href", {
        
                value: oAttributes.href,
                validator: Lang.isString,
                method: this._setHref
        
            });
        
        
            /**
			 * @attribute target
			 * @description String specifying the target for the button. Applies
			 *              only to buttons of type "link."
			 * @type String
			 */
            this.setAttributeConfig("target", {
        
                value: oAttributes.target,
                validator: Lang.isString,
                method: this._setTarget
        
            });
        
        
            /**
			 * @attribute checked
			 * @description Boolean indicating if the button is checked. Applies
			 *              only to buttons of type "radio" and "checkbox."
			 * @default false
			 * @type Boolean
			 */
            this.setAttributeConfig("checked", {
        
                value: (oAttributes.checked || false),
                validator: Lang.isBoolean,
                method: this._setChecked
        
            });
        
        
            /**
			 * @attribute container
			 * @description HTML element reference or string specifying the id
			 *              attribute of the HTML element that the button's
			 *              markup should be rendered into.
			 * @type <a href="http://www.w3.org/TR/2000/WD-DOM-Level-1-20000929/
			 *       level-one-html.html#ID-58190037">HTMLElement</a>|String
			 * @default null
			 * @writeonce
			 */
            this.setAttributeConfig("container", {
        
                value: oAttributes.container,
                writeOnce: true
        
            });
        
        
            /**
			 * @attribute srcelement
			 * @description Object reference to the HTML element (either
			 *              <code>&#60;input&#62;</code> or
			 *              <code>&#60;span&#62;</code>) used to create the
			 *              button.
			 * @type <a href="http://www.w3.org/TR/2000/WD-DOM-Level-1-20000929/
			 *       level-one-html.html#ID-58190037">HTMLElement</a>|String
			 * @default null
			 * @writeonce
			 */
            this.setAttributeConfig("srcelement", {
        
                value: oAttributes.srcelement,
                writeOnce: true
        
            });
        
        
            /**
			 * @attribute menu
			 * @description Object specifying the menu for the button. The value
			 *              can be one of the following:
			 *              <ul>
			 *              <li>Object specifying a rendered <a
			 *              href="YAHOO.widget.Menu.html"> YAHOO.widget.Menu</a>
			 *              instance.</li>
			 *              <li>Object specifying a rendered <a
			 *              href="YAHOO.widget.Overlay.html">
			 *              YAHOO.widget.Overlay</a> instance.</li>
			 *              <li>String specifying the id attribute of the
			 *              <code>&#60;div&#62;
            * </code> element used to create
			 *              the menu. By default the menu will be created as an
			 *              instance of <a
			 *              href="YAHOO.widget.Overlay.html">YAHOO.widget.Overlay</a>.
			 *              If the <a
			 *              href="YAHOO.widget.Menu.html#CSS_CLASS_NAME">
			 *              default CSS class name for YAHOO.widget.Menu</a> is
			 *              applied to the <code>&#60;div&#62;</code> element,
			 *              it will be created as an instance of <a
			 *              href="YAHOO.widget.Menu.html">YAHOO.widget.Menu
			 *              </a>.</li>
			 *              <li>String specifying the id attribute of the
			 *              <code>&#60;select&#62;</code> element used to
			 *              create the menu. </li>
			 *              <li>Object specifying the
			 *              <code>&#60;div&#62;</code> element used to create
			 *              the menu.</li>
			 *              <li>Object specifying the
			 *              <code>&#60;select&#62;</code> element used to
			 *              create the menu.</li>
			 *              <li>Array of object literals, each representing a
			 *              set of <a
			 *              href="YAHOO.widget.MenuItem.html">YAHOO.widget.MenuItem</a>
			 *              configuration attributes.</li>
			 *              <li>Array of strings representing the text labels
			 *              for each menu item in the menu.</li>
			 *              </ul>
			 * @type <a href="YAHOO.widget.Menu.html">YAHOO.widget.Menu</a>|<a
			 *       href="YAHOO.widget.Overlay.html">YAHOO.widget.Overlay</a>|<a
			 *       href="http://www.w3.org/TR/2000/WD-DOM-Level-1-20000929/level-
			 *       one-html.html#ID-58190037">HTMLElement</a>|String|Array
			 * @default null
			 * @writeonce
			 */
            this.setAttributeConfig("menu", {
        
                value: null,
                method: this._setMenu,
                writeOnce: true
            
            });
        
        
            /**
			 * @attribute lazyloadmenu
			 * @description Boolean indicating the value to set for the <a
			 *              href="YAHOO.widget.Menu.html#lazyLoad">"lazyload"</a>
			 *              configuration property of the button's menu. Setting
			 *              "lazyloadmenu" to <code>true </code> will defer
			 *              rendering of the button's menu until the first time
			 *              it is made visible. If "lazyloadmenu" is set to
			 *              <code>false</code>, the button's menu will be
			 *              rendered immediately if the button is in the
			 *              document, or in response to the button's "appendTo"
			 *              event if the button is not yet in the document. In
			 *              either case, the menu is rendered into the button's
			 *              parent HTML element.
			 *              <em>This attribute does not apply if a 
            * <a href="YAHOO.widget.Menu.html">YAHOO.widget.Menu</a> or 
            * <a href="YAHOO.widget.Overlay.html">YAHOO.widget.Overlay</a> 
            * instance is passed as the value of the button's "menu" 
            * configuration attribute. <a href="YAHOO.widget.Menu.html">
            * YAHOO.widget.Menu</a> or <a href="YAHOO.widget.Overlay.html">
            * YAHOO.widget.Overlay</a> instances should be rendered before 
            * being set as the value for the "menu" configuration 
            * attribute.</em>
			 * @default true
			 * @type Boolean
			 * @writeonce
			 */
            this.setAttributeConfig("lazyloadmenu", {
        
                value: (oAttributes.lazyloadmenu === false ? false : true),
                validator: Lang.isBoolean,
                writeOnce: true
        
            });


            /**
			 * @attribute menuclassname
			 * @description String representing the CSS class name to be applied
			 *              to the root element of the button's menu.
			 * @type String
			 * @default "yui-button-menu"
			 * @writeonce
			 */
            this.setAttributeConfig("menuclassname", {
        
                value: (oAttributes.menuclassname || (this.CLASS_NAME_PREFIX + "button-menu")),
                validator: Lang.isString,
                method: this._setMenuClassName,
                writeOnce: true
        
            });        


			/**
			 * @attribute menuminscrollheight
			 * @description Number defining the minimum threshold for the
			 *              "menumaxheight" configuration attribute. When set
			 *              this attribute is automatically applied to all
			 *              submenus.
			 * @default 90
			 * @type Number
			 */
            this.setAttributeConfig("menuminscrollheight", {
        
                value: (oAttributes.menuminscrollheight || 90),
                validator: Lang.isNumber
        
            });


            /**
			 * @attribute menumaxheight
			 * @description Number defining the maximum height (in pixels) for a
			 *              menu's body element (<code>&#60;div class="bd"&#60;</code>).
			 *              Once a menu's body exceeds this height, the contents
			 *              of the body are scrolled to maintain this value.
			 *              This value cannot be set lower than the value of the
			 *              "minscrollheight" configuration property.
			 * @type Number
			 * @default 0
			 */
            this.setAttributeConfig("menumaxheight", {
        
                value: (oAttributes.menumaxheight || 0),
                validator: Lang.isNumber
        
            });


            /**
			 * @attribute menualignment
			 * @description Array defining how the Button's Menu is aligned to
			 *              the Button. The default value of ["tl", "bl"] aligns
			 *              the Menu's top left corner to the Button's bottom
			 *              left corner.
			 * @type Array
			 * @default ["tl", "bl"]
			 */
            this.setAttributeConfig("menualignment", {
        
                value: (oAttributes.menualignment || ["tl", "bl"]),
                validator: Lang.isArray
        
            });
            

            /**
			 * @attribute selectedMenuItem
			 * @description Object representing the item in the button's menu
			 *              that is currently selected.
			 * @type YAHOO.widget.MenuItem
			 * @default null
			 */
            this.setAttributeConfig("selectedMenuItem", {
        
                value: null
        
            });
        
        
            /**
			 * @attribute onclick
			 * @description Object literal representing the code to be executed
			 *              when the button is clicked. Format:<br>
			 *              <code> {<br> 
            * <strong>fn:</strong> Function,   &#47;&#47; The handler to call 
            * when the event fires.<br> <strong>obj:</strong> Object, 
            * &#47;&#47; An object to pass back to the handler.<br> 
            * <strong>scope:</strong> Object &#47;&#47;  The object to use 
            * for the scope of the handler.<br> } </code>
			 * @type Object
			 * @default null
			 */
            this.setAttributeConfig("onclick", {
        
                value: oAttributes.onclick,
                method: this._setOnClick
            
            });


            /**
			 * @attribute focusmenu
			 * @description Boolean indicating whether or not the button's menu
			 *              should be focused when it is made visible.
			 * @type Boolean
			 * @default true
			 */
            this.setAttributeConfig("focusmenu", {
        
                value: (oAttributes.focusmenu === false ? false : true),
                validator: Lang.isBoolean
        
            });


            /**
			 * @attribute replaceLabel
			 * @description Boolean indicating whether or not the text of the
			 *              button's <code>&#60;label&#62;</code> element
			 *              should be used as the source for the button's label
			 *              configuration attribute and removed from the DOM.
			 * @type Boolean
			 * @default false
			 */
            this.setAttributeConfig("replaceLabel", {
        
                value: false,
                validator: Lang.isBoolean,
                writeOnce: true
        
            });

        },
        
        
        /**
		 * @method focus
		 * @description Causes the button to receive the focus and fires the
		 *              button's "focus" event.
		 */
        focus: function () {
        
            if (!this.get("disabled")) {
                // Adding a try/catch in case the element is not
                // visible by the time it's focus is being called.
                // for example, on a dialog that closes on button click
                try {
                    this._button.focus();
                } catch (e) {}
            
            }
        
        },
        
        
        /**
		 * @method blur
		 * @description Causes the button to lose focus and fires the button's
		 *              "blur" event.
		 */
        blur: function () {
        
            if (!this.get("disabled")) {
                // Adding a try/catch in case the element is not
                // visible by the time it's focus is being called.
                // for example, on a dialog that closes on button click
                try {
                    this._button.blur();
                } catch (e) {}
        
            }
        
        },
        
        
        /**
		 * @method hasFocus
		 * @description Returns a boolean indicating whether or not the button
		 *              has focus.
		 * @return {Boolean}
		 */
        hasFocus: function () {
        
            return (m_oFocusedButton == this);
        
        },
        
        
        /**
		 * @method isActive
		 * @description Returns a boolean indicating whether or not the button
		 *              is active.
		 * @return {Boolean}
		 */
        isActive: function () {
        
            return this.hasClass(this.CLASS_NAME_PREFIX + this.CSS_CLASS_NAME + "-active");
        
        },
        
        
        /**
		 * @method getMenu
		 * @description Returns a reference to the button's menu.
		 * @return {<a href="YAHOO.widget.Overlay.html"> YAHOO.widget.Overlay</a>|<a
		 *         href="YAHOO.widget.Menu.html">YAHOO.widget.Menu</a>}
		 */
        getMenu: function () {
        
            return this._menu;
        
        },
        
        
        /**
		 * @method getForm
		 * @description Returns a reference to the button's parent form.
		 * @return {<a href="http://www.w3.org/TR/2000/WD-DOM-Level-1-
		 *         20000929/level-one-html.html#ID-40002357">HTMLFormElement</a>}
		 */
        getForm: function () {
        
        	var oButton = this._button,
        		oForm;
        
            if (oButton) {
            
            	oForm = oButton.form;
            
            }
        
        	return oForm;
        
        },
        
        
        /**
		 * @method getHiddenFields
		 * @description Returns an <code>&#60;input&#62;</code> element or
		 *              array of form elements used to represent the button when
		 *              its parent form is submitted.
		 * @return {<a href="http://www.w3.org/TR/2000/WD-DOM-Level-1-20000929/
		 *         level-one-html.html#ID-6043025">HTMLInputElement</a>|Array}
		 */
        getHiddenFields: function () {
        
            return this._hiddenFields;
        
        },
        
        
        /**
		 * @method destroy
		 * @description Removes the button's element from its parent element and
		 *              removes all event handlers.
		 */
        destroy: function () {
        
        
            var oElement = this.get("element"),
                oMenu = this._menu,
				oLabel = this._label,
                oParentNode,
                aButtons;
        
            if (oMenu) {
        

                if (m_oOverlayManager && m_oOverlayManager.find(oMenu)) {

                    m_oOverlayManager.remove(oMenu);

                }
        
                oMenu.destroy();
        
            }
        
        
            Event.purgeElement(oElement);
            Event.purgeElement(this._button);
            Event.removeListener(document, "mouseup", this._onDocumentMouseUp);
            Event.removeListener(document, "keyup", this._onDocumentKeyUp);
            Event.removeListener(document, "mousedown", this._onDocumentMouseDown);


			if (oLabel) {

            	Event.removeListener(oLabel, "click", this._onLabelClick);
				
				oParentNode = oLabel.parentNode;
				oParentNode.removeChild(oLabel);
				
			}
        
        
            var oForm = this.getForm();
            
            if (oForm) {
        
                Event.removeListener(oForm, "reset", this._onFormReset);
                Event.removeListener(oForm, "submit", this._onFormSubmit);
        
            }


            this.unsubscribeAll();

			oParentNode = oElement.parentNode;

            if (oParentNode) {

                oParentNode.removeChild(oElement);
            
            }
        
        
            delete m_oButtons[this.get("id")];

			var sClass = (this.CLASS_NAME_PREFIX + this.CSS_CLASS_NAME);

            aButtons = Dom.getElementsByClassName(sClass, 
                                this.NODE_NAME, oForm); 

            if (Lang.isArray(aButtons) && aButtons.length === 0) {

                Event.removeListener(oForm, "keypress", 
                        YAHOO.widget.Button.onFormKeyPress);

            }

        
        },
        
        
        fireEvent: function (p_sType , p_aArgs) {
        
			var sType = arguments[0];
		
			// Disabled buttons should not respond to DOM events
		
			if (this.DOM_EVENTS[sType] && this.get("disabled")) {
		
				return false;
		
			}
		
			return YAHOO.widget.Button.superclass.fireEvent.apply(this, arguments);
        
        },
        
        
        /**
		 * @method toString
		 * @description Returns a string representing the button.
		 * @return {String}
		 */
        toString: function () {
        
            return ("Button " + this.get("id"));
        
        }
    
    });
    
    
    /**
	 * @method YAHOO.widget.Button.onFormKeyPress
	 * @description "keypress" event handler for the button's form.
	 * @param {Event}
	 *            p_oEvent Object representing the DOM event object passed back
	 *            by the event utility (YAHOO.util.Event).
	 */
    YAHOO.widget.Button.onFormKeyPress = function (p_oEvent) {
    
        var oTarget = Event.getTarget(p_oEvent),
            nCharCode = Event.getCharCode(p_oEvent),
            sNodeName = oTarget.nodeName && oTarget.nodeName.toUpperCase(),
            sType = oTarget.type,
    
            /*
			 * Boolean indicating if the form contains any enabled or disabled
			 * YUI submit buttons
			 */
    
            bFormContainsYUIButtons = false,
    
            oButton,
    
            oYUISubmitButton,   // The form's first, enabled YUI submit button
    
            /*
			 * The form's first, enabled HTML submit button that precedes any
			 * YUI submit button
			 */
    
            oPrecedingSubmitButton,
            
            oEvent; 
    
    
        function isSubmitButton(p_oElement) {
    
            var sId,
                oSrcElement;
    
            switch (p_oElement.nodeName.toUpperCase()) {
    
            case "INPUT":
            case "BUTTON":
            
                if (p_oElement.type == "submit" && !p_oElement.disabled) {
                    
                    if (!bFormContainsYUIButtons && !oPrecedingSubmitButton) {

                        oPrecedingSubmitButton = p_oElement;

                    }
                
                }

                break;
            

            default:
            
                sId = p_oElement.id;
    
                if (sId) {
    
                    oButton = m_oButtons[sId];
        
                    if (oButton) {

                        bFormContainsYUIButtons = true;
        
                        if (!oButton.get("disabled")) {

                            oSrcElement = oButton.get("srcelement");
    
                            if (!oYUISubmitButton && (oButton.get("type") == "submit" || 
                                (oSrcElement && oSrcElement.type == "submit"))) {

                                oYUISubmitButton = oButton;
                            
                            }
                        
                        }
                        
                    }
                
                }

                break;
    
            }
    
        }
    
    
        if (nCharCode == 13 && ((sNodeName == "INPUT" && (sType == "text" || 
            sType == "password" || sType == "checkbox" || sType == "radio" || 
            sType == "file")) || sNodeName == "SELECT")) {
    
            Dom.getElementsBy(isSubmitButton, "*", this);
    
    
            if (oPrecedingSubmitButton) {
    
                /*
				 * Need to set focus to the first enabled submit button to make
				 * sure that IE includes its name and value in the form's data
				 * set.
				 */
    
                oPrecedingSubmitButton.focus();
            
            }
            else if (!oPrecedingSubmitButton && oYUISubmitButton) {
    
				/*
				 * Need to call "preventDefault" to ensure that the form doesn't
				 * end up getting submitted twice.
				 */
    
    			Event.preventDefault(p_oEvent);


				if (UA.ie) {
				
					oYUISubmitButton.get("element").fireEvent("onclick");
				
				}
				else {

					oEvent = document.createEvent("HTMLEvents");
					oEvent.initEvent("click", true, true);
			

					if (UA.gecko < 1.9) {
					
						oYUISubmitButton.fireEvent("click", oEvent);
					
					}
					else {

						oYUISubmitButton.get("element").dispatchEvent(oEvent);
					
					}
  
                }

            }
            
        }
    
    };
    
    
    /**
	 * @method YAHOO.widget.Button.addHiddenFieldsToForm
	 * @description Searches the specified form and adds hidden fields for
	 *              instances of YAHOO.widget.Button that are of type "radio,"
	 *              "checkbox," "menu," and "split."
	 * @param {
	 *            <a
	 *            href="http://www.w3.org/TR/2000/WD-DOM-Level-1-20000929/level-
	 *            one-html.html#ID-40002357">HTMLFormElement</a>} p_oForm
	 *            Object reference for the form to search.
	 */
    YAHOO.widget.Button.addHiddenFieldsToForm = function (p_oForm) {
    
        var proto = YAHOO.widget.Button.prototype,
			aButtons = Dom.getElementsByClassName(
							(proto.CLASS_NAME_PREFIX + proto.CSS_CLASS_NAME), 
                            "*", 
                            p_oForm),
    
            nButtons = aButtons.length,
            oButton,
            sId,
            i;
    
        if (nButtons > 0) {
    
    
            for (i = 0; i < nButtons; i++) {
    
                sId = aButtons[i].id;
    
                if (sId) {
    
                    oButton = m_oButtons[sId];
        
                    if (oButton) {
           
                        oButton.createHiddenFields();
                        
                    }
                
                }
            
            }
    
        }
    
    };
    

    /**
	 * @method YAHOO.widget.Button.getButton
	 * @description Returns a button with the specified id.
	 * @param {String}
	 *            p_sId String specifying the id of the root node of the HTML
	 *            element representing the button to be retrieved.
	 * @return {YAHOO.widget.Button}
	 */
    YAHOO.widget.Button.getButton = function (p_sId) {

		return m_oButtons[p_sId];

    };
    
    
    // Events
    
    
    /**
	 * @event focus
	 * @description Fires when the menu item receives focus. Passes back a
	 *              single object representing the original DOM event object
	 *              passed back by the event utility (YAHOO.util.Event) when the
	 *              event was fired. See <a
	 *              href="YAHOO.util.Element.html#addListener">Element.addListener</a>
	 *              for more information on listening for this event.
	 * @type YAHOO.util.CustomEvent
	 */
    
    
    /**
	 * @event blur
	 * @description Fires when the menu item loses the input focus. Passes back
	 *              a single object representing the original DOM event object
	 *              passed back by the event utility (YAHOO.util.Event) when the
	 *              event was fired. See <a
	 *              href="YAHOO.util.Element.html#addListener">Element.addListener</a>
	 *              for more information on listening for this event.
	 * @type YAHOO.util.CustomEvent
	 */
    
    
    /**
	 * @event option
	 * @description Fires when the user invokes the button's option. Passes back
	 *              a single object representing the original DOM event (either
	 *              "mousedown" or "keydown") that caused the "option" event to
	 *              fire. See <a
	 *              href="YAHOO.util.Element.html#addListener">Element.addListener</a>
	 *              for more information on listening for this event.
	 * @type YAHOO.util.CustomEvent
	 */

})();
(function () {

    // Shorthard for utilities
    
    var Dom = YAHOO.util.Dom,
        Event = YAHOO.util.Event,
        Lang = YAHOO.lang,
        Button = YAHOO.widget.Button,  
    
        // Private collection of radio buttons
    
        m_oButtons = {};



    /**
	 * The ButtonGroup class creates a set of buttons that are mutually
	 * exclusive; checking one button in the set will uncheck all others in the
	 * button group.
	 * 
	 * @param {String}
	 *            p_oElement String specifying the id attribute of the
	 *            <code>&#60;div&#62;</code> element of the button group.
	 * @param {
	 *            <a href="http://www.w3.org/TR/2000/WD-DOM-Level-1-20000929/
	 *            level-one-html.html#ID-22445964">HTMLDivElement</a>}
	 *            p_oElement Object specifying the <code>&#60;div&#62;</code>
	 *            element of the button group.
	 * @param {Object}
	 *            p_oElement Object literal specifying a set of configuration
	 *            attributes used to create the button group.
	 * @param {Object}
	 *            p_oAttributes Optional. Object literal specifying a set of
	 *            configuration attributes used to create the button group.
	 * @namespace YAHOO.widget
	 * @class ButtonGroup
	 * @constructor
	 * @extends YAHOO.util.Element
	 */
    YAHOO.widget.ButtonGroup = function (p_oElement, p_oAttributes) {
    
        var fnSuperClass = YAHOO.widget.ButtonGroup.superclass.constructor,
            sNodeName,
            oElement,
            sId;
    
        if (arguments.length == 1 && !Lang.isString(p_oElement) && 
            !p_oElement.nodeName) {
    
            if (!p_oElement.id) {
    
                sId = Dom.generateId();
    
                p_oElement.id = sId;
    
    
            }
    
    
    
            fnSuperClass.call(this, (this._createGroupElement()), p_oElement);
    
        }
        else if (Lang.isString(p_oElement)) {
    
            oElement = Dom.get(p_oElement);
    
            if (oElement) {
            
                if (oElement.nodeName.toUpperCase() == this.NODE_NAME) {
    
            
                    fnSuperClass.call(this, oElement, p_oAttributes);
    
                }
    
            }
        
        }
        else {
    
            sNodeName = p_oElement.nodeName.toUpperCase();
    
            if (sNodeName && sNodeName == this.NODE_NAME) {
        
                if (!p_oElement.id) {
        
                    p_oElement.id = Dom.generateId();
        
        
                }
        
        
                fnSuperClass.call(this, p_oElement, p_oAttributes);
    
            }
    
        }
    
    };
    
    
    YAHOO.extend(YAHOO.widget.ButtonGroup, YAHOO.util.Element, {
    
    
        // Protected properties
        
        
        /**
		 * @property _buttons
		 * @description Array of buttons in the button group.
		 * @default null
		 * @protected
		 * @type Array
		 */
        _buttons: null,
        
        
        
        // Constants
        
        
        /**
		 * @property NODE_NAME
		 * @description The name of the tag to be used for the button group's
		 *              element.
		 * @default "DIV"
		 * @final
		 * @type String
		 */
        NODE_NAME: "DIV",


        /**
		 * @property CLASS_NAME_PREFIX
		 * @description Prefix used for all class names applied to a
		 *              ButtonGroup.
		 * @default "yui-"
		 * @final
		 * @type String
		 */
        CLASS_NAME_PREFIX: "yui-",
        
        
        /**
		 * @property CSS_CLASS_NAME
		 * @description String representing the CSS class(es) to be applied to
		 *              the button group's element.
		 * @default "buttongroup"
		 * @final
		 * @type String
		 */
        CSS_CLASS_NAME: "buttongroup",
    
    
    
        // Protected methods
        
        
        /**
		 * @method _createGroupElement
		 * @description Creates the button group's element.
		 * @protected
		 * @return {<a href="http://www.w3.org/TR/2000/WD-DOM-Level-1-20000929/
		 *         level-one-html.html#ID-22445964">HTMLDivElement</a>}
		 */
        _createGroupElement: function () {
        
            var oElement = document.createElement(this.NODE_NAME);
        
            return oElement;
        
        },
        
        
        
        // Protected attribute setter methods
        
        
        /**
		 * @method _setDisabled
		 * @description Sets the value of the button groups's "disabled"
		 *              attribute.
		 * @protected
		 * @param {Boolean}
		 *            p_bDisabled Boolean indicating the value for the button
		 *            group's "disabled" attribute.
		 */
        _setDisabled: function (p_bDisabled) {
        
            var nButtons = this.getCount(),
                i;
        
            if (nButtons > 0) {
        
                i = nButtons - 1;
                
                do {
        
                    this._buttons[i].set("disabled", p_bDisabled);
                
                }
                while (i--);
        
            }
        
        },
        
        
        
        // Protected event handlers
        
        
        /**
		 * @method _onKeyDown
		 * @description "keydown" event handler for the button group.
		 * @protected
		 * @param {Event}
		 *            p_oEvent Object representing the DOM event object passed
		 *            back by the event utility (YAHOO.util.Event).
		 */
        _onKeyDown: function (p_oEvent) {
        
            var oTarget = Event.getTarget(p_oEvent),
                nCharCode = Event.getCharCode(p_oEvent),
                sId = oTarget.parentNode.parentNode.id,
                oButton = m_oButtons[sId],
                nIndex = -1;
        
        
            if (nCharCode == 37 || nCharCode == 38) {
        
                nIndex = (oButton.index === 0) ? 
                            (this._buttons.length - 1) : (oButton.index - 1);
            
            }
            else if (nCharCode == 39 || nCharCode == 40) {
        
                nIndex = (oButton.index === (this._buttons.length - 1)) ? 
                            0 : (oButton.index + 1);
        
            }
        
        
            if (nIndex > -1) {
        
                this.check(nIndex);
                this.getButton(nIndex).focus();
            
            }        
        
        },
        
        
        /**
		 * @method _onAppendTo
		 * @description "appendTo" event handler for the button group.
		 * @protected
		 * @param {Event}
		 *            p_oEvent Object representing the event that was fired.
		 */
        _onAppendTo: function (p_oEvent) {
        
            var aButtons = this._buttons,
                nButtons = aButtons.length,
                i;
        
            for (i = 0; i < nButtons; i++) {
        
                aButtons[i].appendTo(this.get("element"));
        
            }
        
        },
        
        
        /**
		 * @method _onButtonCheckedChange
		 * @description "checkedChange" event handler for each button in the
		 *              button group.
		 * @protected
		 * @param {Event}
		 *            p_oEvent Object representing the event that was fired.
		 * @param {
		 *            <a href="YAHOO.widget.Button.html">YAHOO.widget.Button</a>}
		 *            p_oButton Object representing the button that fired the
		 *            event.
		 */
        _onButtonCheckedChange: function (p_oEvent, p_oButton) {
        
            var bChecked = p_oEvent.newValue,
                oCheckedButton = this.get("checkedButton");
        
            if (bChecked && oCheckedButton != p_oButton) {
        
                if (oCheckedButton) {
        
                    oCheckedButton.set("checked", false, true);
        
                }
        
                this.set("checkedButton", p_oButton);
                this.set("value", p_oButton.get("value"));
        
            }
            else if (oCheckedButton && !oCheckedButton.set("checked")) {
        
                oCheckedButton.set("checked", true, true);
        
            }
           
        },
        
        
        
        // Public methods
        
        
        /**
		 * @method init
		 * @description The ButtonGroup class's initialization method.
		 * @param {String}
		 *            p_oElement String specifying the id attribute of the
		 *            <code>&#60;div&#62;</code> element of the button group.
		 * @param {
		 *            <a
		 *            href="http://www.w3.org/TR/2000/WD-DOM-Level-1-20000929/
		 *            level-one-html.html#ID-22445964">HTMLDivElement</a>}
		 *            p_oElement Object specifying the
		 *            <code>&#60;div&#62;</code> element of the button group.
		 * @param {Object}
		 *            p_oElement Object literal specifying a set of
		 *            configuration attributes used to create the button group.
		 * @param {Object}
		 *            p_oAttributes Optional. Object literal specifying a set of
		 *            configuration attributes used to create the button group.
		 */
        init: function (p_oElement, p_oAttributes) {
        
            this._buttons = [];
        
            YAHOO.widget.ButtonGroup.superclass.init.call(this, p_oElement, 
                    p_oAttributes);
        
            this.addClass(this.CLASS_NAME_PREFIX + this.CSS_CLASS_NAME);

        
            var sClass = (YAHOO.widget.Button.prototype.CLASS_NAME_PREFIX + "radio-button"),
				aButtons = this.getElementsByClassName(sClass);

        
        
            if (aButtons.length > 0) {
        
        
                this.addButtons(aButtons);
        
            }
        
        
        
            function isRadioButton(p_oElement) {
        
                return (p_oElement.type == "radio");
        
            }
        
            aButtons = 
                Dom.getElementsBy(isRadioButton, "input", this.get("element"));
        
        
            if (aButtons.length > 0) {
        
        
                this.addButtons(aButtons);
        
            }
        
            this.on("keydown", this._onKeyDown);
            this.on("appendTo", this._onAppendTo);
        

            var oContainer = this.get("container");

            if (oContainer) {
        
                if (Lang.isString(oContainer)) {
        
                    Event.onContentReady(oContainer, function () {
        
                        this.appendTo(oContainer);            
                    
                    }, null, this);
        
                }
                else {
        
                    this.appendTo(oContainer);
        
                }
        
            }
        
        
        
        },
        
        
        /**
		 * @method initAttributes
		 * @description Initializes all of the configuration attributes used to
		 *              create the button group.
		 * @param {Object}
		 *            p_oAttributes Object literal specifying a set of
		 *            configuration attributes used to create the button group.
		 */
        initAttributes: function (p_oAttributes) {
        
            var oAttributes = p_oAttributes || {};
        
            YAHOO.widget.ButtonGroup.superclass.initAttributes.call(
                this, oAttributes);
        
        
            /**
			 * @attribute name
			 * @description String specifying the name for the button group.
			 *              This name will be applied to each button in the
			 *              button group.
			 * @default null
			 * @type String
			 */
            this.setAttributeConfig("name", {
        
                value: oAttributes.name,
                validator: Lang.isString
        
            });
        
        
            /**
			 * @attribute disabled
			 * @description Boolean indicating if the button group should be
			 *              disabled. Disabling the button group will disable
			 *              each button in the button group. Disabled buttons
			 *              are dimmed and will not respond to user input or
			 *              fire events.
			 * @default false
			 * @type Boolean
			 */
            this.setAttributeConfig("disabled", {
        
                value: (oAttributes.disabled || false),
                validator: Lang.isBoolean,
                method: this._setDisabled
        
            });
        
        
            /**
			 * @attribute value
			 * @description Object specifying the value for the button group.
			 * @default null
			 * @type Object
			 */
            this.setAttributeConfig("value", {
        
                value: oAttributes.value
        
            });
        
        
            /**
			 * @attribute container
			 * @description HTML element reference or string specifying the id
			 *              attribute of the HTML element that the button
			 *              group's markup should be rendered into.
			 * @type <a href="http://www.w3.org/TR/2000/WD-DOM-Level-1-20000929/
			 *       level-one-html.html#ID-58190037">HTMLElement</a>|String
			 * @default null
			 * @writeonce
			 */
            this.setAttributeConfig("container", {
        
                value: oAttributes.container,
                writeOnce: true
        
            });
        
        
            /**
			 * @attribute checkedButton
			 * @description Reference for the button in the button group that is
			 *              checked.
			 * @type {<a href="YAHOO.widget.Button.html">YAHOO.widget.Button</a>}
			 * @default null
			 */
            this.setAttributeConfig("checkedButton", {
        
                value: null
        
            });
        
        },
        
        
        /**
		 * @method addButton
		 * @description Adds the button to the button group.
		 * @param {
		 *            <a href="YAHOO.widget.Button.html">YAHOO.widget.Button</a>}
		 *            p_oButton Object reference for the <a
		 *            href="YAHOO.widget.Button.html"> YAHOO.widget.Button</a>
		 *            instance to be added to the button group.
		 * @param {String}
		 *            p_oButton String specifying the id attribute of the
		 *            <code>&#60;input&#62;</code> or
		 *            <code>&#60;span&#62;</code> element to be used to create
		 *            the button to be added to the button group.
		 * @param {
		 *            <a
		 *            href="http://www.w3.org/TR/2000/WD-DOM-Level-1-20000929/
		 *            level-one-html.html#ID-6043025">HTMLInputElement</a>|<a
		 *            href="
		 *            http://www.w3.org/TR/2000/WD-DOM-Level-1-20000929/level-one-html.html#
		 *            ID-33759296">HTMLElement</a>} p_oButton Object reference
		 *            for the <code>&#60;input&#62;</code> or
		 *            <code>&#60;span&#62;</code> element to be used to create
		 *            the button to be added to the button group.
		 * @param {Object}
		 *            p_oButton Object literal specifying a set of <a
		 *            href="YAHOO.widget.Button.html">YAHOO.widget.Button</a>
		 *            configuration attributes used to configure the button to
		 *            be added to the button group.
		 * @return {<a href="YAHOO.widget.Button.html">YAHOO.widget.Button</a>}
		 */
        addButton: function (p_oButton) {
        
            var oButton,
                oButtonElement,
                oGroupElement,
                nIndex,
                sButtonName,
                sGroupName;
        
        
            if (p_oButton instanceof Button && 
                p_oButton.get("type") == "radio") {
        
                oButton = p_oButton;
        
            }
            else if (!Lang.isString(p_oButton) && !p_oButton.nodeName) {
        
                p_oButton.type = "radio";
        
                oButton = new Button(p_oButton);

            }
            else {
        
                oButton = new Button(p_oButton, { type: "radio" });
        
            }
        
        
            if (oButton) {
        
                nIndex = this._buttons.length;
                sButtonName = oButton.get("name");
                sGroupName = this.get("name");
        
                oButton.index = nIndex;
        
                this._buttons[nIndex] = oButton;
                m_oButtons[oButton.get("id")] = oButton;
        
        
                if (sButtonName != sGroupName) {
        
                    oButton.set("name", sGroupName);
                
                }
        
        
                if (this.get("disabled")) {
        
                    oButton.set("disabled", true);
        
                }
        
        
                if (oButton.get("checked")) {
        
                    this.set("checkedButton", oButton);
        
                }

                
                oButtonElement = oButton.get("element");
                oGroupElement = this.get("element");
                
                if (oButtonElement.parentNode != oGroupElement) {
                
                    oGroupElement.appendChild(oButtonElement);
                
                }
        
                
                oButton.on("checkedChange", 
                    this._onButtonCheckedChange, oButton, this);
        
        
            }

			return oButton;
        
        },
        
        
        /**
		 * @method addButtons
		 * @description Adds the array of buttons to the button group.
		 * @param {Array}
		 *            p_aButtons Array of <a href="YAHOO.widget.Button.html">
		 *            YAHOO.widget.Button</a> instances to be added to the
		 *            button group.
		 * @param {Array}
		 *            p_aButtons Array of strings specifying the id attribute of
		 *            the <code>&#60;input&#62;</code> or <code>&#60;span&#62;
        * </code>
		 *            elements to be used to create the buttons to be added to
		 *            the button group.
		 * @param {Array}
		 *            p_aButtons Array of object references for the
		 *            <code>&#60;input&#62;</code> or
		 *            <code>&#60;span&#62;</code> elements to be used to
		 *            create the buttons to be added to the button group.
		 * @param {Array}
		 *            p_aButtons Array of object literals, each containing a set
		 *            of <a href="YAHOO.widget.Button.html">YAHOO.widget.Button</a>
		 *            configuration attributes used to configure each button to
		 *            be added to the button group.
		 * @return {Array}
		 */
        addButtons: function (p_aButtons) {
    
            var nButtons,
                oButton,
                aButtons,
                i;
        
            if (Lang.isArray(p_aButtons)) {
            
                nButtons = p_aButtons.length;
                aButtons = [];
        
                if (nButtons > 0) {
        
                    for (i = 0; i < nButtons; i++) {
        
                        oButton = this.addButton(p_aButtons[i]);
                        
                        if (oButton) {
        
                            aButtons[aButtons.length] = oButton;
        
                        }
                    
                    }
                
                }
        
            }

			return aButtons;
        
        },
        
        
        /**
		 * @method removeButton
		 * @description Removes the button at the specified index from the
		 *              button group.
		 * @param {Number}
		 *            p_nIndex Number specifying the index of the button to be
		 *            removed from the button group.
		 */
        removeButton: function (p_nIndex) {
        
            var oButton = this.getButton(p_nIndex),
                nButtons,
                i;
            
            if (oButton) {
        
        
                this._buttons.splice(p_nIndex, 1);
                delete m_oButtons[oButton.get("id")];
        
                oButton.removeListener("checkedChange", 
                    this._onButtonCheckedChange);

                oButton.destroy();
        
        
                nButtons = this._buttons.length;
                
                if (nButtons > 0) {
        
                    i = this._buttons.length - 1;
                    
                    do {
        
                        this._buttons[i].index = i;
        
                    }
                    while (i--);
                
                }
        
        
            }
        
        },
        
        
        /**
		 * @method getButton
		 * @description Returns the button at the specified index.
		 * @param {Number}
		 *            p_nIndex The index of the button to retrieve from the
		 *            button group.
		 * @return {<a href="YAHOO.widget.Button.html">YAHOO.widget.Button</a>}
		 */
        getButton: function (p_nIndex) {
        
            return this._buttons[p_nIndex];
        
        },
        
        
        /**
		 * @method getButtons
		 * @description Returns an array of the buttons in the button group.
		 * @return {Array}
		 */
        getButtons: function () {
        
            return this._buttons;
        
        },
        
        
        /**
		 * @method getCount
		 * @description Returns the number of buttons in the button group.
		 * @return {Number}
		 */
        getCount: function () {
        
            return this._buttons.length;
        
        },
        
        
        /**
		 * @method focus
		 * @description Sets focus to the button at the specified index.
		 * @param {Number}
		 *            p_nIndex Number indicating the index of the button to
		 *            focus.
		 */
        focus: function (p_nIndex) {
        
            var oButton,
                nButtons,
                i;
        
            if (Lang.isNumber(p_nIndex)) {
        
                oButton = this._buttons[p_nIndex];
                
                if (oButton) {
        
                    oButton.focus();
        
                }
            
            }
            else {
        
                nButtons = this.getCount();
        
                for (i = 0; i < nButtons; i++) {
        
                    oButton = this._buttons[i];
        
                    if (!oButton.get("disabled")) {
        
                        oButton.focus();
                        break;
        
                    }
        
                }
        
            }
        
        },
        
        
        /**
		 * @method check
		 * @description Checks the button at the specified index.
		 * @param {Number}
		 *            p_nIndex Number indicating the index of the button to
		 *            check.
		 */
        check: function (p_nIndex) {
        
            var oButton = this.getButton(p_nIndex);
            
            if (oButton) {
        
                oButton.set("checked", true);
            
            }
        
        },
        
        
        /**
		 * @method destroy
		 * @description Removes the button group's element from its parent
		 *              element and removes all event handlers.
		 */
        destroy: function () {
        
        
            var nButtons = this._buttons.length,
                oElement = this.get("element"),
                oParentNode = oElement.parentNode,
                i;
            
            if (nButtons > 0) {
        
                i = this._buttons.length - 1;
        
                do {
        
                    this._buttons[i].destroy();
        
                }
                while (i--);
            
            }
        
        
            Event.purgeElement(oElement);
            
        
            oParentNode.removeChild(oElement);
        
        },
        
        
        /**
		 * @method toString
		 * @description Returns a string representing the button group.
		 * @return {String}
		 */
        toString: function () {
        
            return ("ButtonGroup " + this.get("id"));
        
        }
    
    });

})();
YAHOO.register("button", YAHOO.widget.Button, {version: "2.9.0", build: "2800"});
/*
 * Copyright (c) 2011, Yahoo! Inc. All rights reserved. Code licensed under the
 * BSD License: http://developer.yahoo.com/yui/license.html version: 2.9.0
 */
/**
 * @description
 * <p>
 * Makes an element resizable
 * </p>
 * @namespace YAHOO.util
 * @requires yahoo, dom, dragdrop, element, event
 * @optional animation
 * @module resize
 */
(function() {
var D = YAHOO.util.Dom,
    Event = YAHOO.util.Event,
    Lang = YAHOO.lang;

    /**
	 * @constructor
	 * @class Resize
	 * @extends YAHOO.util.Element
	 * @description
	 *          <p>
	 *          Makes an element resizable
	 *          </p>
	 * @param {String/HTMLElement}
	 *            el The element to make resizable.
	 * @param {Object}
	 *            attrs Object liternal containing configuration parameters.
	 */

    var Resize = function(el, config) {
        var oConfig = {
            element: el,
            attributes: config || {}
        };

        Resize.superclass.constructor.call(this, oConfig.element, oConfig.attributes);    
    };

    /**
	 * @private
	 * @static
	 * @property _instances
	 * @description Internal hash table for all resize instances
	 * @type Object
	 */ 
    Resize._instances = {};
    /**
	 * @static
	 * @method getResizeById
	 * @description Get's a resize object by the HTML id of the element
	 *              associated with the Resize object.
	 * @return {Object} The Resize Object
	 */ 
    Resize.getResizeById = function(id) {
        if (Resize._instances[id]) {
            return Resize._instances[id];
        }
        return false;
    };

    YAHOO.extend(Resize, YAHOO.util.Element, {
        /**
		 * @private
		 * @property CSS_RESIZE
		 * @description Base CSS class name
		 * @type String
		 */ 
        CSS_RESIZE: 'yui-resize',
        /**
		 * @private
		 * @property CSS_DRAG
		 * @description Class name added when dragging is enabled
		 * @type String
		 */ 
        CSS_DRAG: 'yui-draggable',
        /**
		 * @private
		 * @property CSS_HOVER
		 * @description Class name used for hover only handles
		 * @type String
		 */ 
        CSS_HOVER: 'yui-resize-hover',
        /**
		 * @private
		 * @property CSS_PROXY
		 * @description Class name given to the proxy element
		 * @type String
		 */ 
        CSS_PROXY: 'yui-resize-proxy',
        /**
		 * @private
		 * @property CSS_WRAP
		 * @description Class name given to the wrap element
		 * @type String
		 */ 
        CSS_WRAP: 'yui-resize-wrap',
        /**
		 * @private
		 * @property CSS_KNOB
		 * @description Class name used to make the knob style handles
		 * @type String
		 */ 
        CSS_KNOB: 'yui-resize-knob',
        /**
		 * @private
		 * @property CSS_HIDDEN
		 * @description Class name given to the wrap element to make all handles
		 *              hidden
		 * @type String
		 */ 
        CSS_HIDDEN: 'yui-resize-hidden',
        /**
		 * @private
		 * @property CSS_HANDLE
		 * @description Class name given to all handles, used as a base for
		 *              single handle names as well.. Handle "t" will get
		 *              this.CSS_HANDLE + '-t' as well as this.CSS_HANDLE
		 * @type String
		 */ 
        CSS_HANDLE: 'yui-resize-handle',
        /**
		 * @private
		 * @property CSS_STATUS
		 * @description Class name given to the status element
		 * @type String
		 */ 
        CSS_STATUS: 'yui-resize-status',
        /**
		 * @private
		 * @property CSS_GHOST
		 * @description Class name given to the wrap element when the ghost
		 *              property is active
		 * @type String
		 */ 
        CSS_GHOST: 'yui-resize-ghost',
        /**
		 * @private
		 * @property CSS_RESIZING
		 * @description Class name given to the wrap element when a resize
		 *              action is taking place.
		 * @type String
		 */ 
        CSS_RESIZING: 'yui-resize-resizing',
        /**
		 * @private
		 * @property _resizeEvent
		 * @description The mouse event used to resize with
		 * @type Event
		 */ 
        _resizeEvent: null,
        /**
		 * @private
		 * @property dd
		 * @description The <a
		 *              href="YAHOO.util.DragDrop.html">YAHOO.util.DragDrop</a>
		 *              instance used if draggable is true
		 * @type Object
		 */ 
        dd: null,
        /**
		 * @private
		 * @property browser
		 * @description A copy of the YAHOO.env.ua property
		 * @type Object
		 */
        browser: YAHOO.env.ua,
        /**
		 * @private
		 * @property _locked
		 * @description A flag to show if the resize is locked
		 * @type Boolean
		 */
        _locked: null,
        /**
		 * @private
		 * @property _positioned
		 * @description A flag to show if the element is absolutely positioned
		 * @type Boolean
		 */
        _positioned: null,
        /**
		 * @private
		 * @property _dds
		 * @description An Object containing references to all of the <a
		 *              href="YAHOO.util.DragDrop.html">YAHOO.util.DragDrop</a>
		 *              instances used for the resize handles
		 * @type Object
		 */
        _dds: null,
        /**
		 * @private
		 * @property _wrap
		 * @description The HTML reference of the element wrapper
		 * @type HTMLElement
		 */
        _wrap: null,
        /**
		 * @private
		 * @property _proxy
		 * @description The HTML reference of the element proxy
		 * @type HTMLElement
		 */
        _proxy: null,
        /**
		 * @private
		 * @property _handles
		 * @description An object containing references to all of the resize
		 *              handles.
		 * @type Object
		 */
        _handles: null,
        /**
		 * @private
		 * @property _currentHandle
		 * @description The string identifier of the currently active handle.
		 *              e.g. 'r', 'br', 'tl'
		 * @type String
		 */
        _currentHandle: null,
        /**
		 * @private
		 * @property _currentDD
		 * @description A link to the currently active DD object
		 * @type Object
		 */
        _currentDD: null,
        /**
		 * @private
		 * @property _cache
		 * @description An lookup table containing key information for the
		 *              element being resized. e.g. height, width, x position, y
		 *              position, etc..
		 * @type Object
		 */
        _cache: null,
        /**
		 * @private
		 * @property _active
		 * @description Flag to show if the resize is active. Used for events.
		 * @type Boolean
		 */
        _active: null,
        /**
		 * @private
		 * @method _createProxy
		 * @description Creates the proxy element if the proxy config is true
		 */
        _createProxy: function() {
            if (this.get('proxy')) {
                this._proxy = document.createElement('div');
                this._proxy.className = this.CSS_PROXY;
                this._proxy.style.height = this.get('element').clientHeight + 'px';
                this._proxy.style.width = this.get('element').clientWidth + 'px';
                this._wrap.parentNode.appendChild(this._proxy);
            } else {
                this.set('animate', false);
            }
        },
        /**
		 * @private
		 * @method _createWrap
		 * @description Creates the wrap element if the wrap config is true. It
		 *              will auto wrap the following element types: img,
		 *              textarea, input, iframe, select
		 */
        _createWrap: function() {
            this._positioned = false;
            // Force wrap for elements that can't have children
            if (this.get('wrap') === false) {
                switch (this.get('element').tagName.toLowerCase()) {
                    case 'img':
                    case 'textarea':
                    case 'input':
                    case 'iframe':
                    case 'select':
                        this.set('wrap', true);
                        break;
                }
            }
            if (this.get('wrap') === true) {
                this._wrap = document.createElement('div');
                this._wrap.id = this.get('element').id + '_wrap';
                this._wrap.className = this.CSS_WRAP;
                if (this.get('element').tagName.toLowerCase() == 'textarea') {
                    D.addClass(this._wrap, 'yui-resize-textarea');
                }
                D.setStyle(this._wrap, 'width', this.get('width') + 'px');
                D.setStyle(this._wrap, 'height', this.get('height') + 'px');
                D.setStyle(this._wrap, 'z-index', this.getStyle('z-index'));
                this.setStyle('z-index', 0);
                var pos = D.getStyle(this.get('element'), 'position');
                D.setStyle(this._wrap, 'position', ((pos == 'static') ? 'relative' : pos));
                D.setStyle(this._wrap, 'top', D.getStyle(this.get('element'), 'top'));
                D.setStyle(this._wrap, 'left', D.getStyle(this.get('element'), 'left'));
                if (D.getStyle(this.get('element'), 'position') == 'absolute') {
                    this._positioned = true;
                    D.setStyle(this.get('element'), 'position', 'relative');
                    D.setStyle(this.get('element'), 'top', '0');
                    D.setStyle(this.get('element'), 'left', '0');
                }
                var par = this.get('element').parentNode;
                par.replaceChild(this._wrap, this.get('element'));
                this._wrap.appendChild(this.get('element'));
            } else {
                this._wrap = this.get('element');
                if (D.getStyle(this._wrap, 'position') == 'absolute') {
                    this._positioned = true;
                }
            }
            if (this.get('draggable')) {
                this._setupDragDrop();
            }
            if (this.get('hover')) {
                D.addClass(this._wrap, this.CSS_HOVER);
            }
            if (this.get('knobHandles')) {
                D.addClass(this._wrap, this.CSS_KNOB);
            }
            if (this.get('hiddenHandles')) {
                D.addClass(this._wrap, this.CSS_HIDDEN);
            }
            D.addClass(this._wrap, this.CSS_RESIZE);
        },
        /**
		 * @private
		 * @method _setupDragDrop
		 * @description Setup the <a
		 *              href="YAHOO.util.DragDrop.html">YAHOO.util.DragDrop</a>
		 *              instance on the element
		 */
        _setupDragDrop: function() {
            D.addClass(this._wrap, this.CSS_DRAG);
            this.dd = new YAHOO.util.DD(this._wrap, this.get('id') + '-resize', { dragOnly: true, useShim: this.get('useShim') });
            this.dd.on('dragEvent', function() {
                this.fireEvent('dragEvent', arguments);
            }, this, true);
        },
        /**
		 * @private
		 * @method _createHandles
		 * @description Creates the handles as specified in the config
		 */
        _createHandles: function() {
            this._handles = {};
            this._dds = {};
            var h = this.get('handles');
            for (var i = 0; i < h.length; i++) {
                this._handles[h[i]] = document.createElement('div');
                this._handles[h[i]].id = D.generateId(this._handles[h[i]]);
                this._handles[h[i]].className = this.CSS_HANDLE + ' ' + this.CSS_HANDLE + '-' + h[i];
                var k = document.createElement('div');
                k.className = this.CSS_HANDLE + '-inner-' + h[i];
                this._handles[h[i]].appendChild(k);
                this._wrap.appendChild(this._handles[h[i]]);
                Event.on(this._handles[h[i]], 'mouseover', this._handleMouseOver, this, true);
                Event.on(this._handles[h[i]], 'mouseout', this._handleMouseOut, this, true);
                this._dds[h[i]] = new YAHOO.util.DragDrop(this._handles[h[i]], this.get('id') + '-handle-' + h, { useShim: this.get('useShim') });
                this._dds[h[i]].setPadding(15, 15, 15, 15);
                this._dds[h[i]].on('startDragEvent', this._handleStartDrag, this._dds[h[i]], this);
                this._dds[h[i]].on('mouseDownEvent', this._handleMouseDown, this._dds[h[i]], this);
            }
            this._status = document.createElement('span');
            this._status.className = this.CSS_STATUS;
            document.body.insertBefore(this._status, document.body.firstChild);
        },
        /**
		 * @private
		 * @method _ieSelectFix
		 * @description The function we use as the onselectstart handler when we
		 *              start a drag in Internet Explorer
		 */
        _ieSelectFix: function() {
            return false;
        },
        /**
		 * @private
		 * @property _ieSelectBack
		 * @description We will hold a copy of the current "onselectstart"
		 *              method on this property, and reset it after we are done
		 *              using it.
		 */
        _ieSelectBack: null,
        /**
		 * @private
		 * @method _setAutoRatio
		 * @param {Event}
		 *            ev A mouse event.
		 * @description This method checks to see if the "autoRatio" config is
		 *              set. If it is, we will check to see if the "Shift Key"
		 *              is pressed. If so, we will set the config ratio to true.
		 */
        _setAutoRatio: function(ev) {
            if (this.get('autoRatio')) {
                if (ev && ev.shiftKey) {
                    // Shift Pressed
                    this.set('ratio', true);
                } else {
                    this.set('ratio', this._configs.ratio._initialConfig.value);
                }
            }
        },
        /**
		 * @private
		 * @method _handleMouseDown
		 * @param {Event}
		 *            ev A mouse event.
		 * @description This method preps the autoRatio on MouseDown.
		 */
        _handleMouseDown: function(ev) {
            if (this._locked) {
                return false;
            }
            if (D.getStyle(this._wrap, 'position') == 'absolute') {
                this._positioned = true;
            }
            if (ev) {
                this._setAutoRatio(ev);
            }
            if (this.browser.ie) {
                this._ieSelectBack = document.body.onselectstart;
                document.body.onselectstart = this._ieSelectFix;
            }
        },
        /**
		 * @private
		 * @method _handleMouseOver
		 * @param {Event}
		 *            ev A mouse event.
		 * @description Adds CSS class names to the handles
		 */
        _handleMouseOver: function(ev) {
            if (this._locked) {
                return false;
            }
            D.removeClass(this._wrap, this.CSS_RESIZE);

            if (this.get('hover')) {
                D.removeClass(this._wrap, this.CSS_HOVER);
            }
            var tar = Event.getTarget(ev);
            if (!D.hasClass(tar, this.CSS_HANDLE)) {
                tar = tar.parentNode;
            }
            if (D.hasClass(tar, this.CSS_HANDLE) && !this._active) {
                D.addClass(tar, this.CSS_HANDLE + '-active');
                for (var i in this._handles) {
                    if (Lang.hasOwnProperty(this._handles, i)) {
                        if (this._handles[i] == tar) {
                            D.addClass(tar, this.CSS_HANDLE + '-' + i + '-active');
                            break;
                        }
                    }
                }
            }

            D.addClass(this._wrap, this.CSS_RESIZE);
        },
        /**
		 * @private
		 * @method _handleMouseOut
		 * @param {Event}
		 *            ev A mouse event.
		 * @description Removes CSS class names to the handles
		 */
        _handleMouseOut: function(ev) {
            D.removeClass(this._wrap, this.CSS_RESIZE);
            if (this.get('hover') && !this._active) {
                D.addClass(this._wrap, this.CSS_HOVER);
            }
            var tar = Event.getTarget(ev);
            if (!D.hasClass(tar, this.CSS_HANDLE)) {
                tar = tar.parentNode;
            }
            if (D.hasClass(tar, this.CSS_HANDLE) && !this._active) {
                D.removeClass(tar, this.CSS_HANDLE + '-active');
                for (var i in this._handles) {
                    if (Lang.hasOwnProperty(this._handles, i)) {
                        if (this._handles[i] == tar) {
                            D.removeClass(tar, this.CSS_HANDLE + '-' + i + '-active');
                            break;
                        }
                    }
                }
            }
            D.addClass(this._wrap, this.CSS_RESIZE);
        },
        /**
		 * @private
		 * @method _handleStartDrag
		 * @param {Object}
		 *            args The args passed from the CustomEvent.
		 * @param {Object}
		 *            dd The <a
		 *            href="YAHOO.util.DragDrop.html">YAHOO.util.DragDrop</a>
		 *            object we are working with.
		 * @description Resizes the proxy, sets up the <a
		 *              href="YAHOO.util.DragDrop.html">YAHOO.util.DragDrop</a>
		 *              handlers, updates the status div and preps the cache
		 */
        _handleStartDrag: function(args, dd) {
            var tar = dd.getDragEl();
            if (D.hasClass(tar, this.CSS_HANDLE)) {
                if (D.getStyle(this._wrap, 'position') == 'absolute') {
                    this._positioned = true;
                }
                this._active = true;
                this._currentDD = dd;
                if (this._proxy) {
                    this._proxy.style.visibility = 'visible';
                    this._proxy.style.zIndex = '1000';
                    this._proxy.style.height = this.get('element').clientHeight + 'px';
                    this._proxy.style.width = this.get('element').clientWidth + 'px';
                }

                for (var i in this._handles) {
                    if (Lang.hasOwnProperty(this._handles, i)) {
                        if (this._handles[i] == tar) {
                            this._currentHandle = i;
                            var handle = '_handle_for_' + i;
                            D.addClass(tar, this.CSS_HANDLE + '-' + i + '-active');
                            dd.on('dragEvent', this[handle], this, true);
                            dd.on('mouseUpEvent', this._handleMouseUp, this, true);
                            break;
                        }
                    }
                }


                D.addClass(tar, this.CSS_HANDLE + '-active');

                if (this.get('proxy')) {
                    var xy = D.getXY(this.get('element'));
                    D.setXY(this._proxy, xy);
                    if (this.get('ghost')) {
                        this.addClass(this.CSS_GHOST);
                    }
                }
                D.addClass(this._wrap, this.CSS_RESIZING);
                this._setCache();
                this._updateStatus(this._cache.height, this._cache.width, this._cache.top, this._cache.left);
                this.fireEvent('startResize', { type: 'startresize', target: this});
            }
        },
        /**
		 * @private
		 * @method _setCache
		 * @description Sets up the this._cache hash table.
		 */
        _setCache: function() {
            this._cache.xy = D.getXY(this._wrap);
            D.setXY(this._wrap, this._cache.xy);
            this._cache.height = this.get('clientHeight');
            this._cache.width = this.get('clientWidth');
            this._cache.start.height = this._cache.height;
            this._cache.start.width = this._cache.width;
            this._cache.start.top = this._cache.xy[1];
            this._cache.start.left = this._cache.xy[0];
            this._cache.top = this._cache.xy[1];
            this._cache.left = this._cache.xy[0];
            this.set('height', this._cache.height, true);
            this.set('width', this._cache.width, true);
        },
        /**
		 * @private
		 * @method _handleMouseUp
		 * @param {Event}
		 *            ev A mouse event.
		 * @description Cleans up listeners, hides proxy element and removes
		 *              class names.
		 */
        _handleMouseUp: function(ev) {
            this._active = false;

            var handle = '_handle_for_' + this._currentHandle;
            this._currentDD.unsubscribe('dragEvent', this[handle], this, true);
            this._currentDD.unsubscribe('mouseUpEvent', this._handleMouseUp, this, true);

            if (this._proxy) {
                this._proxy.style.visibility = 'hidden';
                this._proxy.style.zIndex = '-1';
                if (this.get('setSize')) {
                    this.resize(ev, this._cache.height, this._cache.width, this._cache.top, this._cache.left, true);
                } else {
                    this.fireEvent('resize', { ev: 'resize', target: this, height: this._cache.height, width: this._cache.width, top: this._cache.top, left: this._cache.left });
                }

                if (this.get('ghost')) {
                    this.removeClass(this.CSS_GHOST);
                }
            }

            if (this.get('hover')) {
                D.addClass(this._wrap, this.CSS_HOVER);
            }
            if (this._status) {
                D.setStyle(this._status, 'display', 'none');
            }
            if (this.browser.ie) {
                document.body.onselectstart = this._ieSelectBack;
            }

            if (this.browser.ie) {
                D.removeClass(this._wrap, this.CSS_RESIZE);
            }

            for (var i in this._handles) {
                if (Lang.hasOwnProperty(this._handles, i)) {
                    D.removeClass(this._handles[i], this.CSS_HANDLE + '-active');
                }
            }
            if (this.get('hover') && !this._active) {
                D.addClass(this._wrap, this.CSS_HOVER);
            }
            D.removeClass(this._wrap, this.CSS_RESIZING);

            D.removeClass(this._handles[this._currentHandle], this.CSS_HANDLE + '-' + this._currentHandle + '-active');
            D.removeClass(this._handles[this._currentHandle], this.CSS_HANDLE + '-active');

            if (this.browser.ie) {
                D.addClass(this._wrap, this.CSS_RESIZE);
            }

            this._resizeEvent = null;
            this._currentHandle = null;
            
            if (!this.get('animate')) {
                this.set('height', this._cache.height, true);
                this.set('width', this._cache.width, true);
            }

            this.fireEvent('endResize', { ev: 'endResize', target: this, height: this._cache.height, width: this._cache.width, top: this._cache.top, left: this._cache.left });
        },
        /**
		 * @private
		 * @method _setRatio
		 * @param {Number}
		 *            h The height offset.
		 * @param {Number}
		 *            w The with offset.
		 * @param {Number}
		 *            t The top offset.
		 * @param {Number}
		 *            l The left offset.
		 * @description Using the Height, Width, Top & Left, it recalcuates them
		 *              based on the original element size.
		 * @return {Array} The new Height, Width, Top & Left settings
		 */
        _setRatio: function(h, w, t, l) {
            var oh = h, ow = w;
            if (this.get('ratio')) {
                var orgH = this._cache.height,
                    orgW = this._cache.width,
                    nh = parseInt(this.get('height'), 10),
                    nw = parseInt(this.get('width'), 10),
                    maxH = this.get('maxHeight'),
                    minH = this.get('minHeight'),
                    maxW = this.get('maxWidth'),
                    minW = this.get('minWidth');

                switch (this._currentHandle) {
                    case 'l':
                        h = nh * (w / nw);
                        h = Math.min(Math.max(minH, h), maxH);                        
                        w = nw * (h / nh);
                        t = (this._cache.start.top - (-((nh - h) / 2)));
                        l = (this._cache.start.left - (-((nw - w))));
                        break;
                    case 'r':
                        h = nh * (w / nw);
                        h = Math.min(Math.max(minH, h), maxH);                        
                        w = nw * (h / nh);
                        t = (this._cache.start.top - (-((nh - h) / 2)));
                        break;
                    case 't':
                        w = nw * (h / nh);
                        h = nh * (w / nw);
                        l = (this._cache.start.left - (-((nw - w) / 2)));
                        t = (this._cache.start.top - (-((nh - h))));
                        break;
                    case 'b':
                        w = nw * (h / nh);
                        h = nh * (w / nw);
                        l = (this._cache.start.left - (-((nw - w) / 2)));
                        break;
                    case 'bl':
                        h = nh * (w / nw);
                        w = nw * (h / nh);
                        l = (this._cache.start.left - (-((nw - w))));
                        break;
                    case 'br':
                        h = nh * (w / nw);
                        w = nw * (h / nh);
                        break;
                    case 'tl':
                        h = nh * (w / nw);
                        w = nw * (h / nh);
                        l = (this._cache.start.left - (-((nw - w))));
                        t = (this._cache.start.top - (-((nh - h))));
                        break;
                    case 'tr':
                        h = nh * (w / nw);
                        w = nw * (h / nh);
                        l = (this._cache.start.left);
                        t = (this._cache.start.top - (-((nh - h))));
                        break;
                }
                oh = this._checkHeight(h);
                ow = this._checkWidth(w);
                if ((oh != h) || (ow != w)) {
                    t = 0;
                    l = 0;
                    if (oh != h) {
                        ow = this._cache.width;
                    }
                    if (ow != w) {
                        oh = this._cache.height;
                    }
                }
            }
            return [oh, ow, t, l];
        },
        /**
		 * @private
		 * @method _updateStatus
		 * @param {Number}
		 *            h The new height setting.
		 * @param {Number}
		 *            w The new width setting.
		 * @param {Number}
		 *            t The new top setting.
		 * @param {Number}
		 *            l The new left setting.
		 * @description Using the Height, Width, Top & Left, it updates the
		 *              status element with the elements sizes.
		 */
        _updateStatus: function(h, w, t, l) {
            if (this._resizeEvent && (!Lang.isString(this._resizeEvent))) {
                h = ((h === 0) ? this._cache.start.height : h);
                w = ((w === 0) ? this._cache.start.width : w);
                var h1 = parseInt(this.get('height'), 10),
                    w1 = parseInt(this.get('width'), 10);
                
                if (isNaN(h1)) {
                    h1 = parseInt(h, 10);
                }
                if (isNaN(w1)) {
                    w1 = parseInt(w, 10);
                }
                var diffH = (parseInt(h, 10) - h1);
                var diffW = (parseInt(w, 10) - w1);
                this._cache.offsetHeight = diffH;
                this._cache.offsetWidth = diffW;
                if (this.get('status')) {
                    D.setStyle(this._status, 'display', 'inline');
                    // This will cause IE8 to crash if the status box is
					// hidden..
                    this._status.innerHTML = '<strong>' + parseInt(h, 10) + ' x ' + parseInt(w, 10) + '</strong><em>' + ((diffH > 0) ? '+' : '') + diffH + ' x ' + ((diffW > 0) ? '+' : '') + diffW + '</em>';
                    D.setXY(this._status, [Event.getPageX(this._resizeEvent) + 12, Event.getPageY(this._resizeEvent) + 12]);
                }
            }
        },
        /**
		 * @method lock
		 * @description Lock the resize so it can't be resized
		 * @param {Boolean}
		 *            dd If the draggable config is set, lock it too
		 * @return {<a href="YAHOO.util.Resize.html">YAHOO.util.Resize</a>}
		 *         The Resize instance
		 */
        lock: function(dd) {
            this._locked = true;
            if (dd && this.dd) {
                D.removeClass(this._wrap, 'yui-draggable');
                this.dd.lock();
            }
            return this;
        },
        /**
		 * @method unlock
		 * @description Unlock the resize so it can be resized
		 * @param {Boolean}
		 *            dd If the draggable config is set, unlock it too
		 * @return {<a href="YAHOO.util.Resize.html">YAHOO.util.Resize</a>}
		 *         The Resize instance
		 */
        unlock: function(dd) {
            this._locked = false;
            if (dd && this.dd) {
                D.addClass(this._wrap, 'yui-draggable');
                this.dd.unlock();
            }
            return this;
        },
        /**
		 * @method isLocked
		 * @description Check the locked status of the resize instance
		 * @return {Boolean}
		 */
        isLocked: function() {
            return this._locked;
        },
        /**
		 * @method reset
		 * @description Resets the element to is start state.
		 * @return {<a href="YAHOO.util.Resize.html">YAHOO.util.Resize</a>}
		 *         The Resize instance
		 */
        reset: function() {
            this.resize(null, this._cache.start.height, this._cache.start.width, this._cache.start.top, this._cache.start.left, true);
            return this;
        },
        /**
		 * @private
		 * @method resize
		 * @param {Event}
		 *            ev The mouse event.
		 * @param {Number}
		 *            h The new height setting.
		 * @param {Number}
		 *            w The new width setting.
		 * @param {Number}
		 *            t The new top setting.
		 * @param {Number}
		 *            l The new left setting.
		 * @param {Boolean}
		 *            force Resize the element (used for proxy resize).
		 * @param {Boolean}
		 *            silent Don't fire the beforeResize Event.
		 * @description Resizes the element, wrapper or proxy based on the data
		 *              from the handlers.
		 * @return {<a href="YAHOO.util.Resize.html">YAHOO.util.Resize</a>}
		 *         The Resize instance
		 */
        resize: function(ev, h, w, t, l, force, silent) {
            if (this._locked) {
                return false;
            }
            this._resizeEvent = ev;
            var el = this._wrap, anim = this.get('animate'), set = true;
            if (this._proxy && !force) {
                el = this._proxy;
                anim = false;
            }
            this._setAutoRatio(ev);
            if (this._positioned) {
                if (this._proxy) {
                    t = this._cache.top - t;
                    l = this._cache.left - l;
                }
            }
            
            
            var ratio = this._setRatio(h, w, t, l);
            h = parseInt(ratio[0], 10);
            w = parseInt(ratio[1], 10);
            t = parseInt(ratio[2], 10);
            l = parseInt(ratio[3], 10);
            
            if (t == 0) {
                // No Offset, get from cache
                t = D.getY(el);
            }
            if (l == 0) {
                // No Offset, get from cache
                l = D.getX(el);
            }

            

            if (this._positioned) {
                if (this._proxy && force) {
                    if (!anim) {
                        el.style.top = this._proxy.style.top;
                        el.style.left = this._proxy.style.left;
                    } else {
                        t = this._proxy.style.top;
                        l = this._proxy.style.left;
                    }
                } else {
                    if (!this.get('ratio') && !this._proxy) {
                        t = this._cache.top + -(t);
                        l = this._cache.left + -(l);
                    }
                    if (t) {
                        if (this.get('minY')) {
                            if (t < this.get('minY')) {
                                t = this.get('minY');
                            }
                        }
                        if (this.get('maxY')) {
                            if (t > this.get('maxY')) {
                                t = this.get('maxY');
                            }
                        }
                    }
                    if (l) {
                        if (this.get('minX')) {
                            if (l < this.get('minX')) {
                                l = this.get('minX');
                            }
                        }
                        if (this.get('maxX')) {
                            if ((l + w) > this.get('maxX')) {
                                l = (this.get('maxX') - w);
                            }
                        }
                    }
                }
            }
            if (!silent) {
                var beforeReturn = this.fireEvent('beforeResize', { ev: 'beforeResize', target: this, height: h, width: w, top: t, left: l });
                if (beforeReturn === false) {
                    return false;
                }
            }

            this._updateStatus(h, w, t, l);


            if (this._positioned) {
                if (this._proxy && force) {
                    // Do nothing
                } else {
                    if (t) {
                        D.setY(el, t);
                        this._cache.top = t;
                    }
                    if (l) {
                        D.setX(el, l);
                        this._cache.left = l;
                    }
                }
            }
            if (h) {
                if (!anim) {
                    set = true;
                    if (this._proxy && force) {
                        if (!this.get('setSize')) {
                            set = false;
                        }
                    }
                    if (set) {
                        el.style.height = h + 'px';
                    }
                    if ((this._proxy && force) || !this._proxy) {
                        if (this._wrap != this.get('element')) {
                            this.get('element').style.height = h + 'px';
                        }
                    }
                }
                this._cache.height = h;
            }
            if (w) {
                this._cache.width = w;
                if (!anim) {
                    set = true;
                    if (this._proxy && force) {
                        if (!this.get('setSize')) {
                            set = false;
                        }
                    }
                    if (set) {
                        el.style.width = w + 'px';
                    }
                    if ((this._proxy && force) || !this._proxy) {
                        if (this._wrap != this.get('element')) {
                            this.get('element').style.width = w + 'px';
                        }
                    }
                }
            }
            if (anim) {
                if (YAHOO.util.Anim) {
                    var _anim = new YAHOO.util.Anim(el, {
                        height: {
                            to: this._cache.height
                        },
                        width: {
                            to: this._cache.width
                        }
                    }, this.get('animateDuration'), this.get('animateEasing'));
                    if (this._positioned) {
                        if (t) {
                            _anim.attributes.top = {
                                to: parseInt(t, 10)
                            };
                        }
                        if (l) {
                            _anim.attributes.left = {
                                to: parseInt(l, 10)
                            };
                        }
                    }

                    if (this._wrap != this.get('element')) {
                        _anim.onTween.subscribe(function() {
                            this.get('element').style.height = el.style.height;
                            this.get('element').style.width = el.style.width;
                        }, this, true);
                    }

                    _anim.onComplete.subscribe(function() {
                        this.set('height', h);
                        this.set('width', w);
                        this.fireEvent('resize', { ev: 'resize', target: this, height: h, width: w, top: t, left: l });
                    }, this, true);
                    _anim.animate();

                }
            } else {
                if (this._proxy && !force) {
                    this.fireEvent('proxyResize', { ev: 'proxyresize', target: this, height: h, width: w, top: t, left: l });
                } else {
                    this.fireEvent('resize', { ev: 'resize', target: this, height: h, width: w, top: t, left: l });
                }
            }
            return this;
        },
        /**
		 * @private
		 * @method _handle_for_br
		 * @param {Object}
		 *            args The arguments from the CustomEvent.
		 * @description Handles the sizes for the Bottom Right handle.
		 */
        _handle_for_br: function(args) {
            var newW = this._setWidth(args.e);
            var newH = this._setHeight(args.e);
            this.resize(args.e, newH, newW, 0, 0);
        },
        /**
		 * @private
		 * @method _handle_for_bl
		 * @param {Object}
		 *            args The arguments from the CustomEvent.
		 * @description Handles the sizes for the Bottom Left handle.
		 */
        _handle_for_bl: function(args) {
            var newW = this._setWidth(args.e, true);
            var newH = this._setHeight(args.e);
            var l = (newW - this._cache.width);
            this.resize(args.e, newH, newW, 0, l);
        },
        /**
		 * @private
		 * @method _handle_for_tl
		 * @param {Object}
		 *            args The arguments from the CustomEvent.
		 * @description Handles the sizes for the Top Left handle.
		 */
        _handle_for_tl: function(args) {
            var newW = this._setWidth(args.e, true);
            var newH = this._setHeight(args.e, true);
            var t = (newH - this._cache.height);
            var l = (newW - this._cache.width);
            this.resize(args.e, newH, newW, t, l);
        },
        /**
		 * @private
		 * @method _handle_for_tr
		 * @param {Object}
		 *            args The arguments from the CustomEvent.
		 * @description Handles the sizes for the Top Right handle.
		 */
        _handle_for_tr: function(args) {
            var newW = this._setWidth(args.e);
            var newH = this._setHeight(args.e, true);
            var t = (newH - this._cache.height);
            this.resize(args.e, newH, newW, t, 0);
        },
        /**
		 * @private
		 * @method _handle_for_r
		 * @param {Object}
		 *            args The arguments from the CustomEvent.
		 * @description Handles the sizes for the Right handle.
		 */
        _handle_for_r: function(args) {
            this._dds.r.setYConstraint(0,0);
            var newW = this._setWidth(args.e);
            this.resize(args.e, 0, newW, 0, 0);
        },
        /**
		 * @private
		 * @method _handle_for_l
		 * @param {Object}
		 *            args The arguments from the CustomEvent.
		 * @description Handles the sizes for the Left handle.
		 */
        _handle_for_l: function(args) {
            this._dds.l.setYConstraint(0,0);
            var newW = this._setWidth(args.e, true);
            var l = (newW - this._cache.width);
            this.resize(args.e, 0, newW, 0, l);
        },
        /**
		 * @private
		 * @method _handle_for_b
		 * @param {Object}
		 *            args The arguments from the CustomEvent.
		 * @description Handles the sizes for the Bottom handle.
		 */
        _handle_for_b: function(args) {
            this._dds.b.setXConstraint(0,0);
            var newH = this._setHeight(args.e);
            this.resize(args.e, newH, 0, 0, 0);
        },
        /**
		 * @private
		 * @method _handle_for_t
		 * @param {Object}
		 *            args The arguments from the CustomEvent.
		 * @description Handles the sizes for the Top handle.
		 */
        _handle_for_t: function(args) {
            this._dds.t.setXConstraint(0,0);
            var newH = this._setHeight(args.e, true);
            var t = (newH - this._cache.height);
            this.resize(args.e, newH, 0, t, 0);
        },
        /**
		 * @private
		 * @method _setWidth
		 * @param {Event}
		 *            ev The mouse event.
		 * @param {Boolean}
		 *            flip Argument to determine the direction of the movement.
		 * @description Calculates the width based on the mouse event.
		 * @return {Number} The new value
		 */
        _setWidth: function(ev, flip) {
            var xy = this._cache.xy[0],
                w = this._cache.width,
                x = Event.getPageX(ev),
                nw = (x - xy);

                if (flip) {
                    nw = (xy - x) + parseInt(this.get('width'), 10);
                }
                
                nw = this._snapTick(nw, this.get('xTicks'));
                nw = this._checkWidth(nw);
            return nw;
        },
        /**
		 * @private
		 * @method _checkWidth
		 * @param {Number}
		 *            w The width to check.
		 * @description Checks the value passed against the maxWidth and
		 *              minWidth.
		 * @return {Number} the new value
		 */
        _checkWidth: function(w) {
            if (this.get('minWidth')) {
                if (w <= this.get('minWidth')) {
                    w = this.get('minWidth');
                }
            }
            if (this.get('maxWidth')) {
                if (w >= this.get('maxWidth')) {
                    w = this.get('maxWidth');
                }
            }
            return w;
        },
        /**
		 * @private
		 * @method _checkHeight
		 * @param {Number}
		 *            h The height to check.
		 * @description Checks the value passed against the maxHeight and
		 *              minHeight.
		 * @return {Number} The new value
		 */
        _checkHeight: function(h) {
            if (this.get('minHeight')) {
                if (h <= this.get('minHeight')) {
                    h = this.get('minHeight');
                }
            }
            if (this.get('maxHeight')) {
                if (h >= this.get('maxHeight')) {
                    h = this.get('maxHeight');
                }
            }
            return h;
        },
        /**
		 * @private
		 * @method _setHeight
		 * @param {Event}
		 *            ev The mouse event.
		 * @param {Boolean}
		 *            flip Argument to determine the direction of the movement.
		 * @description Calculated the height based on the mouse event.
		 * @return {Number} The new value
		 */
        _setHeight: function(ev, flip) {
            var xy = this._cache.xy[1],
                h = this._cache.height,
                y = Event.getPageY(ev),
                nh = (y - xy);

                if (flip) {
                    nh = (xy - y) + parseInt(this.get('height'), 10);
                }
                nh = this._snapTick(nh, this.get('yTicks'));
                nh = this._checkHeight(nh);
                
            return nh;
        },
        /**
		 * @private
		 * @method _snapTick
		 * @param {Number}
		 *            size The size to tick against.
		 * @param {Number}
		 *            pix The tick pixels.
		 * @description Adjusts the number based on the ticks used.
		 * @return {Number} the new snapped position
		 */
        _snapTick: function(size, pix) {
            if (!size || !pix) {
                return size;
            }
            var _s = size;
            var _x = size % pix;
            if (_x > 0) {
                if (_x > (pix / 2)) {
                    _s = size + (pix - _x);
                } else {
                    _s = size - _x;
                }
            }
            return _s;
        },
        /**
		 * @private
		 * @method init
		 * @description The Resize class's initialization method
		 */        
        init: function(p_oElement, p_oAttributes) {
            this._locked = false;
            this._cache = {
                xy: [],
                height: 0,
                width: 0,
                top: 0,
                left: 0,
                offsetHeight: 0,
                offsetWidth: 0,
                start: {
                    height: 0,
                    width: 0,
                    top: 0,
                    left: 0
                }
            };

            Resize.superclass.init.call(this, p_oElement, p_oAttributes);

            this.set('setSize', this.get('setSize'));

            if (p_oAttributes.height) {
                this.set('height', parseInt(p_oAttributes.height, 10));
            } else {
                var h = this.getStyle('height');
                if (h == 'auto') {
                    this.set('height', parseInt(this.get('element').offsetHeight, 10));
                }
            }
            if (p_oAttributes.width) {
                this.set('width', parseInt(p_oAttributes.width, 10));
            } else {
                var w = this.getStyle('width');
                if (w == 'auto') {
                    this.set('width', parseInt(this.get('element').offsetWidth, 10));
                }
            }
            
            var id = p_oElement;
            if (!Lang.isString(id)) {
                id = D.generateId(id);
            }
            Resize._instances[id] = this;

            this._active = false;
            
            this._createWrap();
            this._createProxy();
            this._createHandles();

        },
        /**
		 * @method getProxyEl
		 * @description Get the HTML reference for the proxy, returns null if no
		 *              proxy.
		 * @return {HTMLElement} The proxy element
		 */      
        getProxyEl: function() {
            return this._proxy;
        },
        /**
		 * @method getWrapEl
		 * @description Get the HTML reference for the wrap element, returns the
		 *              current element if not wrapped.
		 * @return {HTMLElement} The wrap element
		 */      
        getWrapEl: function() {
            return this._wrap;
        },
        /**
		 * @method getStatusEl
		 * @description Get the HTML reference for the status element.
		 * @return {HTMLElement} The status element
		 */      
        getStatusEl: function() {
            return this._status;
        },
        /**
		 * @method getActiveHandleEl
		 * @description Get the HTML reference for the currently active resize
		 *              handle.
		 * @return {HTMLElement} The handle element that is active
		 */      
        getActiveHandleEl: function() {
            return this._handles[this._currentHandle];
        },
        /**
		 * @method isActive
		 * @description Returns true or false if a resize operation is currently
		 *              active on the element.
		 * @return {Boolean}
		 */      
        isActive: function() {
            return ((this._active) ? true : false);
        },
        /**
		 * @private
		 * @method initAttributes
		 * @description Initializes all of the configuration attributes used to
		 *              create a resizable element.
		 * @param {Object}
		 *            attr Object literal specifying a set of configuration
		 *            attributes used to create the utility.
		 */      
        initAttributes: function(attr) {
            Resize.superclass.initAttributes.call(this, attr);

            /**
			 * @attribute useShim
			 * @description This setting will be passed to the DragDrop
			 *              instances on the resize handles and for the
			 *              draggable property. This property should be used if
			 *              you want the resize handles to work over iframe and
			 *              other elements.
			 * @type Boolean
			 */
            this.setAttributeConfig('useShim', {
                value: ((attr.useShim === true) ? true : false),
                validator: YAHOO.lang.isBoolean,
                method: function(u) {
                    for (var i in this._dds) {
                        if (Lang.hasOwnProperty(this._dds, i)) {
                            this._dds[i].useShim = u;
                        }
                    }
                    if (this.dd) {
                        this.dd.useShim = u;
                    }
                }
            });
            /**
			 * @attribute setSize
			 * @description Set the size of the resized element, if set to false
			 *              the element will not be auto resized, the resize
			 *              event will contain the dimensions so the end user
			 *              can resize it on their own. This setting will only
			 *              work with proxy set to true and animate set to
			 *              false.
			 * @type Boolean
			 */
            this.setAttributeConfig('setSize', {
                value: ((attr.setSize === false) ? false : true),
                validator: YAHOO.lang.isBoolean
            });

            /**
			 * @attribute wrap
			 * @description Should we wrap the element
			 * @type Boolean
			 */
            this.setAttributeConfig('wrap', {
                writeOnce: true,
                validator: YAHOO.lang.isBoolean,
                value: attr.wrap || false
            });

            /**
			 * @attribute handles
			 * @description The handles to use (any combination of): 't', 'b',
			 *              'r', 'l', 'bl', 'br', 'tl', 'tr'. Defaults to: ['r',
			 *              'b', 'br']. Can use a shortcut of All. Note: 8 way
			 *              resizing should be done on an element that is
			 *              absolutely positioned.
			 * @type Array
			 */
            this.setAttributeConfig('handles', {
                writeOnce: true,
                value: attr.handles || ['r', 'b', 'br'],
                validator: function(handles) {
                    if (Lang.isString(handles) && handles.toLowerCase() == 'all') {
                        handles = ['t', 'b', 'r', 'l', 'bl', 'br', 'tl', 'tr'];
                    }
                    if (!Lang.isArray(handles)) {
                        handles = handles.replace(/, /g, ',');
                        handles = handles.split(',');
                    }
                    this._configs.handles.value = handles;
                }
            });

            /**
			 * @attribute width
			 * @description The width of the element
			 * @type Number
			 */
            this.setAttributeConfig('width', {
                value: attr.width || parseInt(this.getStyle('width'), 10),
                validator: YAHOO.lang.isNumber,
                method: function(width) {
                    width = parseInt(width, 10);
                    if (width > 0) {
                        if (this.get('setSize')) {
                            this.setStyle('width', width + 'px');
                        }
                        this._cache.width = width;
                        this._configs.width.value = width;
                    }
                }
            });

            /**
			 * @attribute height
			 * @description The height of the element
			 * @type Number
			 */
            this.setAttributeConfig('height', {
                value: attr.height || parseInt(this.getStyle('height'), 10),
                validator: YAHOO.lang.isNumber,
                method: function(height) {
                    height = parseInt(height, 10);
                    if (height > 0) {
                        if (this.get('setSize')) {
                            this.setStyle('height', height + 'px');
                        }
                        this._cache.height = height;
                        this._configs.height.value = height;
                    }
                }
            });

            /**
			 * @attribute minWidth
			 * @description The minimum width of the element
			 * @type Number
			 */
            this.setAttributeConfig('minWidth', {
                value: attr.minWidth || 15,
                validator: YAHOO.lang.isNumber
            });

            /**
			 * @attribute minHeight
			 * @description The minimum height of the element
			 * @type Number
			 */
            this.setAttributeConfig('minHeight', {
                value: attr.minHeight || 15,
                validator: YAHOO.lang.isNumber
            });

            /**
			 * @attribute maxWidth
			 * @description The maximum width of the element
			 * @type Number
			 */
            this.setAttributeConfig('maxWidth', {
                value: attr.maxWidth || 10000,
                validator: YAHOO.lang.isNumber
            });

            /**
			 * @attribute maxHeight
			 * @description The maximum height of the element
			 * @type Number
			 */
            this.setAttributeConfig('maxHeight', {
                value: attr.maxHeight || 10000,
                validator: YAHOO.lang.isNumber
            });

            /**
			 * @attribute minY
			 * @description The minimum y coord of the element
			 * @type Number
			 */
            this.setAttributeConfig('minY', {
                value: attr.minY || false
            });

            /**
			 * @attribute minX
			 * @description The minimum x coord of the element
			 * @type Number
			 */
            this.setAttributeConfig('minX', {
                value: attr.minX || false
            });
            /**
			 * @attribute maxY
			 * @description The max y coord of the element
			 * @type Number
			 */
            this.setAttributeConfig('maxY', {
                value: attr.maxY || false
            });

            /**
			 * @attribute maxX
			 * @description The max x coord of the element
			 * @type Number
			 */
            this.setAttributeConfig('maxX', {
                value: attr.maxX || false
            });

            /**
			 * @attribute animate
			 * @description Should be use animation to resize the element (can
			 *              only be used if we use proxy).
			 * @type Boolean
			 */
            this.setAttributeConfig('animate', {
                value: attr.animate || false,
                validator: function(value) {
                    var ret = true;
                    if (!YAHOO.util.Anim) {
                        ret = false;
                    }
                    return ret;
                }               
            });

            /**
			 * @attribute animateEasing
			 * @description The Easing to apply to the animation.
			 * @type Object
			 */
            this.setAttributeConfig('animateEasing', {
                value: attr.animateEasing || function() {
                    var easing = false;
                    if (YAHOO.util.Easing && YAHOO.util.Easing.easeOut) {
                        easing = YAHOO.util.Easing.easeOut;
                    }
                    return easing;
                }()
            });

            /**
			 * @attribute animateDuration
			 * @description The Duration to apply to the animation.
			 * @type Number
			 */
            this.setAttributeConfig('animateDuration', {
                value: attr.animateDuration || 0.5
            });

            /**
			 * @attribute proxy
			 * @description Resize a proxy element instead of the real element.
			 * @type Boolean
			 */
            this.setAttributeConfig('proxy', {
                value: attr.proxy || false,
                validator: YAHOO.lang.isBoolean
            });

            /**
			 * @attribute ratio
			 * @description Maintain the element's ratio when resizing.
			 * @type Boolean
			 */
            this.setAttributeConfig('ratio', {
                value: attr.ratio || false,
                validator: YAHOO.lang.isBoolean
            });

            /**
			 * @attribute ghost
			 * @description Apply an opacity filter to the element being resized
			 *              (only works with proxy).
			 * @type Boolean
			 */
            this.setAttributeConfig('ghost', {
                value: attr.ghost || false,
                validator: YAHOO.lang.isBoolean
            });

            /**
			 * @attribute draggable
			 * @description A convienence method to make the element draggable
			 * @type Boolean
			 */
            this.setAttributeConfig('draggable', {
                value: attr.draggable || false,
                validator: YAHOO.lang.isBoolean,
                method: function(dd) {
                    if (dd && this._wrap && !this.dd) {
                        this._setupDragDrop();
                    } else {
                        if (this.dd) {
                            if (dd) {
                                // activating an old DD instance..
                                D.addClass(this._wrap, this.CSS_DRAG);
                                this.dd.DDM.regDragDrop(this.dd, "default");
                            } else {
                                D.removeClass(this._wrap, this.CSS_DRAG);
                                this.dd.unreg();
                            }
                        }
                    }
                }
            });

            /**
			 * @attribute hover
			 * @description Only show the handles when they are being moused
			 *              over.
			 * @type Boolean
			 */
            this.setAttributeConfig('hover', {
                value: attr.hover || false,
                validator: YAHOO.lang.isBoolean
            });

            /**
			 * @attribute hiddenHandles
			 * @description Don't show the handles, just use the cursor to the
			 *              user.
			 * @type Boolean
			 */
            this.setAttributeConfig('hiddenHandles', {
                value: attr.hiddenHandles || false,
                validator: YAHOO.lang.isBoolean
            });

            /**
			 * @attribute knobHandles
			 * @description Use the smaller handles, instead if the full size
			 *              handles.
			 * @type Boolean
			 */
            this.setAttributeConfig('knobHandles', {
                value: attr.knobHandles || false,
                validator: YAHOO.lang.isBoolean
            });

            /**
			 * @attribute xTicks
			 * @description The number of x ticks to span the resize to.
			 * @type Number or False
			 */
            this.setAttributeConfig('xTicks', {
                value: attr.xTicks || false
            });

            /**
			 * @attribute yTicks
			 * @description The number of y ticks to span the resize to.
			 * @type Number or False
			 */
            this.setAttributeConfig('yTicks', {
                value: attr.yTicks || false
            });

            /**
			 * @attribute status
			 * @description Show the status (new size) of the resize.
			 * @type Boolean
			 */
            this.setAttributeConfig('status', {
                value: attr.status || false,
                validator: YAHOO.lang.isBoolean
            });

            /**
			 * @attribute autoRatio
			 * @description Using the shift key during a resize will toggle the
			 *              ratio config.
			 * @type Boolean
			 */
            this.setAttributeConfig('autoRatio', {
                value: attr.autoRatio || false,
                validator: YAHOO.lang.isBoolean
            });

        },
        /**
		 * @method destroy
		 * @description Destroys the resize object and all of it's elements &
		 *              listeners.
		 */        
        destroy: function() {
            for (var h in this._handles) {
                if (Lang.hasOwnProperty(this._handles, h)) {
                    Event.purgeElement(this._handles[h]);
                    this._handles[h].parentNode.removeChild(this._handles[h]);
                }
            }
            if (this._proxy) {
                this._proxy.parentNode.removeChild(this._proxy);
            }
            if (this._status) {
                this._status.parentNode.removeChild(this._status);
            }
            if (this.dd) {
                this.dd.unreg();
                D.removeClass(this._wrap, this.CSS_DRAG);
            }
            if (this._wrap != this.get('element')) {
                this.setStyle('position', (this._positioned ? 'absolute' : 'relative'));
                this.setStyle('top', D.getStyle(this._wrap, 'top'));
                this.setStyle('left',D.getStyle(this._wrap, 'left'));
                this._wrap.parentNode.replaceChild(this.get('element'), this._wrap);
            }
            this.removeClass(this.CSS_RESIZE);

            delete YAHOO.util.Resize._instances[this.get('id')];
            // Brutal Object Destroy
            for (var i in this) {
                if (Lang.hasOwnProperty(this, i)) {
                    this[i] = null;
                    delete this[i];
                }
            }
        },
        /**
		 * @method toString
		 * @description Returns a string representing the Resize Object.
		 * @return {String}
		 */        
        toString: function() {
            if (this.get) {
                return 'Resize (#' + this.get('id') + ')';
            }
            return 'Resize Utility';
        }
    });

    YAHOO.util.Resize = Resize;
 
/**
 * @event dragEvent
 * @description Fires when the <a
 *              href="YAHOO.util.DragDrop.html">YAHOO.util.DragDrop</a>
 *              dragEvent is fired for the config option draggable.
 * @type YAHOO.util.CustomEvent
 */
/**
 * @event startResize
 * @description Fires when a resize action is started.
 * @type YAHOO.util.CustomEvent
 */
/**
 * @event endResize
 * @description Fires when the mouseUp event from the Drag Instance fires.
 * @type YAHOO.util.CustomEvent
 */
/**
 * @event resize
 * @description Fires on every element resize (only fires once when used with
 *              proxy config setting).
 * @type YAHOO.util.CustomEvent
 */
/**
 * @event beforeResize
 * @description Fires before every element resize after the size calculations,
 *              returning false will stop the resize.
 * @type YAHOO.util.CustomEvent
 */
/**
 * @event proxyResize
 * @description Fires on every proxy resize (only fires when used with proxy
 *              config setting).
 * @type YAHOO.util.CustomEvent
 */

})();

YAHOO.register("resize", YAHOO.util.Resize, {version: "2.9.0", build: "2800"});
/*
 * Copyright (c) 2011, Yahoo! Inc. All rights reserved. Code licensed under the
 * BSD License: http://developer.yahoo.com/yui/license.html version: 2.9.0
 */
/**
 * @description
 * <p>
 * Provides a fixed layout containing, top, bottom, left, right and center
 * layout units. It can be applied to either the body or an element.
 * </p>
 * @namespace YAHOO.widget
 * @requires yahoo, dom, element, event
 * @module layout
 */
(function() {
    var Dom = YAHOO.util.Dom,
        Event = YAHOO.util.Event,
        Lang = YAHOO.lang;

    /**
	 * @constructor
	 * @class Layout
	 * @extends YAHOO.util.Element
	 * @description
	 *          <p>
	 *          Provides a fixed layout containing, top, bottom, left, right and
	 *          center layout units. It can be applied to either the body or an
	 *          element.
	 *          </p>
	 * @param {String/HTMLElement}
	 *            el The element to make contain a layout.
	 * @param {Object}
	 *            attrs Object liternal containing configuration parameters.
	 */

    var Layout = function(el, config) {
        if (Lang.isObject(el) && !el.tagName) {
            config = el;
            el = null;
        }
        if (Lang.isString(el)) {
            if (Dom.get(el)) {
                el = Dom.get(el);
            }
        }
        if (!el) {
            el = document.body;
        }

        var oConfig = {
            element: el,
            attributes: config || {}
        };

        Layout.superclass.constructor.call(this, oConfig.element, oConfig.attributes);    
    };

    /**
	 * @private
	 * @static
	 * @property _instances
	 * @description Internal hash table for all layout instances
	 * @type Object
	 */ 
    Layout._instances = {};
    /**
	 * @static
	 * @method getLayoutById
	 * @description Get's a layout object by the HTML id of the element
	 *              associated with the Layout object.
	 * @return {Object} The Layout Object
	 */ 
    Layout.getLayoutById = function(id) {
        if (Layout._instances[id]) {
            return Layout._instances[id];
        }
        return false;
    };

    YAHOO.extend(Layout, YAHOO.util.Element, {
        /**
		 * @property browser
		 * @description A modified version of the YAHOO.env.ua object
		 * @type Object
		 */
        browser: function() {
            var b = YAHOO.env.ua;
            b.standardsMode = false;
            b.secure = false;
            return b;
        }(),
        /**
		 * @private
		 * @property _units
		 * @description An object literal that contains a list of units in the
		 *              layout
		 * @type Object
		 */
        _units: null,
        /**
		 * @private
		 * @property _rendered
		 * @description Set to true when the layout is rendered
		 * @type Boolean
		 */
        _rendered: null,
        /**
		 * @private
		 * @property _zIndex
		 * @description The zIndex to set all LayoutUnits to
		 * @type Number
		 */
        _zIndex: null,
        /**
		 * @private
		 * @property _sizes
		 * @description A collection of the current sizes of all usable
		 *              LayoutUnits to be used for calculations
		 * @type Object
		 */
        _sizes: null,
        /**
		 * @private
		 * @method _setBodySize
		 * @param {Boolean}
		 *            set If set to false, it will NOT set the size, just
		 *            perform the calculations (used for collapsing units)
		 * @description Used to set the body size of the layout, sets the height
		 *              and width of the parent container
		 */
        _setBodySize: function(set) {
            var h = 0, w = 0;
            set = ((set === false) ? false : true);

            if (this._isBody) {
                h = Dom.getClientHeight();
                w = Dom.getClientWidth();
            } else {
                h = parseInt(this.getStyle('height'), 10);
                w = parseInt(this.getStyle('width'), 10);
                if (isNaN(w)) {
                    w = this.get('element').clientWidth;
                }
                if (isNaN(h)) {
                    h = this.get('element').clientHeight;
                }
            }
            if (this.get('minWidth')) {
                if (w < this.get('minWidth')) {
                    w = this.get('minWidth');
                }
            }
            if (this.get('minHeight')) {
                if (h < this.get('minHeight')) {
                    h = this.get('minHeight');
                }
            }
            if (set) {
                if (h < 0) {
                    h = 0;
                }
                if (w < 0) {
                    w = 0;
                }
                Dom.setStyle(this._doc, 'height', h + 'px');
                Dom.setStyle(this._doc, 'width', w + 'px');
            }
            this._sizes.doc = { h: h, w: w };
            this._setSides(set);
        },
        /**
		 * @private
		 * @method _setSides
		 * @param {Boolean}
		 *            set If set to false, it will NOT set the size, just
		 *            perform the calculations (used for collapsing units)
		 * @description Used to set the size and position of the left, right,
		 *              top and bottom units
		 */
        _setSides: function(set) {
            var h1 = ((this._units.top) ? this._units.top.get('height') : 0),
                h2 = ((this._units.bottom) ? this._units.bottom.get('height') : 0),
                h = this._sizes.doc.h,
                w = this._sizes.doc.w;
            set = ((set === false) ? false : true);

            this._sizes.top = {
                h: h1, w: ((this._units.top) ? w : 0),
                t: 0
            };
            this._sizes.bottom = {
                h: h2, w: ((this._units.bottom) ? w : 0)
            };
            
            var newH = (h - (h1 + h2));

            this._sizes.left = {
                h: newH, w: ((this._units.left) ? this._units.left.get('width') : 0)
            };
            this._sizes.right = {
                h: newH, w: ((this._units.right) ? this._units.right.get('width') : 0),
                l: ((this._units.right) ? (w - this._units.right.get('width')) : 0),
                t: ((this._units.top) ? this._sizes.top.h : 0)
            };
            
            if (this._units.right && set) {
                this._units.right.set('top', this._sizes.right.t);
                if (!this._units.right._collapsing) { 
                    this._units.right.set('left', this._sizes.right.l);
                }
                this._units.right.set('height', this._sizes.right.h, true);
            }
            if (this._units.left) {
                this._sizes.left.l = 0;
                if (this._units.top) {
                    this._sizes.left.t = this._sizes.top.h;
                } else {
                    this._sizes.left.t = 0;
                }
                if (set) {
                    this._units.left.set('top', this._sizes.left.t);
                    this._units.left.set('height', this._sizes.left.h, true);
                    this._units.left.set('left', 0);
                }
            }
            if (this._units.bottom) {
                this._sizes.bottom.t = this._sizes.top.h + this._sizes.left.h;
                if (set) {
                    this._units.bottom.set('top', this._sizes.bottom.t);
                    this._units.bottom.set('width', this._sizes.bottom.w, true);
                }
            }
            if (this._units.top) {
                if (set) {
                    this._units.top.set('width', this._sizes.top.w, true);
                }
            }
            this._setCenter(set);
        },
        /**
		 * @private
		 * @method _setCenter
		 * @param {Boolean}
		 *            set If set to false, it will NOT set the size, just
		 *            perform the calculations (used for collapsing units)
		 * @description Used to set the size and position of the center unit
		 */
        _setCenter: function(set) {
            set = ((set === false) ? false : true);
            var h = this._sizes.left.h;
            var w = (this._sizes.doc.w - (this._sizes.left.w + this._sizes.right.w));
            if (set) {
                this._units.center.set('height', h, true);
                this._units.center.set('width', w, true);
                this._units.center.set('top', this._sizes.top.h);
                this._units.center.set('left', this._sizes.left.w);
            }
            this._sizes.center = { h: h, w: w, t: this._sizes.top.h, l: this._sizes.left.w };
        },
        /**
		 * @method getSizes
		 * @description Get a reference to the internal Layout Unit sizes object
		 *              used to build the layout wireframe
		 * @return {Object} An object of the layout unit sizes
		 */
        getSizes: function() {
            return this._sizes;
        },
        /**
		 * @method getUnitById
		 * @param {String}
		 *            id The HTML element id of the unit
		 * @description Get the LayoutUnit by it's HTML id
		 * @return {<a
		 *         href="YAHOO.widget.LayoutUnit.html">YAHOO.widget.LayoutUnit</a>}
		 *         The LayoutUnit instance
		 */
        getUnitById: function(id) {
            return YAHOO.widget.LayoutUnit.getLayoutUnitById(id);
        },
        /**
		 * @method getUnitByPosition
		 * @param {String}
		 *            pos The position of the unit in this layout
		 * @description Get the LayoutUnit by it's position in this layout
		 * @return {<a
		 *         href="YAHOO.widget.LayoutUnit.html">YAHOO.widget.LayoutUnit</a>}
		 *         The LayoutUnit instance
		 */
        getUnitByPosition: function(pos) {
            if (pos) {
                pos = pos.toLowerCase();
                if (this._units[pos]) {
                    return this._units[pos];
                }
                return false;
            }
            return false;
        },
        /**
		 * @method removeUnit
		 * @param {Object}
		 *            unit The LayoutUnit that you want to remove
		 * @description Remove the unit from this layout and resize the layout.
		 */
        removeUnit: function(unit) {
            delete this._units[unit.get('position')];
            this.resize();
        },
        /**
		 * @method addUnit
		 * @param {Object}
		 *            cfg The config for the LayoutUnit that you want to add
		 * @description Add a unit to this layout and if the layout is rendered,
		 *              resize the layout.
		 * @return {<a
		 *         href="YAHOO.widget.LayoutUnit.html">YAHOO.widget.LayoutUnit</a>}
		 *         The LayoutUnit instance
		 */
        addUnit: function(cfg) {
            if (!cfg.position) {
                return false;
            }
            if (this._units[cfg.position]) {
                return false;
            }
            var element = null,
                el = null;

            if (cfg.id) {
                if (Dom.get(cfg.id)) {
                    element = Dom.get(cfg.id);
                    delete cfg.id;

                }
            }
            if (cfg.element) {
                element = cfg.element;
            }

            if (!el) {
                el = document.createElement('div');
                var id = Dom.generateId();
                el.id = id;
            }

            if (!element) {
                element = document.createElement('div');
            }
            Dom.addClass(element, 'yui-layout-wrap');
            if (this.browser.ie && !this.browser.standardsMode) {
                el.style.zoom = 1;
                element.style.zoom = 1;
            }

            if (el.firstChild) {
                el.insertBefore(element, el.firstChild);
            } else {
                el.appendChild(element);
            }
            this._doc.appendChild(el);

            var h = false, w = false;

            if (cfg.height) {
                h = parseInt(cfg.height, 10);
            }
            if (cfg.width) {
                w = parseInt(cfg.width, 10);
            }
            var unitConfig = {};
            YAHOO.lang.augmentObject(unitConfig, cfg); // break obj ref

            unitConfig.parent = this;
            unitConfig.wrap = element;
            unitConfig.height = h;
            unitConfig.width = w;

            var unit = new YAHOO.widget.LayoutUnit(el, unitConfig);

            unit.on('heightChange', this.resize, { unit: unit }, this);
            unit.on('widthChange', this.resize, { unit: unit }, this);
            unit.on('gutterChange', this.resize, { unit: unit }, this);
            this._units[cfg.position] = unit;

            if (this._rendered) {
                this.resize();
            }

            return unit;
        },
        /**
		 * @private
		 * @method _createUnits
		 * @description Private method to create units from the config that was
		 *              passed in.
		 */
        _createUnits: function() {
            var units = this.get('units');
            for (var i in units) {
                if (Lang.hasOwnProperty(units, i)) {
                    this.addUnit(units[i]);
                }
            }
        },
        /**
		 * @method resize
		 * @param Boolean/Event
		 *            set If set to false, it will NOT set the size, just
		 *            perform the calculations (used for collapsing units). This
		 *            can also have an attribute event passed to it.
		 * @description Starts the chain of resize routines that will resize all
		 *              the units.
		 * @return {<a href="YAHOO.widget.Layout.html">YAHOO.widget.Layout</a>}
		 *         The Layout instance
		 */
        resize: function(set, info) {
            /*
			 * Fixes bug #2528175 If the event comes from an attribute and the
			 * value hasn't changed, don't process it.
			 */
            var ev = set;
            if (ev && ev.prevValue && ev.newValue) {
                if (ev.prevValue == ev.newValue) {
                    if (info) {
                        if (info.unit) {
                            if (!info.unit.get('animate')) {
                                set = false;
                            }
                        }
                    }
                }
            }
            set = ((set === false) ? false : true);
            if (set) {
                var retVal = this.fireEvent('beforeResize');
                if (retVal === false) {
                    set = false;
                }
                if (this.browser.ie) {
                    if (this._isBody) {
                        Dom.removeClass(document.documentElement, 'yui-layout');
                        Dom.addClass(document.documentElement, 'yui-layout');
                    } else {
                        this.removeClass('yui-layout');
                        this.addClass('yui-layout');
                    }
                }
            }
            this._setBodySize(set);
            if (set) {
                this.fireEvent('resize', { target: this, sizes: this._sizes, event: ev });
            }
            return this;
        },
        /**
		 * @private
		 * @method _setupBodyElements
		 * @description Sets up the main doc element when using the body as the
		 *              main element.
		 */
        _setupBodyElements: function() {
            this._doc = Dom.get('layout-doc');
            if (!this._doc) {
                this._doc = document.createElement('div');
                this._doc.id = 'layout-doc';
                if (document.body.firstChild) {
                    document.body.insertBefore(this._doc, document.body.firstChild);
                } else {
                    document.body.appendChild(this._doc);
                }
            }
            this._createUnits();
            this._setBodySize();
            Event.on(window, 'resize', this.resize, this, true);
            Dom.addClass(this._doc, 'yui-layout-doc');
        },
        /**
		 * @private
		 * @method _setupElements
		 * @description Sets up the main doc element when not using the body as
		 *              the main element.
		 */
        _setupElements: function() {
            this._doc = this.getElementsByClassName('yui-layout-doc')[0];
            if (!this._doc) {
                this._doc = document.createElement('div');
                this.get('element').appendChild(this._doc);
            }
            this._createUnits();
            this._setBodySize();
            Dom.addClass(this._doc, 'yui-layout-doc');
        },
        /**
		 * @private
		 * @property _isBody
		 * @description Flag to determine if we are using the body as the root
		 *              element.
		 * @type Boolean
		 */
        _isBody: null,
        /**
		 * @private
		 * @property _doc
		 * @description Reference to the root element
		 * @type HTMLElement
		 */
        _doc: null,
        /**
		 * @private
		 * @method init
		 * @description The Layout class' initialization method
		 */        
        init: function(p_oElement, p_oAttributes) {

            this._zIndex = 0;

            Layout.superclass.init.call(this, p_oElement, p_oAttributes);
            
            if (this.get('parent')) {
                this._zIndex = this.get('parent')._zIndex + 10;
            }

            this._sizes = {};
            this._units = {};

            var id = p_oElement;
            if (!Lang.isString(id)) {
                id = Dom.generateId(id);
            }
            Layout._instances[id] = this;
        },
        /**
		 * @method render
		 * @description This method starts the render process, applying
		 *              classnames and creating elements
		 * @return {<a href="YAHOO.widget.Layout.html">YAHOO.widget.Layout</a>}
		 *         The Layout instance
		 */        
        render: function() {
            this._stamp();
            var el = this.get('element');
            if (el && el.tagName && (el.tagName.toLowerCase() == 'body')) {
                this._isBody = true;
                Dom.addClass(document.body, 'yui-layout');
                if (Dom.hasClass(document.body, 'yui-skin-sam')) {
                    // Move the class up so we can have a css chain
                    Dom.addClass(document.documentElement, 'yui-skin-sam');
                    Dom.removeClass(document.body, 'yui-skin-sam');
                }
                this._setupBodyElements();
            } else {
                this._isBody = false;
                this.addClass('yui-layout');
                this._setupElements();
            }
            this.resize();
            this._rendered = true;
            this.fireEvent('render');

            return this;
        },
        /**
		 * @private
		 * @method _stamp
		 * @description Stamps the root node with a secure classname for ease of
		 *              use. Also sets the this.browser.standardsMode variable.
		 */        
        _stamp: function() {
            if (document.compatMode == 'CSS1Compat') {
                this.browser.standardsMode = true;
            }
            if (window.location.href.toLowerCase().indexOf("https") === 0) {
                Dom.addClass(document.documentElement, 'secure');
                this.browser.secure = true;
            }
        },
        /**
		 * @private
		 * @method initAttributes
		 * @description Processes the config
		 */        
        initAttributes: function(attr) {
            Layout.superclass.initAttributes.call(this, attr);
            /**
			 * @attribute units
			 * @description An array of config definitions for the LayoutUnits
			 *              to add to this layout
			 * @type Array
			 */
            this.setAttributeConfig('units', {
                writeOnce: true,
                validator: YAHOO.lang.isArray,
                value: attr.units || []
            });

            /**
			 * @attribute minHeight
			 * @description The minimum height in pixels
			 * @type Number
			 */
            this.setAttributeConfig('minHeight', {
                value: attr.minHeight || false,
                validator: YAHOO.lang.isNumber
            });

            /**
			 * @attribute minWidth
			 * @description The minimum width in pixels
			 * @type Number
			 */
            this.setAttributeConfig('minWidth', {
                value: attr.minWidth || false,
                validator: YAHOO.lang.isNumber
            });

            /**
			 * @attribute height
			 * @description The height in pixels
			 * @type Number
			 */
            this.setAttributeConfig('height', {
                value: attr.height || false,
                validator: YAHOO.lang.isNumber,
                method: function(h) {
                    if (h < 0) {
                        h = 0;
                    }
                    this.setStyle('height', h + 'px');
                }
            });

            /**
			 * @attribute width
			 * @description The width in pixels
			 * @type Number
			 */
            this.setAttributeConfig('width', {
                value: attr.width || false,
                validator: YAHOO.lang.isNumber,
                method: function(w) {
                    if (w < 0) {
                        w = 0;
                    }
                    this.setStyle('width', w + 'px');
                }
            });

            /**
			 * @attribute parent
			 * @description If this layout is to be used as a child of another
			 *              Layout instance, this config will bind the resize
			 *              events together.
			 * @type Object YAHOO.widget.Layout
			 */
            this.setAttributeConfig('parent', {
                writeOnce: true,
                value: attr.parent || false,
                method: function(p) {
                    if (p) {
                        p.on('resize', this.resize, this, true);
                    }
                }
            });
        },
        /**
		 * @method destroy
		 * @description Removes this layout from the page and destroys all units
		 *              that it contains. This will destroy all data inside the
		 *              layout and it's children.
		 */
        destroy: function() {
            var par = this.get('parent');
            if (par) {
                par.removeListener('resize', this.resize, this, true);
            }
            Event.removeListener(window, 'resize', this.resize, this, true);

            this.unsubscribeAll();
            for (var u in this._units) {
                if (Lang.hasOwnProperty(this._units, u)) {
                    if (this._units[u]) {
                        this._units[u].destroy(true);
                    }
                }
            }

            Event.purgeElement(this.get('element'), true);
            this.get('parentNode').removeChild(this.get('element'));
            
            delete YAHOO.widget.Layout._instances[this.get('id')];
            // Brutal Object Destroy
            for (var i in this) {
                if (Lang.hasOwnProperty(this, i)) {
                    this[i] = null;
                    delete this[i];
                }
            }
            
            if (par) {
                par.resize();
            }
        },
        /**
		 * @method toString
		 * @description Returns a string representing the Layout.
		 * @return {String}
		 */        
        toString: function() {
            if (this.get) {
                return 'Layout #' + this.get('id');
            }
            return 'Layout';
        }
    });
    /**
	 * @event resize
	 * @description Fired when this.resize is called
	 * @type YAHOO.util.CustomEvent
	 */
    /**
	 * @event startResize
	 * @description Fired when the Resize Utility for a Unit fires it's
	 *              startResize Event.
	 * @type YAHOO.util.CustomEvent
	 */
    /**
	 * @event beforeResize
	 * @description Fires at the beginning of the resize method. If you return
	 *              false, the resize is cancelled.
	 * @type YAHOO.util.CustomEvent
	 */
    /**
	 * @event render
	 * @description Fired after the render method completes.
	 * @type YAHOO.util.CustomEvent
	 */

    YAHOO.widget.Layout = Layout;
})();
/**
 * @description
 * <p>
 * Provides a fixed position unit containing a header, body and footer for use
 * with a YAHOO.widget.Layout instance.
 * </p>
 * @namespace YAHOO.widget
 * @requires yahoo, dom, element, event, layout
 * @optional animation, dragdrop, selector
 */
(function() {
    var Dom = YAHOO.util.Dom,
        Sel = YAHOO.util.Selector,
        Event = YAHOO.util.Event,
        Lang = YAHOO.lang;

    /**
	 * @constructor
	 * @class LayoutUnit
	 * @extends YAHOO.util.Element
	 * @description
	 *          <p>
	 *          Provides a fixed position unit containing a header, body and
	 *          footer for use with a YAHOO.widget.Layout instance.
	 *          </p>
	 * @param {String/HTMLElement}
	 *            el The element to make a unit.
	 * @param {Object}
	 *            attrs Object liternal containing configuration parameters.
	 */

    var LayoutUnit = function(el, config) {
        
        var oConfig = {
            element: el,
            attributes: config || {}
        };

        LayoutUnit.superclass.constructor.call(this, oConfig.element, oConfig.attributes);    
    };

    /**
	 * @private
	 * @static
	 * @property _instances
	 * @description Internal hash table for all layout unit instances
	 * @type Object
	 */ 
    LayoutUnit._instances = {};
    /**
	 * @static
	 * @method getLayoutUnitById
	 * @description Get's a layout unit object by the HTML id of the element
	 *              associated with the Layout Unit object.
	 * @return {Object} The Layout Object
	 */ 
    LayoutUnit.getLayoutUnitById = function(id) {
        if (LayoutUnit._instances[id]) {
            return LayoutUnit._instances[id];
        }
        return false;
    };

    YAHOO.extend(LayoutUnit, YAHOO.util.Element, {
        /**
		 * @property STR_CLOSE
		 * @description String used for close button title
		 * @type {String}
		 */
        STR_CLOSE: 'Click to close this pane.',
        /**
		 * @property STR_COLLAPSE
		 * @description String used for collapse button title
		 * @type {String}
		 */
        STR_COLLAPSE: 'Click to collapse this pane.',
        /**
		 * @property STR_EXPAND
		 * @description String used for expand button title
		 * @type {String}
		 */
        STR_EXPAND: 'Click to expand this pane.',
        /**
		 * The class name applied to dynamic tabs while loading.
		 * 
		 * @property LOADING_CLASSNAME
		 * @type String
		 * @default "disabled"
		 */
	    LOADING_CLASSNAME: 'loading',
        /**
		 * @property browser
		 * @description A modified version of the YAHOO.env.ua object
		 * @type Object
		 */
        browser: null,
        /**
		 * @private
		 * @property _sizes
		 * @description A collection of the current sizes of the contents of
		 *              this Layout Unit
		 * @type Object
		 */
        _sizes: null,
        /**
		 * @private
		 * @property _anim
		 * @description A reference to the Animation instance used by this
		 *              LayouUnit
		 * @type YAHOO.util.Anim
		 */
        _anim: null,
        /**
		 * @private
		 * @property _resize
		 * @description A reference to the Resize instance used by this
		 *              LayoutUnit
		 * @type YAHOO.util.Resize
		 */
        _resize: null,
        /**
		 * @private
		 * @property _clip
		 * @description A reference to the clip element used when collapsing the
		 *              unit
		 * @type HTMLElement
		 */
        _clip: null,
        /**
		 * @private
		 * @property _gutter
		 * @description A simple hash table used to store the gutter to apply to
		 *              the Unit
		 * @type Object
		 */
        _gutter: null,
        /**
		 * @property header
		 * @description A reference to the HTML element used for the Header
		 * @type HTMLELement
		 */
        header: null,
        /**
		 * @property body
		 * @description A reference to the HTML element used for the body
		 * @type HTMLElement
		 */
        body: null,
        /**
		 * @property footer
		 * @description A reference to the HTML element used for the footer
		 * @type HTMLElement
		 */
        footer: null,
        /**
		 * @private
		 * @property _collapsed
		 * @description Flag to determine if the unit is collapsed or not.
		 * @type Boolean
		 */
        _collapsed: null,
        /**
		 * @private
		 * @property _collapsing
		 * @description A flag set while the unit is being collapsed, used so we
		 *              don't fire events while animating the size
		 * @type Boolean
		 */
        _collapsing: null,
        /**
		 * @private
		 * @property _lastWidth
		 * @description A holder for the last known width of the unit
		 * @type Number
		 */
        _lastWidth: null,
        /**
		 * @private
		 * @property _lastHeight
		 * @description A holder for the last known height of the unit
		 * @type Number
		 */
        _lastHeight: null,
        /**
		 * @private
		 * @property _lastTop
		 * @description A holder for the last known top of the unit
		 * @type Number
		 */
        _lastTop: null,
        /**
		 * @private
		 * @property _lastLeft
		 * @description A holder for the last known left of the unit
		 * @type Number
		 */
        _lastLeft: null,
        /**
		 * @private
		 * @property _lastScroll
		 * @description A holder for the last known scroll state of the unit
		 * @type Boolean
		 */
        _lastScroll: null,
        /**
		 * @private
		 * @property _lastCenetrScroll
		 * @description A holder for the last known scroll state of the center
		 *              unit
		 * @type Boolean
		 */
        _lastCenterScroll: null,
        /**
		 * @private
		 * @property _lastScrollTop
		 * @description A holder for the last known scrollTop state of the unit
		 * @type Number
		 */
        _lastScrollTop: null,
        /**
		 * @method resize
		 * @description Resize either the unit or it's clipped state, also
		 *              updating the box inside
		 * @param {Boolean}
		 *            force This will force full calculations even when the unit
		 *            is collapsed
		 * @return {<a
		 *         href="YAHOO.widget.LayoutUnit.html">YAHOO.widget.LayoutUnit</a>}
		 *         The LayoutUnit instance
		 */
        resize: function(force) {
            var retVal = this.fireEvent('beforeResize');
            if (retVal === false) {
                return this;
            }
            if (!this._collapsing || (force === true)) {
                var scroll = this.get('scroll');
                this.set('scroll', false);


                var hd = this._getBoxSize(this.header),
                    ft = this._getBoxSize(this.footer),
                    box = [this.get('height'), this.get('width')];

                var nh = (box[0] - hd[0] - ft[0]) - (this._gutter.top + this._gutter.bottom),
                    nw = box[1] - (this._gutter.left + this._gutter.right);

                var wrapH = (nh + (hd[0] + ft[0])),
                    wrapW = nw;

                if (this._collapsed && !this._collapsing) {
                    this._setHeight(this._clip, wrapH);
                    this._setWidth(this._clip, wrapW);
                    Dom.setStyle(this._clip, 'top', this.get('top') + this._gutter.top + 'px');
                    Dom.setStyle(this._clip, 'left', this.get('left') + this._gutter.left + 'px');
                } else if (!this._collapsed || (this._collapsed && this._collapsing)) {
                    wrapH = this._setHeight(this.get('wrap'), wrapH);
                    wrapW = this._setWidth(this.get('wrap'), wrapW);
                    this._sizes.wrap.h = wrapH;
                    this._sizes.wrap.w = wrapW;

                    Dom.setStyle(this.get('wrap'), 'top', this._gutter.top + 'px');
                    Dom.setStyle(this.get('wrap'), 'left', this._gutter.left + 'px');

                    this._sizes.header.w = this._setWidth(this.header, wrapW);
                    this._sizes.header.h = hd[0];

                    this._sizes.footer.w = this._setWidth(this.footer, wrapW);
                    this._sizes.footer.h = ft[0];

                    Dom.setStyle(this.footer, 'bottom', '0px');

                    this._sizes.body.h = this._setHeight(this.body, (wrapH - (hd[0] + ft[0])));
                    this._sizes.body.w =this._setWidth(this.body, wrapW);
                    Dom.setStyle(this.body, 'top', hd[0] + 'px');

                    this.set('scroll', scroll);
                    this.fireEvent('resize');
                }
            }
            return this;
        },
        /**
		 * @private
		 * @method _setWidth
		 * @description Sets the width of the element based on the border size
		 *              of the element.
		 * @param {HTMLElement}
		 *            el The HTMLElement to have it's width set
		 * @param {Number}
		 *            w The width that you want it the element set to
		 * @return {Number} The new width, fixed for borders and IE QuirksMode
		 */
        _setWidth: function(el, w) {
            if (el) {
                var b = this._getBorderSizes(el);
                w = (w - (b[1] + b[3]));
                w = this._fixQuirks(el, w, 'w');
                if (w < 0) {
                    w = 0;
                }
                Dom.setStyle(el, 'width', w + 'px');
            }
            return w;
        },
        /**
		 * @private
		 * @method _setHeight
		 * @description Sets the height of the element based on the border size
		 *              of the element.
		 * @param {HTMLElement}
		 *            el The HTMLElement to have it's height set
		 * @param {Number}
		 *            h The height that you want it the element set to
		 * @return {Number} The new height, fixed for borders and IE QuirksMode
		 */
        _setHeight: function(el, h) {
            if (el) {
                var b = this._getBorderSizes(el);
                h = (h - (b[0] + b[2]));
                h = this._fixQuirks(el, h, 'h');
                if (h < 0) {
                    h = 0;
                }
                Dom.setStyle(el, 'height', h + 'px');
            }
            return h;
        },
        /**
		 * @private
		 * @method _fixQuirks
		 * @description Fixes the box calculations for IE in QuirksMode
		 * @param {HTMLElement}
		 *            el The HTMLElement to set the dimension on
		 * @param {Number}
		 *            dim The number of the dimension to fix
		 * @param {String}
		 *            side The dimension (h or w) to fix. Defaults to h
		 * @return {Number} The fixed dimension
		 */
        _fixQuirks: function(el, dim, side) {
            var i1 = 0, i2 = 2;
            if (side == 'w') {
                i1 = 1;
                i2 = 3;
            }
            if ((this.browser.ie < 8) && !this.browser.standardsMode) {
                // Internet Explorer - Quirks Mode
                var b = this._getBorderSizes(el),
                    bp = this._getBorderSizes(el.parentNode);
                if ((b[i1] === 0) && (b[i2] === 0)) { // No Borders, check
														// parent
                    if ((bp[i1] !== 0) && (bp[i2] !== 0)) { // Parent has
															// Borders
                        dim = (dim - (bp[i1] + bp[i2]));
                    }
                } else {
                    if ((bp[i1] === 0) && (bp[i2] === 0)) {
                        dim = (dim + (b[i1] + b[i2]));
                    }
                }
            }
            return dim;
        },
        /**
		 * @private
		 * @method _getBoxSize
		 * @description Get's the elements clientHeight and clientWidth plus the
		 *              size of the borders
		 * @param {HTMLElement}
		 *            el The HTMLElement to get the size of
		 * @return {Array} An array of height and width
		 */
        _getBoxSize: function(el) {
            var size = [0, 0];
            if (el) {
                if (this.browser.ie && !this.browser.standardsMode) {
                    el.style.zoom = 1;
                }
                var b = this._getBorderSizes(el);
                size[0] = el.clientHeight + (b[0] + b[2]);
                size[1] = el.clientWidth + (b[1] + b[3]);
            }
            return size;
        },
        /**
		 * @private
		 * @method _getBorderSizes
		 * @description Get the CSS border size of the element passed.
		 * @param {HTMLElement}
		 *            el The element to get the border size of
		 * @return {Array} An array of the top, right, bottom, left borders.
		 */
        _getBorderSizes: function(el) {
            var s = [];
            el = el || this.get('element');
            if (this.browser.ie && !this.browser.standardsMode) {
                el.style.zoom = 1;
            }
            s[0] = parseInt(Dom.getStyle(el, 'borderTopWidth'), 10);
            s[1] = parseInt(Dom.getStyle(el, 'borderRightWidth'), 10);
            s[2] = parseInt(Dom.getStyle(el, 'borderBottomWidth'), 10);
            s[3] = parseInt(Dom.getStyle(el, 'borderLeftWidth'), 10);
            
            // IE will return NaN on these if they are set to auto, we'll set
			// them to 0
            for (var i = 0; i < s.length; i++) {
                if (isNaN(s[i])) {
                    s[i] = 0;
                }
            }
            return s;
        },
        /**
		 * @private
		 * @method _createClip
		 * @description Create the clip element used when the Unit is collapsed
		 */
        _createClip: function() {
            if (!this._clip) {
                this._clip = document.createElement('div');
                this._clip.className = 'yui-layout-clip yui-layout-clip-' + this.get('position');
                this._clip.innerHTML = '<div class="collapse"></div>';
                var c = this._clip.firstChild;
                c.title = this.STR_EXPAND;
                Event.on(c, 'click', this.expand, this, true);
                this.get('element').parentNode.appendChild(this._clip);
            }
        },
        /**
		 * @private
		 * @method _toggleClip
		 * @description Toggle th current state of the Clip element and set it's
		 *              height, width and position
		 */
        _toggleClip: function() {
            if (!this._collapsed) {
                // show
                var hd = this._getBoxSize(this.header),
                    ft = this._getBoxSize(this.footer),
                    box = [this.get('height'), this.get('width')];


                var nh = (box[0] - hd[0] - ft[0]) - (this._gutter.top + this._gutter.bottom),
                    nw = box[1] - (this._gutter.left + this._gutter.right),
                    wrapH = (nh + (hd[0] + ft[0]));

                switch (this.get('position')) {
                    case 'top':
                    case 'bottom':
                        this._setWidth(this._clip, nw);
                        this._setHeight(this._clip, this.get('collapseSize'));
                        Dom.setStyle(this._clip, 'left', (this._lastLeft + this._gutter.left) + 'px');
                        if (this.get('position') == 'bottom') {
                            Dom.setStyle(this._clip, 'top', ((this._lastTop + this._lastHeight) - (this.get('collapseSize') - this._gutter.top)) + 'px');
                        } else {
                            Dom.setStyle(this._clip, 'top', this.get('top') + this._gutter.top + 'px');
                        }
                        break;
                    case 'left':
                    case 'right':
                        this._setWidth(this._clip, this.get('collapseSize'));
                        this._setHeight(this._clip, wrapH);
                        Dom.setStyle(this._clip, 'top', (this.get('top') + this._gutter.top) + 'px');
                        if (this.get('position') == 'right') {
                            Dom.setStyle(this._clip, 'left', (((this._lastLeft + this._lastWidth) - this.get('collapseSize')) - this._gutter.left) + 'px');
                        } else {
                            Dom.setStyle(this._clip, 'left', (this.get('left') + this._gutter.left) + 'px');
                        }
                        break;
                }

                Dom.setStyle(this._clip, 'display', 'block');
                this.setStyle('display', 'none');
            } else {
                // Hide
                Dom.setStyle(this._clip, 'display', 'none');
            }
        },
        /**
		 * @method getSizes
		 * @description Get a reference to the internal sizes object for this
		 *              unit
		 * @return {Object} An object of the sizes used for calculations
		 */
        getSizes: function() {
            return this._sizes;
        },
        /**
		 * @method toggle
		 * @description Toggles the Unit, replacing it with a clipped version.
		 * @return {<a
		 *         href="YAHOO.widget.LayoutUnit.html">YAHOO.widget.LayoutUnit</a>}
		 *         The LayoutUnit instance
		 */
        toggle: function() {
            if (this._collapsed) {
                this.expand();
            } else {
                this.collapse();
            }
            return this;
        },
        /**
		 * @method expand
		 * @description Expand the Unit if it is collapsed.
		 * @return {<a
		 *         href="YAHOO.widget.LayoutUnit.html">YAHOO.widget.LayoutUnit</a>}
		 *         The LayoutUnit instance
		 */
        expand: function() {
            if (!this._collapsed) {
                return this;
            }
            var retVal = this.fireEvent('beforeExpand');
            if (retVal === false) {
                return this;
            }

            this._collapsing = true;
            this.setStyle('zIndex', this._zIndex);

            if (this._anim) {
                this.setStyle('display', 'none');
                var attr = {}, s;

                switch (this.get('position')) {
                    case 'left':
                    case 'right':
                        this.set('width', this._lastWidth, true);
                        this.setStyle('width', this._lastWidth + 'px');
                        this.get('parent').resize(false);
                        s = this.get('parent').getSizes()[this.get('position')];
                        this.set('height', s.h, true);
                        var left = s.l;
                        attr = {
                            left: {
                                to: left
                            }
                        };
                        if (this.get('position') == 'left') {
                            attr.left.from = (left - s.w);
                            this.setStyle('left', (left - s.w) + 'px');
                        }
                        break;
                    case 'top':
                    case 'bottom':
                        this.set('height', this._lastHeight, true);
                        this.setStyle('height', this._lastHeight + 'px');
                        this.get('parent').resize(false);
                        s = this.get('parent').getSizes()[this.get('position')];
                        this.set('width', s.w, true);
                        var top = s.t;
                        attr = {
                            top: {
                                to: top
                            }
                        };
                        if (this.get('position') == 'top') {
                            this.setStyle('top',  (top - s.h) + 'px');
                            attr.top.from = (top - s.h);
                        }
                        break;
                }

                this._anim.attributes = attr;
                var exStart = function() {
                    this.setStyle('display', 'block');
                    this.resize(true);
                    this._anim.onStart.unsubscribe(exStart, this, true);
                };
                var expand = function() {
                    this._collapsing = false;
                    this.setStyle('zIndex', this._zIndex);
                    this.set('width', this._lastWidth);
                    this.set('height', this._lastHeight);
                    this._collapsed = false;
                    this.resize();
                    this.set('scroll', this._lastScroll);
                    if (this._lastScrollTop > 0) {
                        this.body.scrollTop = this._lastScrollTop;
                    }
                    this._anim.onComplete.unsubscribe(expand, this, true);
                    this.fireEvent('expand');
                };
                this._anim.onStart.subscribe(exStart, this, true);
                this._anim.onComplete.subscribe(expand, this, true);
                this._anim.animate();
                this._toggleClip();
            } else {
                this._collapsing = false;
                this._toggleClip();
                this._collapsed = false;
                this._zIndex = this.getStyle('zIndex');
                this.setStyle('zIndex', this.get('parent')._zIndex);
                this.setStyle('display', 'block');
                this.set('width', this._lastWidth);
                this.set('height', this._lastHeight);
                this.resize();
                this.set('scroll', this._lastScroll);
                if (this._lastScrollTop > 0) {
                    this.body.scrollTop = this._lastScrollTop;
                }
                this.fireEvent('expand');
            }
            return this;
        },
        /**
		 * @method collapse
		 * @description Collapse the Unit if it is not collapsed.
		 * @return {<a
		 *         href="YAHOO.widget.LayoutUnit.html">YAHOO.widget.LayoutUnit</a>}
		 *         The LayoutUnit instance
		 */
        collapse: function() {
            if (this._collapsed) {
                return this;
            }
            var retValue = this.fireEvent('beforeCollapse');
            if (retValue === false) {
                return this;
            }
            if (!this._clip) {
                this._createClip();
            }
            this._collapsing = true;
            var w = this.get('width'),
                h = this.get('height'),
                attr = {};
            this._lastWidth = w;
            this._lastHeight = h;
            this._lastScroll = this.get('scroll');
            this._lastScrollTop = this.body.scrollTop;            
            this.set('scroll', false, true);
            this._lastLeft = parseInt(this.get('element').style.left, 10);
            this._lastTop = parseInt(this.get('element').style.top, 10);
            if (isNaN(this._lastTop)) {
                this._lastTop = 0;
                this.set('top', 0);
            }
            if (isNaN(this._lastLeft)) {
                this._lastLeft = 0;
                this.set('left', 0);
            }
            this._zIndex = this.getStyle('zIndex');
            this.setStyle('zIndex', this.get('parent')._zIndex + 1);
            var pos = this.get('position');

            switch (pos) {
                case 'top':
                case 'bottom':
                    this.set('height', (this.get('collapseSize') + (this._gutter.top + this._gutter.bottom)));
                    attr = {
                        top: {
                            to: (this.get('top') - h)
                        }
                    };
                    if (pos == 'bottom') {
                        attr.top.to = (this.get('top') + h);
                    }
                    break;
                case 'left':
                case 'right':
                    this.set('width', (this.get('collapseSize') + (this._gutter.left + this._gutter.right)));
                    attr = {
                        left: {
                            to: -(this._lastWidth)
                        }
                    };
                    if (pos == 'right') {
                        attr.left = {
                            to: (this.get('left') + w)
                        };
                    }
                    break;
            }
            if (this._anim) {
                this._anim.attributes = attr;
                var collapse = function() {
                    this._collapsing = false;
                    this._toggleClip();
                    this.setStyle('zIndex', this.get('parent')._zIndex);
                    this._collapsed = true;
                    this.get('parent').resize();
                    this._anim.onComplete.unsubscribe(collapse, this, true);
                    this.fireEvent('collapse');
                };
                this._anim.onComplete.subscribe(collapse, this, true);
                this._anim.animate();
            } else {
                this._collapsing = false;
                this.setStyle('display', 'none');
                this._toggleClip();
                this.setStyle('zIndex', this.get('parent')._zIndex);
                this.get('parent').resize();
                this._collapsed = true;
                this.fireEvent('collapse');
            }
            return this;
        },
        /**
		 * @method close
		 * @description Close the unit, removing it from the parent Layout.
		 * @return {<a href="YAHOO.widget.Layout.html">YAHOO.widget.Layout</a>}
		 *         The parent Layout instance
		 */
        close: function() {
            this.setStyle('display', 'none');
            this.get('parent').removeUnit(this);
            this.fireEvent('close');
            if (this._clip) {
                this._clip.parentNode.removeChild(this._clip);
                this._clip = null;
            }
            return this.get('parent');
        },
		/**
		 * @property loadHandler
		 * @description Callback method for the YUI Connection Manager used for
		 *              load the body using AJAX. NOTE: e.responseText is loaded
		 *              via innerHTML.
		 * @type Object
		 */
		loadHandler: {
            success: function(o) {
				this.body.innerHTML = o.responseText;
				this.resize (true);
            },
            failure: function(o) {
            }
        },
		/**
		 * @property dataConnection
		 * @description YUI Connection Manager handler
		 * @type Object
		 */
		dataConnection: null,
		/**
		 * @private
		 * @property _loading
		 * @description During the loading process this variable will be true
		 * @type Number
		 */
        _loading: false,
		/**
		 * @method loadContent
		 * @description Loading the content of the unit using the connection
		 *              manager
		 * @return {object} YUI Connection Manager handler
		 */
        loadContent: function() {
			// load dynamic content unless already loading or loaded and caching
			if (YAHOO.util.Connect && this.get('dataSrc') && !this._loading && !this.get('dataLoaded')) {
		        this._loading = true; 
		        Dom.addClass(this.body, this.LOADING_CLASSNAME);
				this.dataConnection = YAHOO.util.Connect.asyncRequest(
		            this.get('loadMethod'),
		            this.get('dataSrc'), 
		            {
		                success: function(o) {
		                    this.loadHandler.success.call(this, o);
		                    this.set('dataLoaded', true);
		                    this.dataConnection = null;
		                    Dom.removeClass(this.body, this.LOADING_CLASSNAME);
							this._loading = false;
							this.fireEvent('load');
		                },
		                failure: function(o) {
		                    this.loadHandler.failure.call(this, o);
		                    this.dataConnection = null;
		                    Dom.removeClass(this.body, this.LOADING_CLASSNAME);
		                    this._loading = false;
							this.fireEvent('loadError', { error: o });
		                },
		                scope: this,
		                timeout: this.get('dataTimeout')
		            }
		        );
				return this.dataConnection;
	        }
			return false;
        },
        /**
		 * @private
		 * @method init
		 * @description The initalization method inherited from Element.
		 */
        init: function(p_oElement, p_oAttributes) {
            this._gutter = {
                left: 0,
                right: 0,
                top: 0,
                bottom: 0
            };
            this._sizes = {
                wrap: {
                    h: 0,
                    w: 0
                },
                header: {
                    h: 0,
                    w: 0
                },
                body: {
                    h: 0,
                    w: 0
                },
                footer: {
                    h: 0,
                    w: 0
                }
            };
            
            LayoutUnit.superclass.init.call(this, p_oElement, p_oAttributes);

            this.browser = this.get('parent').browser;
            
            var id = p_oElement;
            if (!Lang.isString(id)) {
                id = Dom.generateId(id);
            }
            LayoutUnit._instances[id] = this;

            this.setStyle('position', 'absolute');

            this.addClass('yui-layout-unit');
            this.addClass('yui-layout-unit-' + this.get('position'));


            var header = this.getElementsByClassName('yui-layout-hd', 'div')[0];
            if (header) {
                this.header = header;
            }
            var body = this.getElementsByClassName('yui-layout-bd', 'div')[0];
            if (body) {
                this.body = body;
            }
            var footer = this.getElementsByClassName('yui-layout-ft', 'div')[0];
            if (footer) {
                this.footer = footer;
            }

            this.on('contentChange', this.resize, this, true);
            this._lastScrollTop = 0;

            this.set('animate', this.get('animate'));
        },
        /**
		 * @private
		 * @method initAttributes
		 * @description Processes the config
		 */        
        initAttributes: function(attr) {
            LayoutUnit.superclass.initAttributes.call(this, attr);

            /**
			 * @private
			 * @attribute wrap
			 * @description A reference to the wrap element
			 * @type HTMLElement
			 */
            this.setAttributeConfig('wrap', {
                value: attr.wrap || null,
                method: function(w) {
                    if (w) {
                        var id = Dom.generateId(w);
                        LayoutUnit._instances[id] = this;
                    }
                }
            });
            /**
			 * @attribute grids
			 * @description Set this option to true if you want the LayoutUnit
			 *              to fix the first layer of YUI CSS Grids (margins)
			 * @type Boolean
			 */
            this.setAttributeConfig('grids', {
                value: attr.grids || false
            });
            /**
			 * @private
			 * @attribute top
			 * @description The current top positioning of the Unit
			 * @type Number
			 */
            this.setAttributeConfig('top', {
                value: attr.top || 0,
                validator: Lang.isNumber,
                method: function(t) {
                    if (!this._collapsing) {
                        this.setStyle('top', t + 'px');
                    }
                }
            });
            /**
			 * @private
			 * @attribute left
			 * @description The current left position of the Unit
			 * @type Number
			 */
            this.setAttributeConfig('left', {
                value: attr.left || 0,
                validator: Lang.isNumber,
                method: function(l) {
                    if (!this._collapsing) {
                        this.setStyle('left', l + 'px');
                    }
                }
            });

            /**
			 * @attribute minWidth
			 * @description The minWidth parameter passed to the Resize Utility
			 * @type Number
			 */
            this.setAttributeConfig('minWidth', {
                value: attr.minWidth || false,
                method: function(v) {
                    if (this._resize) {
                        this._resize.set('minWidth', v);
                    }
                },
                validator: YAHOO.lang.isNumber
            });

            /**
			 * @attribute maxWidth
			 * @description The maxWidth parameter passed to the Resize Utility
			 * @type Number
			 */
            this.setAttributeConfig('maxWidth', {
                value: attr.maxWidth || false,
                method: function(v) {
                    if (this._resize) {
                        this._resize.set('maxWidth', v);
                    }
                },
                validator: YAHOO.lang.isNumber
            });

            /**
			 * @attribute minHeight
			 * @description The minHeight parameter passed to the Resize Utility
			 * @type Number
			 */
            this.setAttributeConfig('minHeight', {
                value: attr.minHeight || false,
                method: function(v) {
                    if (this._resize) {
                        this._resize.set('minHeight', v);
                    }
                },
                validator: YAHOO.lang.isNumber
            });

            /**
			 * @attribute maxHeight
			 * @description The maxHeight parameter passed to the Resize Utility
			 * @type Number
			 */
            this.setAttributeConfig('maxHeight', {
                value: attr.maxHeight || false,
                method: function(v) {
                    if (this._resize) {
                        this._resize.set('maxHeight', v);
                    }
                },
                validator: YAHOO.lang.isNumber
            });

            /**
			 * @attribute height
			 * @description The height of the Unit
			 * @type Number
			 */
            this.setAttributeConfig('height', {
                value: attr.height,
                validator: Lang.isNumber,
                method: function(h) {
                    if (!this._collapsing) {
                        if (h < 0) {
                            h = 0;
                        }
                        this.setStyle('height', h + 'px');
                    }
                }
            });

            /**
			 * @attribute width
			 * @description The width of the Unit
			 * @type Number
			 */
            this.setAttributeConfig('width', {
                value: attr.width,
                validator: Lang.isNumber,
                method: function(w) {
                    if (!this._collapsing) {
                        if (w < 0) {
                            w = 0;
                        }
                        this.setStyle('width', w + 'px');
                    }
                }
            });
            /**
			 * @attribute zIndex
			 * @description The CSS zIndex to give to the unit, so you can have
			 *              overlapping elements such as menus in a unit.
			 * @type {Number}
			 */
            this.setAttributeConfig('zIndex', {
                value: attr.zIndex || false,
                method: function(z) {
                    this.setStyle('zIndex', z);
                }
            });
            /**
			 * @attribute position
			 * @description The position (top, right, bottom, left or center) of
			 *              the Unit in the Layout
			 * @type {String}
			 */
            this.setAttributeConfig('position', {
                value: attr.position
            });
            /**
			 * @attribute gutter
			 * @description The gutter that we should apply to the parent Layout
			 *              around this Unit. Supports standard CSS markup: (2 4
			 *              0 5) or (2) or (2 5)
			 * @type String
			 */
            this.setAttributeConfig('gutter', {
                value: attr.gutter || 0,
                validator: YAHOO.lang.isString,
                method: function(gutter) {
                    var p = gutter.split(' ');
                    if (p.length) {
                        this._gutter.top = parseInt(p[0], 10);
                        if (p[1]) {
                            this._gutter.right = parseInt(p[1], 10);
                        } else {
                            this._gutter.right = this._gutter.top;
                        }
                        if (p[2]) {
                            this._gutter.bottom = parseInt(p[2], 10);
                        } else {
                            this._gutter.bottom = this._gutter.top;
                        }
                        if (p[3]) {
                            this._gutter.left = parseInt(p[3], 10);
                        } else if (p[1]) {
                            this._gutter.left = this._gutter.right;
                        } else {
                            this._gutter.left = this._gutter.top;
                        }
                    }
                }
            });
            /**
			 * @attribute parent
			 * @description The parent Layout that we are assigned to
			 * @type {Object} YAHOO.widget.Layout
			 */
            this.setAttributeConfig('parent', {
                writeOnce: true,
                value: attr.parent || false,
                method: function(p) {
                    if (p) {
                        p.on('resize', this.resize, this, true);
                    }

                }
            });
            /**
			 * @attribute collapseSize
			 * @description The pixel size of the Clip that we will collapse to
			 * @type Number
			 */
            this.setAttributeConfig('collapseSize', {
                value: attr.collapseSize || 25,
                validator: YAHOO.lang.isNumber
            });
            /**
			 * @attribute duration
			 * @description The duration to give the Animation Utility when
			 *              animating the opening and closing of Units
			 */
            this.setAttributeConfig('duration', {
                value: attr.duration || 0.5
            });
            /**
			 * @attribute easing
			 * @description The Animation Easing to apply to the Animation
			 *              instance for this unit.
			 */
            this.setAttributeConfig('easing', {
                value: attr.easing || ((YAHOO.util && YAHOO.util.Easing) ? YAHOO.util.Easing.BounceIn : 'false')
            });
            /**
			 * @attribute animate
			 * @description Use animation to collapse/expand the unit
			 * @type Boolean
			 */
            this.setAttributeConfig('animate', {
                value: ((attr.animate === false) ? false : true),
                validator: function() {
                    var anim = false;
                    if (YAHOO.util.Anim) {
                        anim = true;
                    }
                    return anim;
                },
                method: function(anim) {
                    if (anim) {
                        this._anim = new YAHOO.util.Anim(this.get('element'), {}, this.get('duration'), this.get('easing'));
                    } else {
                        this._anim = false;
                    }
                }
            });
            /**
			 * @attribute header
			 * @description The html to use as the Header of the Unit (sets via
			 *              innerHTML)
			 * @type {HTML}
			 */
            this.setAttributeConfig('header', {
                value: attr.header || false,
                method: function(txt) {
                    if (txt === false) {
                        // Remove the footer
                        if (this.header) {
                            Dom.addClass(this.body, 'yui-layout-bd-nohd');
                            this.header.parentNode.removeChild(this.header);
                            this.header = null;
                        }
                    } else {
                        if (!this.header) {
                            var header = this.getElementsByClassName('yui-layout-hd', 'div')[0];
                            if (!header) {
                                header = this._createHeader();
                            }
                            this.header = header;
                        }
                        var h = this.header.getElementsByTagName('h2')[0];
                        if (!h) {
                            h = document.createElement('h2');
                            this.header.appendChild(h);
                        }
                        h.innerHTML = txt;
                        if (this.body) {
                            Dom.removeClass(this.body, 'yui-layout-bd-nohd');
                        }
                    }
                    this.fireEvent('contentChange', { target: 'header' });
                }
            });
            /**
			 * @attribute proxy
			 * @description Use the proxy config setting for the Resize Utility
			 * @type Boolean
			 */
            this.setAttributeConfig('proxy', {
                writeOnce: true,
                value: ((attr.proxy === false) ? false : true)
            });
            /**
			 * @attribute body
			 * @description The content for the body. If we find an element in
			 *              the page with an id that matches the passed option
			 *              we will move that element into the body of this
			 *              unit. (sets via innerHTML)
			 * @type {HTML}
			 */
            this.setAttributeConfig('body', {
                value: attr.body || false,
                method: function(content) {
                    if (!this.body) {
                        var body = this.getElementsByClassName('yui-layout-bd', 'div')[0];
                        if (body) {
                            this.body = body;
                        } else {
                            body = document.createElement('div');
                            body.className = 'yui-layout-bd';
                            this.body = body;
                            this.get('wrap').appendChild(body);
                        }
                    }
                    if (!this.header) {
                        Dom.addClass(this.body, 'yui-layout-bd-nohd');
                    }
                    Dom.addClass(this.body, 'yui-layout-bd-noft');


                    var el = null;
                    if (Lang.isString(content)) {
                        el = Dom.get(content);
                    } else if (content && content.tagName) {
                        el = content;
                    }
                    if (el) {
                        var id = Dom.generateId(el);
                        LayoutUnit._instances[id] = this;
                        this.body.appendChild(el);
                    } else {
                        this.body.innerHTML = content;
                    }

                    this._cleanGrids();

                    this.fireEvent('contentChange', { target: 'body' });
                }
            });

            /**
			 * @attribute footer
			 * @description The content for the footer. If we find an element in
			 *              the page with an id that matches the passed option
			 *              we will move that element into the footer of this
			 *              unit. (sets via innerHTML)
			 * @type {HTML}
			 */
            this.setAttributeConfig('footer', {
                value: attr.footer || false,
                method: function(content) {
                    if (content === false) {
                        // Remove the footer
                        if (this.footer) {
                            Dom.addClass(this.body, 'yui-layout-bd-noft');
                            this.footer.parentNode.removeChild(this.footer);
                            this.footer = null;
                        }
                    } else {
                        if (!this.footer) {
                            var ft = this.getElementsByClassName('yui-layout-ft', 'div')[0];
                            if (!ft) {
                                ft = document.createElement('div');
                                ft.className = 'yui-layout-ft';
                                this.footer = ft;
                                this.get('wrap').appendChild(ft);
                            } else {
                                this.footer = ft;
                            }
                        }
                        var el = null;
                        if (Lang.isString(content)) {
                            el = Dom.get(content);
                        } else if (content && content.tagName) {
                            el = content;
                        }
                        if (el) {
                            this.footer.appendChild(el);
                        } else {
                            this.footer.innerHTML = content;
                        }
                        Dom.removeClass(this.body, 'yui-layout-bd-noft');
                    }
                    this.fireEvent('contentChange', { target: 'footer' });
                }
            });
            /**
			 * @attribute close
			 * @description Adds a close icon to the unit
			 */
            this.setAttributeConfig('close', {
                value: attr.close || false,
                method: function(close) {
                    // Position Center doesn't get this
                    if (this.get('position') == 'center') {
                        return false;
                    }
                    if (!this.header && close) {
                        this._createHeader();
                    }
                    if (!this.header) {
                        return;
                    }
                    var c = this.header ? Dom.getElementsByClassName('close', 'div', this.header)[0] : null;
                    
                    if (close) {
                        // Force some header text if there isn't any
                        if (!this.get('header')) {
                            this.set('header', '&nbsp;');
                        }
                        if (!c) {
                            c = document.createElement('div');
                            c.className = 'close';
                            this.header.appendChild(c);
                            Event.on(c, 'click', this.close, this, true);
                        }
                        c.title = this.STR_CLOSE;
                    } else if (c && c.parentNode) {
                        Event.purgeElement(c);
                        c.parentNode.removeChild(c);
                    }
                    this._configs.close.value = close;
                    this.set('collapse', this.get('collapse')); // Reset so we
																// get the right
																// classnames
                }
            });

            /**
			 * @attribute collapse
			 * @description Adds a collapse icon to the unit
			 */
            this.setAttributeConfig('collapse', {
                value: attr.collapse || false,
                method: function(collapse) {
                    // Position Center doesn't get this
                    if (this.get('position') == 'center') {
                        return false;
                    }
                    if (!this.header && collapse) {
                        this._createHeader();
                    }
                    if (!this.header) {
                        return;
                    }
                    var c = this.header ? Dom.getElementsByClassName('collapse', 'div', this.header)[0] : null;
                    
                    if (collapse) {
                        // Force some header text if there isn't any
                        if (!this.get('header')) {
                            this.set('header', '&nbsp;');
                        }
                        if (!c) {
                            c = document.createElement('div');
                            this.header.appendChild(c);
                            Event.on(c, 'click', this.collapse, this, true);
                        }
                        c.title = this.STR_COLLAPSE;
                        c.className = 'collapse' + ((this.get('close')) ? ' collapse-close' : '');
                    } else if (c && c.parentNode) {
                        Event.purgeElement(c);
                        c.parentNode.removeChild(c);
                    }
                }
            });
            /**
			 * @attribute scroll
			 * @description Adds a class to the unit to allow for overflow: auto
			 *              (yui-layout-scroll), default is overflow: hidden
			 *              (yui-layout-noscroll). If true scroll bars will be
			 *              placed on the element when the content exceeds the
			 *              given area, false will put overflow hidden to hide
			 *              the content. Passing null will render the content as
			 *              usual overflow.
			 * @type Boolean/Null
			 */

            this.setAttributeConfig('scroll', {
                value: (((attr.scroll === true) || (attr.scroll === false) || (attr.scroll === null)) ? attr.scroll : false),
                method: function(scroll) {
                    if ((scroll === false) && !this._collapsed) { // Removing
																	// scroll
																	// bar
                        if (this.body) {
                            if (this.body.scrollTop > 0) {
                                this._lastScrollTop = this.body.scrollTop;
                            }
                        }
                    }
                    
                    if (scroll === true) {
                        this.addClass('yui-layout-scroll');
                        this.removeClass('yui-layout-noscroll');
                        if (this._lastScrollTop > 0) {
                            if (this.body) {
                                this.body.scrollTop = this._lastScrollTop;
                            }
                        }
                    } else if (scroll === false) {
                        this.removeClass('yui-layout-scroll');
                        this.addClass('yui-layout-noscroll');
                    } else if (scroll === null) {
                        this.removeClass('yui-layout-scroll');
                        this.removeClass('yui-layout-noscroll');
                    }
                }
            });
            /**
			 * @attribute hover
			 * @description Config option to pass to the Resize Utility
			 */
            this.setAttributeConfig('hover', {
                writeOnce: true,
                value: attr.hover || false,
                validator: YAHOO.lang.isBoolean
            });
            /**
			 * @attribute useShim
			 * @description Config option to pass to the Resize Utility
			 */
            this.setAttributeConfig('useShim', {
                value: attr.useShim || false,
                validator: YAHOO.lang.isBoolean,
                method: function(u) {
                    if (this._resize) {
                        this._resize.set('useShim', u);
                    }
                }
            });
            /**
			 * @attribute resize
			 * @description Should a Resize instance be added to this unit
			 */

            this.setAttributeConfig('resize', {
                value: attr.resize || false,
                validator: function(r) {
                    if (YAHOO.util && YAHOO.util.Resize) {
                        return true;
                    }
                    return false;
                },
                method: function(resize) {
                    if (resize && !this._resize) {
                        // Position Center doesn't get this
                        if (this.get('position') == 'center') {
                            return false;
                        }
                        var handle = false; // To catch center
                        switch (this.get('position')) {
                            case 'top':
                                handle = 'b';
                                break;
                            case 'bottom':
                                handle = 't';
                                break;
                            case 'right':
                                handle = 'l';
                                break;
                            case 'left':
                                handle = 'r';
                                break;
                        }

                        this.setStyle('position', 'absolute'); // Make sure
																// Resize get's
																// a position
                        
                        if (handle) {
                            this._resize = new YAHOO.util.Resize(this.get('element'), {
                                proxy: this.get('proxy'),
                                hover: this.get('hover'),
                                status: false,
                                autoRatio: false,
                                handles: [handle],
                                minWidth: this.get('minWidth'),
                                maxWidth: this.get('maxWidth'),
                                minHeight: this.get('minHeight'),
                                maxHeight: this.get('maxHeight'),
                                height: this.get('height'),
                                width: this.get('width'),
                                setSize: false,
                                useShim: this.get('useShim'),
                                wrap: false
                            });
                            
                            this._resize._handles[handle].innerHTML = '<div class="yui-layout-resize-knob"></div>';

                            if (this.get('proxy')) {
                                var proxy = this._resize.getProxyEl();
                                proxy.innerHTML = '<div class="yui-layout-handle-' + handle + '"></div>';
                            }
                            this._resize.on('startResize', function(ev) {
                                this._lastScroll = this.get('scroll');
                                this.set('scroll', false);
                                if (this.get('parent')) {
                                    this.get('parent').fireEvent('startResize');
                                    var c = this.get('parent').getUnitByPosition('center');
                                    this._lastCenterScroll = c.get('scroll');
                                    c.addClass(this._resize.CSS_RESIZING);
                                    c.set('scroll', false);
                                }
                                this.fireEvent('startResize');
                            }, this, true);
                            this._resize.on('resize', function(ev) {
                                this.set('height', ev.height);
                                this.set('width', ev.width);
                            }, this, true);
                            this._resize.on('endResize', function(ev) {
                                this.set('scroll', this._lastScroll);
                                if (this.get('parent')) {
                                    var c = this.get('parent').getUnitByPosition('center');
                                    c.set('scroll', this._lastCenterScroll);
                                    c.removeClass(this._resize.CSS_RESIZING);
                                }
                                this.resize();
                                this.fireEvent('endResize');
                            }, this, true);
                        }
                    } else {
                        if (this._resize) {
                            this._resize.destroy();
                        }
                    }
                }
            });
			/**
			 * The unit data source, used for loading content dynamically.
			 * 
			 * @attribute dataSrc
			 * @type String
			 */
	        this.setAttributeConfig('dataSrc', {
	            value: attr.dataSrc
	        });
	        /**
			 * The method to use for the data request.
			 * 
			 * @attribute loadMethod
			 * @type String
			 * @default "GET"
			 */
	        this.setAttributeConfig('loadMethod', {
	            value: attr.loadMethod || 'GET',
	            validator: YAHOO.lang.isString
	        });	
	        /**
			 * Whether or not any data has been loaded from the server.
			 * 
			 * @attribute dataLoaded
			 * @type Boolean
			 */        
	        this.setAttributeConfig('dataLoaded', {
	            value: false,
	            validator: YAHOO.lang.isBoolean,
	            writeOnce: true
	        });
	        /**
			 * Number if milliseconds before aborting and calling failure
			 * handler.
			 * 
			 * @attribute dataTimeout
			 * @type Number
			 * @default null
			 */
	        this.setAttributeConfig('dataTimeout', {
	            value: attr.dataTimeout || null,
	            validator: YAHOO.lang.isNumber
	        });
        },
        /**
		 * @private
		 * @method _cleanGrids
		 * @description This method attempts to clean up the first level of the
		 *              YUI CSS Grids, YAHOO.util.Selector is required for this
		 *              operation.
		 */
        _cleanGrids: function() {
            if (this.get('grids')) {
                var b = Sel.query('div.yui-b', this.body, true);
                if (b) {
                    Dom.removeClass(b, 'yui-b');
                }
                Event.onAvailable('yui-main', function() {
                    Dom.setStyle(Sel.query('#yui-main'), 'margin-left', '0');
                    Dom.setStyle(Sel.query('#yui-main'), 'margin-right', '0');
                });
            }
        },
        /**
		 * @private
		 * @method _createHeader
		 * @description Creates the HTMLElement for the header
		 * @return {HTMLElement} The new HTMLElement
		 */
        _createHeader: function() {
            var header = document.createElement('div');
            header.className = 'yui-layout-hd';
            if (this.get('firstChild')) {
                this.get('wrap').insertBefore(header, this.get('wrap').firstChild);
            } else {
                this.get('wrap').appendChild(header);
            }
            this.header = header;
            return header;
        },
        /**
		 * @method destroy
		 * @param {Boolean}
		 *            force Don't report to the parent, because we are being
		 *            called from the parent.
		 * @description Removes this unit from the parent and cleans up after
		 *              itself.
		 * @return {<a href="YAHOO.widget.Layout.html">YAHOO.widget.Layout</a>}
		 *         The parent Layout instance
		 */
        destroy: function(force) {
            if (this._resize) {
                this._resize.destroy();
            }
            var par = this.get('parent');

            this.setStyle('display', 'none');
            if (this._clip) {
                this._clip.parentNode.removeChild(this._clip);
                this._clip = null;
            }

            if (!force) {
                par.removeUnit(this);
            }
            
            if (par) {
                par.removeListener('resize', this.resize, this, true);
            }
            this.unsubscribeAll();
            Event.purgeElement(this.get('element'), true);
            this.get('parentNode').removeChild(this.get('element'));

            delete YAHOO.widget.LayoutUnit._instances[this.get('id')];
            // Brutal Object Destroy
            for (var i in this) {
                if (Lang.hasOwnProperty(this, i)) {
                    this[i] = null;
                    delete this[i];
                }
            }
        
            return par;
        },
        /**
		 * @method toString
		 * @description Returns a string representing the LayoutUnit.
		 * @return {String}
		 */        
        toString: function() {
            if (this.get) {
                return 'LayoutUnit #' + this.get('id') + ' (' + this.get('position') + ')';
            }
            return 'LayoutUnit';
        }
    /**
	 * @event resize
	 * @description Fired when this.resize is called
	 * @type YAHOO.util.CustomEvent
	 */
    /**
	 * @event startResize
	 * @description Fired when the Resize Utility fires it's startResize Event.
	 * @type YAHOO.util.CustomEvent
	 */
    /**
	 * @event endResize
	 * @description Fired when the Resize Utility fires it's endResize Event.
	 * @type YAHOO.util.CustomEvent
	 */
    /**
	 * @event beforeResize
	 * @description Fired at the beginning of the resize method. If you return
	 *              false, the resize is cancelled.
	 * @type YAHOO.util.CustomEvent
	 */
    /**
	 * @event contentChange
	 * @description Fired when the content in the header, body or footer is
	 *              changed via the API
	 * @type YAHOO.util.CustomEvent
	 */
    /**
	 * @event close
	 * @description Fired when the unit is closed
	 * @type YAHOO.util.CustomEvent
	 */
    /**
	 * @event beforeCollapse
	 * @description Fired before the unit is collapsed. If you return false, the
	 *              collapse is cancelled.
	 * @type YAHOO.util.CustomEvent
	 */
    /**
	 * @event collapse
	 * @description Fired when the unit is collapsed
	 * @type YAHOO.util.CustomEvent
	 */
    /**
	 * @event expand
	 * @description Fired when the unit is exanded
	 * @type YAHOO.util.CustomEvent
	 */
    /**
	 * @event beforeExpand
	 * @description Fired before the unit is exanded. If you return false, the
	 *              collapse is cancelled.
	 * @type YAHOO.util.CustomEvent
	 */
    /**
	 * @event load
	 * @description Fired when data is loaded via the dataSrc config.
	 * @type YAHOO.util.CustomEvent
	 */
    /**
	 * @event loadError
	 * @description Fired when an error occurs loading data via the dataSrc
	 *              config. Error message is passed as argument to this event.
	 * @type YAHOO.util.CustomEvent
	 */
    });

    YAHOO.widget.LayoutUnit = LayoutUnit;
})();
YAHOO.register("layout", YAHOO.widget.Layout, {version: "2.9.0", build: "2800"});
/*
 * Copyright (c) 2011, Yahoo! Inc. All rights reserved. Code licensed under the
 * BSD License: http://developer.yahoo.com/yui/license.html version: 2.9.0
 */
/**
 * The StyleSheet component is a utility for managing css rules at the
 * stylesheet level
 * 
 * @module stylesheet
 * @namespace YAHOO.util
 * @requires yahoo
 */
(function () {

var d      = document,
    p      = d.createElement('p'), // Have to hold the node (see notes)
    workerStyle = p.style, // worker style collection
    lang   = YAHOO.lang,
    selectors = {},
    sheets = {},
    ssId   = 0,
    floatAttr = ('cssFloat' in workerStyle) ? 'cssFloat' : 'styleFloat',
    _toCssText,
    _unsetOpacity,
    _unsetProperty;

/*
 * Normalizes the removal of an assigned style for opacity. IE uses the filter
 * property.
 */
_unsetOpacity = ('opacity' in workerStyle) ?
    function (style) { style.opacity = ''; } :
    function (style) { style.filter = ''; };
        
/*
 * Normalizes the removal of an assigned style for a given property. Expands
 * shortcut properties if necessary and handles the various names for the float
 * property.
 */
workerStyle.border = "1px solid red";
workerStyle.border = ''; // IE doesn't unset child properties
_unsetProperty = workerStyle.borderLeft ?
    function (style,prop) {
        var p;
        if (prop !== floatAttr && prop.toLowerCase().indexOf('float') != -1) {
            prop = floatAttr;
        }
        if (typeof style[prop] === 'string') {
            switch (prop) {
                case 'opacity':
                case 'filter' : _unsetOpacity(style); break;
                case 'font'   :
                    style.font       = style.fontStyle = style.fontVariant =
                    style.fontWeight = style.fontSize  = style.lineHeight  =
                    style.fontFamily = '';
                    break;
                default       :
                    for (p in style) {
                        if (p.indexOf(prop) === 0) {
                            style[p] = '';
                        }
                    }
            }
        }
    } :
    function (style,prop) {
        if (prop !== floatAttr && prop.toLowerCase().indexOf('float') != -1) {
            prop = floatAttr;
        }
        if (lang.isString(style[prop])) {
            if (prop === 'opacity') {
                _unsetOpacity(style);
            } else {
                style[prop] = '';
            }
        }
    };
    
/**
 * Create an instance of YAHOO.util.StyleSheet to encapsulate a css stylesheet.
 * The constructor can be called using function or constructor syntax.
 * 
 * <pre><code>
 * var sheet = YAHOO.util.StyleSheet(..);
 * </pre></code> or
 * 
 * <pre><code>
 * var sheet = new YAHOO.util.StyleSheet(..);
 * </pre></code>
 * 
 * The first parameter passed can be any of the following things:
 * <ul>
 * <li>The desired string name to register a new empty sheet</li>
 * <li>The string name of an existing YAHOO.util.StyleSheet instance</li>
 * <li>The unique yuiSSID generated for an existing YAHOO.util.StyleSheet
 * instance</li>
 * <li>The id of an existing <code>&lt;link&gt;</code> or
 * <code>&lt;style&gt;</code> node</li>
 * <li>The node reference for an existing <code>&lt;link&gt;</code> or
 * <code>&lt;style&gt;</code> node</li>
 * <li>A chunk of css text to create a new stylesheet from</li>
 * </ul>
 * 
 * <p>
 * If a string is passed, StyleSheet will first look in its static name registry
 * for an existing sheet, then in the DOM for an element with that id. If
 * neither are found and the string contains the { character, it will be used as
 * a the initial cssText for a new StyleSheet. Otherwise, a new empty StyleSheet
 * is created, assigned the string value as a name, and registered statically by
 * that name.
 * </p>
 * 
 * <p>
 * The optional second parameter is a string name to register the sheet as. This
 * param is largely useful when providing a node id/ref or chunk of css text to
 * create a populated instance.
 * </p>
 * 
 * @class StyleSheet
 * @constructor
 * @param seed
 *            {String|&lt;style&gt; element} a style or link node, its id, or a
 *            name or yuiSSID of a StyleSheet, or a string of css text (see
 *            above)
 * @param name
 *            {String} OPTIONAL name to register instance for future static
 *            access
 */
function StyleSheet(seed, name) {
    var head,
        node,
        sheet,
        cssRules = {},
        _rules,
        _insertRule,
        _deleteRule,
        i,r,sel;

    // Factory or constructor
    if (!(this instanceof StyleSheet)) {
        return new StyleSheet(seed,name);
    }

    // capture the DOM node if the string is an id
    node = seed && (seed.nodeName ? seed : d.getElementById(seed));

    // Check for the StyleSheet in the static registry
    if (seed && sheets[seed]) {
        return sheets[seed];
    } else if (node && node.yuiSSID && sheets[node.yuiSSID]) {
        return sheets[node.yuiSSID];
    }

    // Create a style node if necessary
    if (!node || !/^(?:style|link)$/i.test(node.nodeName)) {
        node = d.createElement('style');
        node.type = 'text/css';
    }

    if (lang.isString(seed)) {
        // Create entire sheet from seed cssText
        if (seed.indexOf('{') != -1) {
            // Not a load-time fork because low run-time impact and IE fails
            // test for s.styleSheet at page load time (oddly)
            if (node.styleSheet) {
                node.styleSheet.cssText = seed;
            } else {
                node.appendChild(d.createTextNode(seed));
            }
        } else if (!name) {
            name = seed;
        }
    }

    if (!node.parentNode || node.parentNode.nodeName.toLowerCase() !== 'head') {
        head = (node.ownerDocument || d).getElementsByTagName('head')[0];
        // styleSheet isn't available on the style node in FF2 until appended
        // to the head element. style nodes appended to body do not affect
        // change in Safari.
        head.appendChild(node);
    }

    // Begin setting up private aliases to the important moving parts
    // 1. The stylesheet object
    // IE stores StyleSheet under the "styleSheet" property
    // Safari doesn't populate sheet for xdomain link elements
    sheet = node.sheet || node.styleSheet;

    // 2. The style rules collection
    // IE stores the rules collection under the "rules" property
    _rules = sheet && ('cssRules' in sheet) ? 'cssRules' : 'rules';

    // 3. The method to remove a rule from the stylesheet
    // IE supports removeRule
    _deleteRule = ('deleteRule' in sheet) ?
        function (i) { sheet.deleteRule(i); } :
        function (i) { sheet.removeRule(i); };

    // 4. The method to add a new rule to the stylesheet
    // IE supports addRule with different signature
    _insertRule = ('insertRule' in sheet) ?
        function (sel,css,i) { sheet.insertRule(sel+' {'+css+'}',i); } :
        function (sel,css,i) { sheet.addRule(sel,css,i); };

    // 5. Initialize the cssRules map from the node
    // xdomain link nodes forbid access to the cssRules collection, so this
    // will throw an error.
    // TODO: research alternate stylesheet, @media
    for (i = sheet[_rules].length - 1; i >= 0; --i) {
        r   = sheet[_rules][i];
        sel = r.selectorText;

        if (cssRules[sel]) {
            cssRules[sel].style.cssText += ';' + r.style.cssText;
            _deleteRule(i);
        } else {
            cssRules[sel] = r;
        }
    }

    // Cache the instance by the generated Id
    node.yuiSSID = 'yui-stylesheet-' + (ssId++);
    StyleSheet.register(node.yuiSSID,this);

    // Register the instance by name if provided or defaulted from seed
    if (name) {
        StyleSheet.register(name,this);
    }

    // Public API
    lang.augmentObject(this,{
        /**
		 * Get the unique yuiSSID for this StyleSheet instance
		 * 
		 * @method getId
		 * @return {Number} the static id
		 */
        getId : function () { return node.yuiSSID; },

        /**
		 * The &lt;style&gt; element that this instance encapsulates
		 * 
		 * @property node
		 * @type HTMLElement
		 */
        node : node,

        /**
		 * Enable all the rules in the sheet
		 * 
		 * @method enable
		 * @return {StyleSheet} the instance
		 * @chainable
		 */
        // Enabling/disabling the stylesheet. Changes may be made to rules
        // while disabled.
        enable : function () { sheet.disabled = false; return this; },

        /**
		 * Disable all the rules in the sheet. Rules may be changed while the
		 * StyleSheet is disabled.
		 * 
		 * @method disable
		 * @return {StyleSheet} the instance
		 * @chainable
		 */
        disable : function () { sheet.disabled = true; return this; },

        /**
		 * Returns boolean indicating whether the StyleSheet is enabled
		 * 
		 * @method isEnabled
		 * @return {Boolean} is it enabled?
		 */
        isEnabled : function () { return !sheet.disabled; },

        /**
		 * <p>
		 * Set style properties for a provided selector string. If the selector
		 * includes commas, it will be split into individual selectors and
		 * applied accordingly. If the selector string does not have a
		 * corresponding rule in the sheet, it will be added.
		 * </p>
		 * 
		 * <p>
		 * The second parameter can be either a string of CSS text, formatted as
		 * CSS ("font-size: 10px;"), or an object collection of properties and
		 * their new values. Object properties must be in JavaScript format ({
		 * fontSize: "10px" }).
		 * </p>
		 * 
		 * <p>
		 * The float style property will be set by any of &quot;float&quot;,
		 * &quot;styleFloat&quot;, or &quot;cssFloat&quot; if passed in the
		 * object map. Use "float: left;" format when passing a CSS text string.
		 * </p>
		 * 
		 * @method set
		 * @param sel
		 *            {String} the selector string to apply the changes to
		 * @param css
		 *            {Object|String} Object literal of style properties and new
		 *            values, or a string of cssText
		 * @return {StyleSheet} the StyleSheet instance
		 * @chainable
		 */
        set : function (sel,css) {
            var rule = cssRules[sel],
                multi = sel.split(/\s*,\s*/),i,
                idx;

            // IE's addRule doesn't support multiple comma delimited selectors
            if (multi.length > 1) {
                for (i = multi.length - 1; i >= 0; --i) {
                    this.set(multi[i], css);
                }
                return this;
            }

            // Some selector values can cause IE to hang
            if (!StyleSheet.isValidSelector(sel)) {
                return this;
            }

            // Opera throws an error if there's a syntax error in assigned
            // cssText. Avoid this using a worker style collection, then
            // assigning the resulting cssText.
            if (rule) {
                rule.style.cssText = StyleSheet.toCssText(css,rule.style.cssText);
            } else {
                idx = sheet[_rules].length;
                css = StyleSheet.toCssText(css);

                // IE throws an error when attempting to addRule(sel,'',n)
                // which would crop up if no, or only invalid values are used
                if (css) {
                    _insertRule(sel, css, idx);

                    // Safari replaces the rules collection, but maintains the
                    // rule instances in the new collection when rules are
                    // added/removed
                    cssRules[sel] = sheet[_rules][idx];
                }
            }
            return this;
        },

        /**
		 * <p>
		 * Unset style properties for a provided selector string, removing their
		 * effect from the style cascade.
		 * </p>
		 * 
		 * <p>
		 * If the selector includes commas, it will be split into individual
		 * selectors and applied accordingly. If there are no properties
		 * remaining in the rule after unsetting, the rule is removed.
		 * </p>
		 * 
		 * <p>
		 * The style property or properties in the second parameter must be the
		 * <p>
		 * JavaScript style property names. E.g. fontSize rather than font-size.
		 * </p>
		 * 
		 * <p>
		 * The float style property will be unset by any of &quot;float&quot;,
		 * &quot;styleFloat&quot;, or &quot;cssFloat&quot;.
		 * </p>
		 * 
		 * @method unset
		 * @param sel
		 *            {String} the selector string to apply the changes to
		 * @param css
		 *            {String|Array} style property name or Array of names
		 * @return {StyleSheet} the StyleSheet instance
		 * @chainable
		 */
        unset : function (sel,css) {
            var rule = cssRules[sel],
                multi = sel.split(/\s*,\s*/),
                remove = !css,
                rules, i;

            // IE's addRule doesn't support multiple comma delimited selectors
            // so rules are mapped internally by atomic selectors
            if (multi.length > 1) {
                for (i = multi.length - 1; i >= 0; --i) {
                    this.unset(multi[i], css);
                }
                return this;
            }

            if (rule) {
                if (!remove) {
                    if (!lang.isArray(css)) {
                        css = [css];
                    }

                    workerStyle.cssText = rule.style.cssText;
                    for (i = css.length - 1; i >= 0; --i) {
                        _unsetProperty(workerStyle,css[i]);
                    }

                    if (workerStyle.cssText) {
                        rule.style.cssText = workerStyle.cssText;
                    } else {
                        remove = true;
                    }
                }
                
                if (remove) { // remove the rule altogether
                    rules = sheet[_rules];
                    for (i = rules.length - 1; i >= 0; --i) {
                        if (rules[i] === rule) {
                            delete cssRules[sel];
                            _deleteRule(i);
                            break;
                        }
                    }
                }
            }
            return this;
        },

        /**
		 * Get the current cssText for a rule or the entire sheet. If the
		 * selector param is supplied, only the cssText for that rule will be
		 * returned, if found. If the selector string targets multiple selectors
		 * separated by commas, the cssText of the first rule only will be
		 * returned. If no selector string, the stylesheet's full cssText will
		 * be returned.
		 * 
		 * @method getCssText
		 * @param sel
		 *            {String} Selector string
		 * @return {String}
		 */
        getCssText : function (sel) {
            var rule, css, selector;

            if (lang.isString(sel)) {
                // IE's addRule doesn't support multiple comma delimited
                // selectors so rules are mapped internally by atomic selectors
                rule = cssRules[sel.split(/\s*,\s*/)[0]];

                return rule ? rule.style.cssText : null;
            } else {
                css = [];
                for (selector in cssRules) {
                    if (cssRules.hasOwnProperty(selector)) {
                        rule = cssRules[selector];
                        css.push(rule.selectorText+" {"+rule.style.cssText+"}");
                    }
                }
                return css.join("\n");
            }
        }
    },true);

}

_toCssText = function (css,base) {
    var f = css.styleFloat || css.cssFloat || css['float'],
        prop;

    // A very difficult to repro/isolate IE 9 beta (and Platform Preview 7) bug
    // was reduced to this line throwing the error:
    // "Invalid this pointer used as target for method call"
    // It appears that the style collection is corrupted. The error is
    // catchable, so in a best effort to work around it, replace the
    // p and workerStyle and try the assignment again.
    try {
        workerStyle.cssText = base || '';
    } catch (ex) {
        p = d.createElement('p');
        workerStyle = p.style;
        workerStyle.cssText = base || '';
    }

    if (lang.isString(css)) {
        // There is a danger here of incremental memory consumption in Opera
        workerStyle.cssText += ';' + css;
    } else {
        if (f && !css[floatAttr]) {
            css = lang.merge(css);
            delete css.styleFloat; delete css.cssFloat; delete css['float'];
            css[floatAttr] = f;
        }

        for (prop in css) {
            if (css.hasOwnProperty(prop)) {
                try {
                    // IE throws Invalid Value errors and doesn't like
					// whitespace
                    // in values ala ' red' or 'red '
                    workerStyle[prop] = lang.trim(css[prop]);
                }
                catch (e) {
                }
            }
        }
    }

    return workerStyle.cssText;
};

lang.augmentObject(StyleSheet, {
    /**
	 * <p>
	 * Converts an object literal of style properties and values into a string
	 * of css text. This can then be assigned to el.style.cssText.
	 * </p>
	 * 
	 * <p>
	 * The optional second parameter is a cssText string representing the
	 * starting state of the style prior to alterations. This is most often
	 * extracted from the eventual target's current el.style.cssText.
	 * </p>
	 * 
	 * @method StyleSheet.toCssText
	 * @param css
	 *            {Object} object literal of style properties and values
	 * @param cssText
	 *            {String} OPTIONAL starting cssText value
	 * @return {String} the resulting cssText string
	 * @static
	 */
    toCssText : (('opacity' in workerStyle) ? _toCssText :
        // Wrap IE's toCssText to catch opacity. The copy/merge is to preserve
        // the input object's integrity, but if float and opacity are set, the
        // input will be copied twice in IE. Is there a way to avoid this
        // without increasing the byte count?
        function (css, cssText) {
            if (lang.isObject(css) && 'opacity' in css) {
                css = lang.merge(css,{
                        filter: 'alpha(opacity='+(css.opacity*100)+')'
                      });
                delete css.opacity;
            }
            return _toCssText(css,cssText);
        }),

    /**
	 * Registers a StyleSheet instance in the static registry by the given name
	 * 
	 * @method StyleSheet.register
	 * @param name
	 *            {String} the name to assign the StyleSheet in the registry
	 * @param sheet
	 *            {StyleSheet} The StyleSheet instance
	 * @return {Boolean} false if no name or sheet is not a StyleSheet instance.
	 *         true otherwise.
	 * @static
	 */
    register : function (name,sheet) {
        return !!(name && sheet instanceof StyleSheet &&
                  !sheets[name] && (sheets[name] = sheet));
    },

    /**
	 * <p>
	 * Determines if a selector string is safe to use. Used internally in set to
	 * prevent IE from locking up when attempting to add a rule for a &quot;bad
	 * selector&quot;.
	 * </p>
	 * 
	 * <p>
	 * Bad selectors are considered to be any string containing unescaped
	 * `~!@$%^&()+=|{}[];'"?< or space. Also forbidden are . or # followed by
	 * anything other than an alphanumeric. Additionally -abc or .-abc or #_abc
	 * or '# ' all fail. There are likely more failure cases, so please file a
	 * bug if you encounter one.
	 * </p>
	 * 
	 * @method StyleSheet.isValidSelector
	 * @param sel
	 *            {String} the selector string
	 * @return {Boolean}
	 * @static
	 */
    isValidSelector : function (sel) {
        var valid = false;

        if (sel && lang.isString(sel)) {

            if (!selectors.hasOwnProperty(sel)) {
                // TEST: there should be nothing but white-space left after
                // these destructive regexs
                selectors[sel] = !/\S/.test(
                    // combinators
                    sel.replace(/\s+|\s*[+~>]\s*/g,' ').
                    // attribute selectors (contents not validated)
                    replace(/([^ ])\[.*?\]/g,'$1').
                    // pseudo-class|element selectors (contents of parens
                    // such as :nth-of-type(2) or :not(...) not validated)
                    replace(/([^ ])::?[a-z][a-z\-]+[a-z](?:\(.*?\))?/ig,'$1').
                    // element tags
                    replace(/(?:^| )[a-z0-6]+/ig,' ').
                    // escaped characters
                    replace(/\\./g,'').
                    // class and id identifiers
                    replace(/[.#]\w[\w\-]*/g,''));
            }

            valid = selectors[sel];
        }

        return valid;
    }
},true);

YAHOO.util.StyleSheet = StyleSheet;

})();

/*
 * 
 * NOTES Style node must be added to the head element. Safari does not honor
 * styles applied to StyleSheet objects on style nodes in the body. StyleSheet
 * object is created on the style node when the style node is added to the head
 * element in Firefox 2 (and maybe 3?) The cssRules collection is replaced after
 * insertRule/deleteRule calls in Safari 3.1. Existing Rules are used in the new
 * collection, so the collection cannot be cached, but the rules can be. Opera
 * requires that the index be passed with insertRule. Same-domain restrictions
 * prevent modifying StyleSheet objects attached to link elements with remote
 * href (or "about:blank" or "javascript:false") Same-domain restrictions
 * prevent reading StyleSheet cssRules/rules collection of link elements with
 * remote href (or "about:blank" or "javascript:false") Same-domain restrictions
 * result in Safari not populating node.sheet property for link elements with
 * remote href (et.al) IE names StyleSheet related properties and methods
 * differently (see code) IE converts tag names to upper case in the Rule's
 * selectorText IE converts empty string assignment to complex properties to
 * value settings for all child properties. E.g. style.background = '' sets
 * non-'' values on style.backgroundPosition, style.backgroundColor, etc. All
 * else clear style.background and all child properties. IE assignment
 * style.filter = '' will result in style.cssText == 'FILTER:' All browsers
 * support Rule.style.cssText as a read/write property, leaving only opacity
 * needing to be accounted for. Benchmarks of style.property = value vs
 * style.cssText += 'property: value' indicate cssText is slightly slower for
 * single property assignment. For multiple property assignment, cssText speed
 * stays relatively the same where style.property speed decreases linearly by
 * the number of properties set. Exception being Opera 9.27, where
 * style.property is always faster than style.cssText. Opera 9.5b throws a
 * syntax error when assigning cssText with a syntax error. Opera 9.5 doesn't
 * honor rule.style.cssText = ''. Previous style persists. You have to remove
 * the rule altogether. Stylesheet properties set with !important will trump
 * inline style set on an element or in el.style.property. Creating a worker
 * style collection like document.createElement('p').style; will fail after a
 * time in FF (~5secs of inactivity). Property assignments will not alter the
 * property or cssText. It may be the generated node is garbage collected and
 * the style collection becomes inert (speculation). IE locks up when attempting
 * to add a rule with a selector including at least characters
 * {[]}~`!@%^&*()+=|? (unescaped) and leading _ or - such as addRule('-foo','{
 * color: red }') or addRule('._abc','{...}') IE's addRule doesn't support comma
 * separated selectors such as addRule('.foo, .bar','{..}') IE throws an error
 * on valid values with leading/trailing white space. When creating an entire
 * sheet at once, only FF2/3 & Opera allow creating a style node, setting its
 * innerHTML and appending to head. When creating an entire sheet at once,
 * Safari requires the style node to be created with content in innerHTML of
 * another element. When creating an entire sheet at once, IE requires the style
 * node content to be set via node.styleSheet.cssText When creating an entire
 * sheet at once in IE, styleSheet.cssText can't be written until node.type =
 * 'text/css'; is performed. When creating an entire sheet at once in IE,
 * load-time fork on var styleNode = d.createElement('style'); _method =
 * styleNode.styleSheet ?.. fails (falsey). During run-time, the test for
 * .styleSheet works fine Setting complex properties in cssText will SOMETIMES
 * allow child properties to be unset set unset FF2 FF3 S3.1 IE6 IE7 Op9.27
 * Op9.5 ---------- ----------------- --- --- ---- --- --- ------ ----- border
 * -top NO NO YES YES YES YES YES -top-color NO NO YES YES YES -color NO NO NO
 * NO NO background -color NO NO YES YES YES -position NO NO YES YES YES
 * -position-x NO NO NO NO NO font line-height YES YES NO NO NO NO YES -style
 * YES YES NO YES YES -size YES YES NO YES YES -size-adjust ??? ??? n/a n/a n/a
 * ??? ??? padding -top NO NO YES YES YES margin -top NO NO YES YES YES
 * list-style -type YES YES YES YES YES -position YES YES YES YES YES overflow
 * -x NO NO YES n/a YES
 * 
 * ??? - unsetting font-size-adjust has the same effect as unsetting font-size
 * FireFox and WebKit populate rule.cssText as "SELECTOR { CSSTEXT }", but Opera
 * and IE do not. IE6 and IE7 silently ignore the { and } if passed into
 * addRule('.foo','{ color:#000}',0). IE8 does not and creates an empty rule.
 * IE6-8 addRule('.foo','',n) throws an error. Must supply *some* cssText
 */

YAHOO.register("stylesheet", YAHOO.util.StyleSheet, {version: "2.9.0", build: "2800"});
/*
 * Copyright (c) 2011, Yahoo! Inc. All rights reserved. Code licensed under the
 * BSD License: http://developer.yahoo.com/yui/license.html version: 2.9.0
 */
(function() {

    /**
	 * The tabview module provides a widget for managing content bound to tabs.
	 * 
	 * @module tabview
	 * @requires yahoo, dom, event, element
	 * 
	 */

    var Y = YAHOO.util,
        Dom = Y.Dom,
        Event = Y.Event,
        document = window.document,
    
        // STRING CONSTANTS
        ACTIVE = 'active',
        ACTIVE_INDEX = 'activeIndex',
        ACTIVE_TAB = 'activeTab',
        DISABLED = 'disabled',
        CONTENT_EL = 'contentEl',
        ELEMENT = 'element',
    
    /**
	 * A widget to control tabbed views.
	 * 
	 * @namespace YAHOO.widget
	 * @class TabView
	 * @extends YAHOO.util.Element
	 * @constructor
	 * @param {HTMLElement |
	 *            String | Object} el(optional) The html element that represents
	 *            the TabView, or the attribute object to use. An element will
	 *            be created if none provided.
	 * @param {Object}
	 *            attr (optional) A key map of the tabView's initial attributes.
	 *            Ignored if first arg is attributes object.
	 */
    TabView = function(el, attr) {
        attr = attr || {};
        if (arguments.length == 1 && !YAHOO.lang.isString(el) && !el.nodeName) {
            attr = el; // treat first arg as attr object
            el = attr.element || null;
        }
        
        if (!el && !attr.element) { // create if we dont have one
            el = this._createTabViewElement(attr);
        }
        TabView.superclass.constructor.call(this, el, attr); 
    };

    YAHOO.extend(TabView, Y.Element, {
        /**
		 * The className to add when building from scratch.
		 * 
		 * @property CLASSNAME
		 * @default "navset"
		 */
        CLASSNAME: 'yui-navset',
        
        /**
		 * The className of the HTMLElement containing the TabView's tab
		 * elements to look for when building from existing markup, or to add
		 * when building from scratch. All childNodes of the tab container are
		 * treated as Tabs when building from existing markup.
		 * 
		 * @property TAB_PARENT_CLASSNAME
		 * @default "nav"
		 */
        TAB_PARENT_CLASSNAME: 'yui-nav',
        
        /**
		 * The className of the HTMLElement containing the TabView's label
		 * elements to look for when building from existing markup, or to add
		 * when building from scratch. All childNodes of the content container
		 * are treated as content elements when building from existing markup.
		 * 
		 * @property CONTENT_PARENT_CLASSNAME
		 * @default "nav-content"
		 */
        CONTENT_PARENT_CLASSNAME: 'yui-content',
        
        _tabParent: null,
        _contentParent: null,
        
        /**
		 * Adds a Tab to the TabView instance. If no index is specified, the tab
		 * is added to the end of the tab list.
		 * 
		 * @method addTab
		 * @param {YAHOO.widget.Tab}
		 *            tab A Tab instance to add.
		 * @param {Integer}
		 *            index The position to add the tab.
		 * @return void
		 */
        addTab: function(tab, index) {
            var tabs = this.get('tabs'),
                tabParent = this._tabParent,
                contentParent = this._contentParent,
                tabElement = tab.get(ELEMENT),
                contentEl = tab.get(CONTENT_EL),
                activeIndex = this.get(ACTIVE_INDEX),
                before;

            if (!tabs) { // not ready yet
                this._queue[this._queue.length] = ['addTab', arguments];
                return false;
            }
            
            before = this.getTab(index);
            index = (index === undefined) ? tabs.length : index;
            
            tabs.splice(index, 0, tab);

            if (before) {
                tabParent.insertBefore(tabElement, before.get(ELEMENT));
                if (contentEl) {
                    contentParent.appendChild(contentEl);
                }
            } else {
                tabParent.appendChild(tabElement);
                if (contentEl) {
                    contentParent.appendChild(contentEl);
                }
            }

            if ( !tab.get(ACTIVE) ) {
                tab.set('contentVisible', false, true); /* hide if not active */
                if (index <= activeIndex) {
                    this.set(ACTIVE_INDEX, activeIndex + 1, true);
                }  
            } else {
                this.set(ACTIVE_TAB, tab, true);
                this.set('activeIndex', index, true);
            }

            this._initTabEvents(tab);
        },

        _initTabEvents: function(tab) {
            tab.addListener( tab.get('activationEvent'), tab._onActivate, this, tab);
            tab.addListener('activationEventChange', tab._onActivationEventChange, this, tab);
        },

        _removeTabEvents: function(tab) {
            tab.removeListener(tab.get('activationEvent'), tab._onActivate, this, tab);
            tab.removeListener('activationEventChange', tab._onActivationEventChange, this, tab);
        },

        /**
		 * Routes childNode events.
		 * 
		 * @method DOMEventHandler
		 * @param {event}
		 *            e The Dom event that is being handled.
		 * @return void
		 */
        DOMEventHandler: function(e) {
            var target = Event.getTarget(e),
                tabParent = this._tabParent,
                tabs = this.get('tabs'),
                tab,
                tabEl,
                contentEl;

            
            if (Dom.isAncestor(tabParent, target) ) {
                for (var i = 0, len = tabs.length; i < len; i++) {
                    tabEl = tabs[i].get(ELEMENT);
                    contentEl = tabs[i].get(CONTENT_EL);

                    if ( target == tabEl || Dom.isAncestor(tabEl, target) ) {
                        tab = tabs[i];
                        break; // note break
                    }
                } 
                
                if (tab) {
                    tab.fireEvent(e.type, e);
                }
            }
        },
        
        /**
		 * Returns the Tab instance at the specified index.
		 * 
		 * @method getTab
		 * @param {Integer}
		 *            index The position of the Tab.
		 * @return YAHOO.widget.Tab
		 */
        getTab: function(index) {
            return this.get('tabs')[index];
        },
        
        /**
		 * Returns the index of given tab.
		 * 
		 * @method getTabIndex
		 * @param {YAHOO.widget.Tab}
		 *            tab The tab whose index will be returned.
		 * @return int
		 */
        getTabIndex: function(tab) {
            var index = null,
                tabs = this.get('tabs');
            for (var i = 0, len = tabs.length; i < len; ++i) {
                if (tab == tabs[i]) {
                    index = i;
                    break;
                }
            }
            
            return index;
        },
        
        /**
		 * Removes the specified Tab from the TabView.
		 * 
		 * @method removeTab
		 * @param {YAHOO.widget.Tab}
		 *            item The Tab instance to be removed.
		 * @return void
		 */
        removeTab: function(tab) {
            var tabCount = this.get('tabs').length,
                activeIndex = this.get(ACTIVE_INDEX),
                index = this.getTabIndex(tab);

            if ( tab === this.get(ACTIVE_TAB) ) { 
                if (tabCount > 1) { // select another tab
                    if (index + 1 === tabCount) { // if last, activate
													// previous
                        this.set(ACTIVE_INDEX, index - 1);
                    } else { // activate next tab
                        this.set(ACTIVE_INDEX, index + 1);
                    }
                } else { // no more tabs
                    this.set(ACTIVE_TAB, null);
                }
            } else if (index < activeIndex) {
                this.set(ACTIVE_INDEX, activeIndex - 1, true);
            }
            
            this._removeTabEvents(tab);
            this._tabParent.removeChild( tab.get(ELEMENT) );
            this._contentParent.removeChild( tab.get(CONTENT_EL) );
            this._configs.tabs.value.splice(index, 1);

            tab.fireEvent('remove', { type: 'remove', tabview: this });
        },
        
        /**
		 * Provides a readable name for the TabView instance.
		 * 
		 * @method toString
		 * @return String
		 */
        toString: function() {
            var name = this.get('id') || this.get('tagName');
            return "TabView " + name; 
        },
        
        /**
		 * The transiton to use when switching between tabs.
		 * 
		 * @method contentTransition
		 */
        contentTransition: function(newTab, oldTab) {
            if (newTab) {
                newTab.set('contentVisible', true);
            }
            if (oldTab) {
                oldTab.set('contentVisible', false);
            }
        },
        
        /**
		 * setAttributeConfigs TabView specific properties.
		 * 
		 * @method initAttributes
		 * @param {Object}
		 *            attr Hash of initial attributes
		 */
        initAttributes: function(attr) {
            TabView.superclass.initAttributes.call(this, attr);
            
            if (!attr.orientation) {
                attr.orientation = 'top';
            }
            
            var el = this.get(ELEMENT);

            if (!this.hasClass(this.CLASSNAME)) {
                this.addClass(this.CLASSNAME);        
            }
            
            /**
			 * The Tabs belonging to the TabView instance.
			 * 
			 * @attribute tabs
			 * @type Array
			 */
            this.setAttributeConfig('tabs', {
                value: [],
                readOnly: true
            });

            /**
			 * The container of the tabView's label elements.
			 * 
			 * @property _tabParent
			 * @private
			 * @type HTMLElement
			 */
            this._tabParent = 
                    this.getElementsByClassName(this.TAB_PARENT_CLASSNAME,
                            'ul' )[0] || this._createTabParent();
                
            /**
			 * The container of the tabView's content elements.
			 * 
			 * @property _contentParent
			 * @type HTMLElement
			 * @private
			 */
            this._contentParent = 
                    this.getElementsByClassName(this.CONTENT_PARENT_CLASSNAME,
                            'div')[0] ||  this._createContentParent();
            
            /**
			 * How the Tabs should be oriented relative to the TabView. Valid
			 * orientations are "top", "left", "bottom", and "right"
			 * 
			 * @attribute orientation
			 * @type String
			 * @default "top"
			 */
            this.setAttributeConfig('orientation', {
                value: attr.orientation,
                method: function(value) {
                    var current = this.get('orientation');
                    this.addClass('yui-navset-' + value);
                    
                    if (current != value) {
                        this.removeClass('yui-navset-' + current);
                    }
                    
                    if (value === 'bottom') {
                        this.appendChild(this._tabParent);
                    }
                }
            });
            
            /**
			 * The index of the tab currently active.
			 * 
			 * @attribute activeIndex
			 * @type Int
			 */
            this.setAttributeConfig(ACTIVE_INDEX, {
                value: attr.activeIndex,
                validator: function(value) {
                    var ret = true,
                        tab;
                    if (value) { // cannot activate if disabled
                        tab = this.getTab(value);
                        if (tab && tab.get(DISABLED)) {
                            ret = false;
                        }
                    }
                    return ret;
                }
            });
            
            /**
			 * The tab currently active.
			 * 
			 * @attribute activeTab
			 * @type YAHOO.widget.Tab
			 */
            this.setAttributeConfig(ACTIVE_TAB, {
                value: attr[ACTIVE_TAB],
                method: function(tab) {
                    var activeTab = this.get(ACTIVE_TAB);
                    
                    if (tab) {
                        tab.set(ACTIVE, true);
                    }
                    
                    if (activeTab && activeTab !== tab) {
                        activeTab.set(ACTIVE, false);
                    }
                    
                    if (activeTab && tab !== activeTab) { // no transition if
															// only 1
                        this.contentTransition(tab, activeTab);
                    } else if (tab) {
                        tab.set('contentVisible', true);
                    }
                },
                validator: function(value) {
                    var ret = true;
                    if (value && value.get(DISABLED)) { // cannot activate if
														// disabled
                        ret = false;
                    }
                    return ret;
                }
            });

            this.on('activeTabChange', this._onActiveTabChange);
            this.on('activeIndexChange', this._onActiveIndexChange);

            if ( this._tabParent ) {
                this._initTabs();
            }
            
            // Due to delegation we add all DOM_EVENTS to the TabView container
            // but IE will leak when unsupported events are added, so remove
			// these
            this.DOM_EVENTS.submit = false;
            this.DOM_EVENTS.focus = false;
            this.DOM_EVENTS.blur = false;
            this.DOM_EVENTS.change = false;

            for (var type in this.DOM_EVENTS) {
                if ( YAHOO.lang.hasOwnProperty(this.DOM_EVENTS, type) ) {
                    this.addListener.call(this, type, this.DOMEventHandler);
                }
            }
        },

        /**
		 * Removes selected state from the given tab if it is the activeTab
		 * 
		 * @method deselectTab
		 * @param {Int}
		 *            index The tab index to deselect
		 */
        deselectTab: function(index) {
            if (this.getTab(index) === this.get(ACTIVE_TAB)) {
                this.set(ACTIVE_TAB, null);
            }
        },

        /**
		 * Makes the tab at the given index the active tab
		 * 
		 * @method selectTab
		 * @param {Int}
		 *            index The tab index to be made active
		 */
        selectTab: function(index) {
            this.set(ACTIVE_TAB, this.getTab(index));
        },

        _onActiveTabChange: function(e) {
            var activeIndex = this.get(ACTIVE_INDEX),
                newIndex = this.getTabIndex(e.newValue);

            if (activeIndex !== newIndex) {
                if (!(this.set(ACTIVE_INDEX, newIndex)) ) { // NOTE: setting
                     // revert if activeIndex update fails (cancelled via
						// beforeChange)
                    this.set(ACTIVE_TAB, e.prevValue);
                }
            }
        },
        
        _onActiveIndexChange: function(e) {
            // no set if called from ActiveTabChange event
            if (e.newValue !== this.getTabIndex(this.get(ACTIVE_TAB))) {
                if (!(this.set(ACTIVE_TAB, this.getTab(e.newValue))) ) { // NOTE:
																			// setting
                     // revert if activeTab update fails (cancelled via
						// beforeChange)
                    this.set(ACTIVE_INDEX, e.prevValue);
                }
            }
        },

        /**
		 * Creates Tab instances from a collection of HTMLElements.
		 * 
		 * @method _initTabs
		 * @private
		 * @return void
		 */
        _initTabs: function() {
            var tabs = Dom.getChildren(this._tabParent),
                contentElements = Dom.getChildren(this._contentParent),
                activeIndex = this.get(ACTIVE_INDEX),
                tab,
                attr,
                active;

            for (var i = 0, len = tabs.length; i < len; ++i) {
                attr = {};
                
                if (contentElements[i]) {
                    attr.contentEl = contentElements[i];
                }

                tab = new YAHOO.widget.Tab(tabs[i], attr);
                this.addTab(tab);
                
                if (tab.hasClass(tab.ACTIVE_CLASSNAME) ) {
                    active = tab;
                }
            }
            if (activeIndex != undefined) { // not null or undefined
                this.set(ACTIVE_TAB, this.getTab(activeIndex));
            } else {
                this._configs[ACTIVE_TAB].value = active; // dont invoke
															// method
                this._configs[ACTIVE_INDEX].value = this.getTabIndex(active);
            }
        },

        _createTabViewElement: function(attr) {
            var el = document.createElement('div');

            if ( this.CLASSNAME ) {
                el.className = this.CLASSNAME;
            }
            
            return el;
        },

        _createTabParent: function(attr) {
            var el = document.createElement('ul');

            if ( this.TAB_PARENT_CLASSNAME ) {
                el.className = this.TAB_PARENT_CLASSNAME;
            }
            
            this.get(ELEMENT).appendChild(el);
            
            return el;
        },
        
        _createContentParent: function(attr) {
            var el = document.createElement('div');

            if ( this.CONTENT_PARENT_CLASSNAME ) {
                el.className = this.CONTENT_PARENT_CLASSNAME;
            }
            
            this.get(ELEMENT).appendChild(el);
            
            return el;
        }
    });
    
    
    YAHOO.widget.TabView = TabView;
})();

(function() {
    var Y = YAHOO.util, 
        Dom = Y.Dom,
        Lang = YAHOO.lang,
    

    // STRING CONSTANTS
        ACTIVE_TAB = 'activeTab',
        LABEL = 'label',
        LABEL_EL = 'labelEl',
        CONTENT = 'content',
        CONTENT_EL = 'contentEl',
        ELEMENT = 'element',
        CACHE_DATA = 'cacheData',
        DATA_SRC = 'dataSrc',
        DATA_LOADED = 'dataLoaded',
        DATA_TIMEOUT = 'dataTimeout',
        LOAD_METHOD = 'loadMethod',
        POST_DATA = 'postData',
        DISABLED = 'disabled',
    
    /**
	 * A representation of a Tab's label and content.
	 * 
	 * @namespace YAHOO.widget
	 * @class Tab
	 * @extends YAHOO.util.Element
	 * @constructor
	 * @param element
	 *            {HTMLElement | String} (optional) The html element that
	 *            represents the Tab. An element will be created if none
	 *            provided.
	 * @param {Object}
	 *            properties A key map of initial properties
	 */
    Tab = function(el, attr) {
        attr = attr || {};
        if (arguments.length == 1 && !Lang.isString(el) && !el.nodeName) {
            attr = el;
            el = attr.element;
        }

        if (!el && !attr.element) {
            el = this._createTabElement(attr);
        }

        this.loadHandler =  {
            success: function(o) {
                this.set(CONTENT, o.responseText);
            },
            failure: function(o) {
            }
        };
        
        Tab.superclass.constructor.call(this, el, attr);
        
        this.DOM_EVENTS = {}; // delegating to tabView
    };

    YAHOO.extend(Tab, YAHOO.util.Element, {
        /**
		 * The default tag name for a Tab's inner element.
		 * 
		 * @property LABEL_INNER_TAGNAME
		 * @type String
		 * @default "em"
		 */
        LABEL_TAGNAME: 'em',
        
        /**
		 * The class name applied to active tabs.
		 * 
		 * @property ACTIVE_CLASSNAME
		 * @type String
		 * @default "selected"
		 */
        ACTIVE_CLASSNAME: 'selected',
        
        /**
		 * The class name applied to active tabs.
		 * 
		 * @property HIDDEN_CLASSNAME
		 * @type String
		 * @default "yui-hidden"
		 */
        HIDDEN_CLASSNAME: 'yui-hidden',
        
        /**
		 * The title applied to active tabs.
		 * 
		 * @property ACTIVE_TITLE
		 * @type String
		 * @default "active"
		 */
        ACTIVE_TITLE: 'active',

        /**
		 * The class name applied to disabled tabs.
		 * 
		 * @property DISABLED_CLASSNAME
		 * @type String
		 * @default "disabled"
		 */
        DISABLED_CLASSNAME: DISABLED,
        
        /**
		 * The class name applied to dynamic tabs while loading.
		 * 
		 * @property LOADING_CLASSNAME
		 * @type String
		 * @default "disabled"
		 */
        LOADING_CLASSNAME: 'loading',

        /**
		 * Provides a reference to the connection request object when data is
		 * loaded dynamically.
		 * 
		 * @property dataConnection
		 * @type Object
		 */
        dataConnection: null,
        
        /**
		 * Object containing success and failure callbacks for loading data.
		 * 
		 * @property loadHandler
		 * @type object
		 */
        loadHandler: null,

        _loading: false,
        
        /**
		 * Provides a readable name for the tab.
		 * 
		 * @method toString
		 * @return String
		 */
        toString: function() {
            var el = this.get(ELEMENT),
                id = el.id || el.tagName;
            return "Tab " + id; 
        },
        
        /**
		 * setAttributeConfigs Tab specific properties.
		 * 
		 * @method initAttributes
		 * @param {Object}
		 *            attr Hash of initial attributes
		 */
        initAttributes: function(attr) {
            attr = attr || {};
            Tab.superclass.initAttributes.call(this, attr);
            
            /**
			 * The event that triggers the tab's activation.
			 * 
			 * @attribute activationEvent
			 * @type String
			 */
            this.setAttributeConfig('activationEvent', {
                value: attr.activationEvent || 'click'
            });        

            /**
			 * The element that contains the tab's label.
			 * 
			 * @attribute labelEl
			 * @type HTMLElement
			 */
            this.setAttributeConfig(LABEL_EL, {
                value: attr[LABEL_EL] || this._getLabelEl(),
                method: function(value) {
                    value = Dom.get(value);
                    var current = this.get(LABEL_EL);

                    if (current) {
                        if (current == value) {
                            return false; // already set
                        }
                        
                        current.parentNode.replaceChild(value, current);
                        this.set(LABEL, value.innerHTML);
                    }
                } 
            });

            /**
			 * The tab's label text (or innerHTML).
			 * 
			 * @attribute label
			 * @type String
			 */
            this.setAttributeConfig(LABEL, {
                value: attr.label || this._getLabel(),
                method: function(value) {
                    var labelEl = this.get(LABEL_EL);
                    if (!labelEl) { // create if needed
                        this.set(LABEL_EL, this._createLabelEl());
                    }
                    
                    labelEl.innerHTML = value;
                }
            });
            
            /**
			 * The HTMLElement that contains the tab's content.
			 * 
			 * @attribute contentEl
			 * @type HTMLElement
			 */
            this.setAttributeConfig(CONTENT_EL, {
                value: attr[CONTENT_EL] || document.createElement('div'),
                method: function(value) {
                    value = Dom.get(value);
                    var current = this.get(CONTENT_EL);

                    if (current) {
                        if (current === value) {
                            return false; // already set
                        }
                        if (!this.get('selected')) {
                            Dom.addClass(value, this.HIDDEN_CLASSNAME);
                        }
                        current.parentNode.replaceChild(value, current);
                        this.set(CONTENT, value.innerHTML);
                    }
                }
            });
            
            /**
			 * The tab's content.
			 * 
			 * @attribute content
			 * @type String
			 */
            this.setAttributeConfig(CONTENT, {
                value: attr[CONTENT] || this.get(CONTENT_EL).innerHTML,
                method: function(value) {
                    this.get(CONTENT_EL).innerHTML = value;
                }
            });

            /**
			 * The tab's data source, used for loading content dynamically.
			 * 
			 * @attribute dataSrc
			 * @type String
			 */
            this.setAttributeConfig(DATA_SRC, {
                value: attr.dataSrc
            });
            
            /**
			 * Whether or not content should be reloaded for every view.
			 * 
			 * @attribute cacheData
			 * @type Boolean
			 * @default false
			 */
            this.setAttributeConfig(CACHE_DATA, {
                value: attr.cacheData || false,
                validator: Lang.isBoolean
            });
            
            /**
			 * The method to use for the data request.
			 * 
			 * @attribute loadMethod
			 * @type String
			 * @default "GET"
			 */
            this.setAttributeConfig(LOAD_METHOD, {
                value: attr.loadMethod || 'GET',
                validator: Lang.isString
            });

            /**
			 * Whether or not any data has been loaded from the server.
			 * 
			 * @attribute dataLoaded
			 * @type Boolean
			 */        
            this.setAttributeConfig(DATA_LOADED, {
                value: false,
                validator: Lang.isBoolean,
                writeOnce: true
            });
            
            /**
			 * Number if milliseconds before aborting and calling failure
			 * handler.
			 * 
			 * @attribute dataTimeout
			 * @type Number
			 * @default null
			 */
            this.setAttributeConfig(DATA_TIMEOUT, {
                value: attr.dataTimeout || null,
                validator: Lang.isNumber
            });
            
            /**
			 * Arguments to pass when POST method is used
			 * 
			 * @attribute postData
			 * @default null
			 */
            this.setAttributeConfig(POST_DATA, {
                value: attr.postData || null
            });

            /**
			 * Whether or not the tab is currently active. If a dataSrc is set
			 * for the tab, the content will be loaded from the given source.
			 * 
			 * @attribute active
			 * @type Boolean
			 */
            this.setAttributeConfig('active', {
                value: attr.active || this.hasClass(this.ACTIVE_CLASSNAME),
                method: function(value) {
                    if (value === true) {
                        this.addClass(this.ACTIVE_CLASSNAME);
                        this.set('title', this.ACTIVE_TITLE);
                    } else {
                        this.removeClass(this.ACTIVE_CLASSNAME);
                        this.set('title', '');
                    }
                },
                validator: function(value) {
                    return Lang.isBoolean(value) && !this.get(DISABLED) ;
                }
            });
            
            /**
			 * Whether or not the tab is disabled.
			 * 
			 * @attribute disabled
			 * @type Boolean
			 */
            this.setAttributeConfig(DISABLED, {
                value: attr.disabled || this.hasClass(this.DISABLED_CLASSNAME),
                method: function(value) {
                    if (value === true) {
                        this.addClass(this.DISABLED_CLASSNAME);
                    } else {
                        this.removeClass(this.DISABLED_CLASSNAME);
                    }
                },
                validator: Lang.isBoolean
            });
            
            /**
			 * The href of the tab's anchor element.
			 * 
			 * @attribute href
			 * @type String
			 * @default '#'
			 */
            this.setAttributeConfig('href', {
                value: attr.href ||
                        this.getElementsByTagName('a')[0].getAttribute('href', 2) || '#',
                method: function(value) {
                    this.getElementsByTagName('a')[0].href = value;
                },
                validator: Lang.isString
            });
            
            /**
			 * The Whether or not the tab's content is visible.
			 * 
			 * @attribute contentVisible
			 * @type Boolean
			 * @default false
			 */
            this.setAttributeConfig('contentVisible', {
                value: attr.contentVisible,
                method: function(value) {
                    if (value) {
                        Dom.removeClass(this.get(CONTENT_EL), this.HIDDEN_CLASSNAME);
                        
                        if ( this.get(DATA_SRC) ) {
                         // load dynamic content unless already loading or
							// loaded and caching
                            if ( !this._loading && !(this.get(DATA_LOADED) && this.get(CACHE_DATA)) ) {
                                this._dataConnect();
                            }
                        }
                    } else {
                        Dom.addClass(this.get(CONTENT_EL), this.HIDDEN_CLASSNAME);
                    }
                },
                validator: Lang.isBoolean
            });
        },
        
        _dataConnect: function() {
            if (!Y.Connect) {
                return false;
            }

            Dom.addClass(this.get(CONTENT_EL).parentNode, this.LOADING_CLASSNAME);
            this._loading = true; 
            this.dataConnection = Y.Connect.asyncRequest(
                this.get(LOAD_METHOD),
                this.get(DATA_SRC), 
                {
                    success: function(o) {
                        this.loadHandler.success.call(this, o);
                        this.set(DATA_LOADED, true);
                        this.dataConnection = null;
                        Dom.removeClass(this.get(CONTENT_EL).parentNode,
                                this.LOADING_CLASSNAME);
                        this._loading = false;
                    },
                    failure: function(o) {
                        this.loadHandler.failure.call(this, o);
                        this.dataConnection = null;
                        Dom.removeClass(this.get(CONTENT_EL).parentNode,
                                this.LOADING_CLASSNAME);
                        this._loading = false;
                    },
                    scope: this,
                    timeout: this.get(DATA_TIMEOUT)
                },

                this.get(POST_DATA)
            );
        },
        _createTabElement: function(attr) {
            var el = document.createElement('li'),
                a = document.createElement('a'),
                label = attr.label || null,
                labelEl = attr.labelEl || null;
            
            a.href = attr.href || '#'; // TODO: Use Dom.setAttribute?
            el.appendChild(a);
            
            if (labelEl) { // user supplied labelEl
                if (!label) { // user supplied label
                    label = this._getLabel();
                }
            } else {
                labelEl = this._createLabelEl();
            }
            
            a.appendChild(labelEl);
            
            return el;
        },

        _getLabelEl: function() {
            return this.getElementsByTagName(this.LABEL_TAGNAME)[0];
        },

        _createLabelEl: function() {
            var el = document.createElement(this.LABEL_TAGNAME);
            return el;
        },
    
        
        _getLabel: function() {
            var el = this.get(LABEL_EL);
                
                if (!el) {
                    return undefined;
                }
            
            return el.innerHTML;
        },

        _onActivate: function(e, tabview) {
            var tab = this,
                silent = false;

            Y.Event.preventDefault(e);
            if (tab === tabview.get(ACTIVE_TAB)) {
                silent = true; // dont fire activeTabChange if already active
            }
            tabview.set(ACTIVE_TAB, tab, silent);
        },

        _onActivationEventChange: function(e) {
            var tab = this;

            if (e.prevValue != e.newValue) {
                tab.removeListener(e.prevValue, tab._onActivate);
                tab.addListener(e.newValue, tab._onActivate, this, tab);
            }
        }
    });
    
    
    /**
	 * Fires when a tab is removed from the tabview
	 * 
	 * @event remove
	 * @type CustomEvent
	 * @param {Event}
	 *            An event object with fields for "type" ("remove") and
	 *            "tabview" (the tabview instance it was removed from)
	 */
    
    YAHOO.widget.Tab = Tab;
})();

YAHOO.register("tabview", YAHOO.widget.TabView, {version: "2.9.0", build: "2800"});
/*
 * Copyright (c) 2011, Yahoo! Inc. All rights reserved. Code licensed under the
 * BSD License: http://developer.yahoo.com/yui/license.html version: 2.9.0
 */
(function () {
    var Dom = YAHOO.util.Dom,
        Event = YAHOO.util.Event,
        Lang = YAHOO.lang,
        Widget = YAHOO.widget;



/**
 * The treeview widget is a generic tree building tool.
 * 
 * @module treeview
 * @title TreeView Widget
 * @requires yahoo, dom, event
 * @optional animation, json, calendar
 * @namespace YAHOO.widget
 */

/**
 * Contains the tree view state data and the root node.
 * 
 * @class TreeView
 * @uses YAHOO.util.EventProvider
 * @constructor
 * @param {string|HTMLElement}
 *            id The id of the element, or the element itself that the tree will
 *            be inserted into. Existing markup in this element, if valid, will
 *            be used to build the tree
 * @param {Array|Object|String}
 *            oConfig (optional) If present, it will be used to build the tree
 *            via method <a
 *            href="#method_buildTreeFromObject">buildTreeFromObject</a>
 * 
 */
YAHOO.widget.TreeView = function(id, oConfig) {
    if (id) { this.init(id); }
    if (oConfig) {
        this.buildTreeFromObject(oConfig);
    } else if (Lang.trim(this._el.innerHTML)) {
        this.buildTreeFromMarkup(id);
    }
};

var TV = Widget.TreeView;

TV.prototype = {

    /**
	 * The id of tree container element
	 * 
	 * @property id
	 * @type String
	 */
    id: null,

    /**
	 * The host element for this tree
	 * 
	 * @property _el
	 * @private
	 * @type HTMLelement
	 */
    _el: null,

     /**
		 * Flat collection of all nodes in this tree. This is a sparse array, so
		 * the length property can't be relied upon for a node count for the
		 * tree.
		 * 
		 * @property _nodes
		 * @type Node[]
		 * @private
		 */
    _nodes: null,

    /**
	 * We lock the tree control while waiting for the dynamic loader to return
	 * 
	 * @property locked
	 * @type boolean
	 */
    locked: false,

    /**
	 * The animation to use for expanding children, if any
	 * 
	 * @property _expandAnim
	 * @type string
	 * @private
	 */
    _expandAnim: null,

    /**
	 * The animation to use for collapsing children, if any
	 * 
	 * @property _collapseAnim
	 * @type string
	 * @private
	 */
    _collapseAnim: null,

    /**
	 * The current number of animations that are executing
	 * 
	 * @property _animCount
	 * @type int
	 * @private
	 */
    _animCount: 0,

    /**
	 * The maximum number of animations to run at one time.
	 * 
	 * @property maxAnim
	 * @type int
	 */
    maxAnim: 2,

    /**
	 * Whether there is any subscriber to dblClickEvent
	 * 
	 * @property _hasDblClickSubscriber
	 * @type boolean
	 * @private
	 */
    _hasDblClickSubscriber: false,

    /**
	 * Stores the timer used to check for double clicks
	 * 
	 * @property _dblClickTimer
	 * @type window.timer object
	 * @private
	 */
    _dblClickTimer: null,

  /**
	 * A reference to the Node currently having the focus or null if none.
	 * 
	 * @property currentFocus
	 * @type YAHOO.widget.Node
	 */
    currentFocus: null,

    /**
	 * If true, only one Node can be highlighted at a time
	 * 
	 * @property singleNodeHighlight
	 * @type boolean
	 * @default false
	 */

    singleNodeHighlight: false,

    /**
	 * A reference to the Node that is currently highlighted. It is only
	 * meaningful if singleNodeHighlight is enabled
	 * 
	 * @property _currentlyHighlighted
	 * @type YAHOO.widget.Node
	 * @default null
	 * @private
	 */

    _currentlyHighlighted: null,

    /**
	 * Sets up the animation for expanding children
	 * 
	 * @method setExpandAnim
	 * @param {string}
	 *            type the type of animation (acceptable values defined in
	 *            YAHOO.widget.TVAnim)
	 */
    setExpandAnim: function(type) {
        this._expandAnim = (Widget.TVAnim.isValid(type)) ? type : null;
    },

    /**
	 * Sets up the animation for collapsing children
	 * 
	 * @method setCollapseAnim
	 * @param {string}
	 *            type of animation (acceptable values defined in
	 *            YAHOO.widget.TVAnim)
	 */
    setCollapseAnim: function(type) {
        this._collapseAnim = (Widget.TVAnim.isValid(type)) ? type : null;
    },

    /**
	 * Perform the expand animation if configured, or just show the element if
	 * not configured or too many animations are in progress
	 * 
	 * @method animateExpand
	 * @param el
	 *            {HTMLElement} the element to animate
	 * @param node
	 *            {YAHOO.util.Node} the node that was expanded
	 * @return {boolean} true if animation could be invoked, false otherwise
	 */
    animateExpand: function(el, node) {

        if (this._expandAnim && this._animCount < this.maxAnim) {
            // this.locked = true;
            var tree = this;
            var a = Widget.TVAnim.getAnim(this._expandAnim, el,
                            function() { tree.expandComplete(node); });
            if (a) {
                ++this._animCount;
                this.fireEvent("animStart", {
                        "node": node,
                        "type": "expand"
                    });
                a.animate();
            }

            return true;
        }

        return false;
    },

    /**
	 * Perform the collapse animation if configured, or just show the element if
	 * not configured or too many animations are in progress
	 * 
	 * @method animateCollapse
	 * @param el
	 *            {HTMLElement} the element to animate
	 * @param node
	 *            {YAHOO.util.Node} the node that was expanded
	 * @return {boolean} true if animation could be invoked, false otherwise
	 */
    animateCollapse: function(el, node) {

        if (this._collapseAnim && this._animCount < this.maxAnim) {
            // this.locked = true;
            var tree = this;
            var a = Widget.TVAnim.getAnim(this._collapseAnim, el,
                            function() { tree.collapseComplete(node); });
            if (a) {
                ++this._animCount;
                this.fireEvent("animStart", {
                        "node": node,
                        "type": "collapse"
                    });
                a.animate();
            }

            return true;
        }

        return false;
    },

    /**
	 * Function executed when the expand animation completes
	 * 
	 * @method expandComplete
	 */
    expandComplete: function(node) {
        --this._animCount;
        this.fireEvent("animComplete", {
                "node": node,
                "type": "expand"
            });
        // this.locked = false;
    },

    /**
	 * Function executed when the collapse animation completes
	 * 
	 * @method collapseComplete
	 */
    collapseComplete: function(node) {
        --this._animCount;
        this.fireEvent("animComplete", {
                "node": node,
                "type": "collapse"
            });
        // this.locked = false;
    },

    /**
	 * Initializes the tree
	 * 
	 * @method init
	 * @parm {string|HTMLElement} id the id of the element that will hold the
	 *       tree
	 * @private
	 */
    init: function(id) {
        this._el = Dom.get(id);
        this.id = Dom.generateId(this._el,"yui-tv-auto-id-");

    /**
	 * When animation is enabled, this event fires when the animation starts
	 * 
	 * @event animStart
	 * @type CustomEvent
	 * @param {YAHOO.widget.Node}
	 *            oArgs.node the node that is expanding/collapsing
	 * @param {String}
	 *            oArgs.type the type of animation ("expand" or "collapse")
	 */
        this.createEvent("animStart", this);

        /**
		 * When animation is enabled, this event fires when the animation
		 * completes
		 * 
		 * @event animComplete
		 * @type CustomEvent
		 * @param {YAHOO.widget.Node}
		 *            oArgs.node the node that is expanding/collapsing
		 * @param {String}
		 *            oArgs.type the type of animation ("expand" or "collapse")
		 */
        this.createEvent("animComplete", this);

        /**
		 * Fires when a node is going to be collapsed. Return false to stop the
		 * collapse.
		 * 
		 * @event collapse
		 * @type CustomEvent
		 * @param {YAHOO.widget.Node}
		 *            node the node that is collapsing
		 */
        this.createEvent("collapse", this);

        /**
		 * Fires after a node is successfully collapsed. This event will not
		 * fire if the "collapse" event was cancelled.
		 * 
		 * @event collapseComplete
		 * @type CustomEvent
		 * @param {YAHOO.widget.Node}
		 *            node the node that was collapsed
		 */
        this.createEvent("collapseComplete", this);

        /**
		 * Fires when a node is going to be expanded. Return false to stop the
		 * collapse.
		 * 
		 * @event expand
		 * @type CustomEvent
		 * @param {YAHOO.widget.Node}
		 *            node the node that is expanding
		 */
        this.createEvent("expand", this);

        /**
		 * Fires after a node is successfully expanded. This event will not fire
		 * if the "expand" event was cancelled.
		 * 
		 * @event expandComplete
		 * @type CustomEvent
		 * @param {YAHOO.widget.Node}
		 *            node the node that was expanded
		 */
        this.createEvent("expandComplete", this);

    /**
	 * Fires when the Enter key is pressed on a node that has the focus
	 * 
	 * @event enterKeyPressed
	 * @type CustomEvent
	 * @param {YAHOO.widget.Node}
	 *            node the node that has the focus
	 */
        this.createEvent("enterKeyPressed", this);

    /**
	 * Fires when the label in a TextNode or MenuNode or content in an HTMLNode
	 * receives a Click. The listener may return false to cancel toggling and
	 * focusing on the node.
	 * 
	 * @event clickEvent
	 * @type CustomEvent
	 * @param oArgs.event
	 *            {HTMLEvent} The event object
	 * @param oArgs.node
	 *            {YAHOO.widget.Node} node the node that was clicked
	 */
        this.createEvent("clickEvent", this);

    /**
	 * Fires when the focus receives the focus, when it changes from a Node to
	 * another Node or when it is completely lost (blurred)
	 * 
	 * @event focusChanged
	 * @type CustomEvent
	 * @param oArgs.oldNode
	 *            {YAHOO.widget.Node} Node that had the focus or null if none
	 * @param oArgs.newNode
	 *            {YAHOO.widget.Node} Node that receives the focus or null if
	 *            none
	 */

        this.createEvent('focusChanged',this);

    /**
	 * Fires when the label in a TextNode or MenuNode or content in an HTMLNode
	 * receives a double Click
	 * 
	 * @event dblClickEvent
	 * @type CustomEvent
	 * @param oArgs.event
	 *            {HTMLEvent} The event object
	 * @param oArgs.node
	 *            {YAHOO.widget.Node} node the node that was clicked
	 */
        var self = this;
        this.createEvent("dblClickEvent", {
            scope:this,
            onSubscribeCallback: function() {
                self._hasDblClickSubscriber = true;
            }
        });

    /**
	 * Custom event that is fired when the text node label is clicked. The node
	 * clicked is provided as an argument
	 * 
	 * @event labelClick
	 * @type CustomEvent
	 * @param {YAHOO.widget.Node}
	 *            node the node clicked
	 * @deprecated use clickEvent or dblClickEvent
	 */
        this.createEvent("labelClick", this);

    /**
	 * Custom event fired when the highlight of a node changes. The node that
	 * triggered the change is provided as an argument: The status of the
	 * highlight can be checked in <a
	 * href="YAHOO.widget.Node.html#property_highlightState">nodeRef.highlightState</a>.
	 * Depending on <a
	 * href="YAHOO.widget.Node.html#property_propagateHighlight">nodeRef.propagateHighlight</a>,
	 * other nodes might have changed
	 * 
	 * @event highlightEvent
	 * @type CustomEvent
	 * @param node
	 *            {YAHOO.widget.Node} the node that started the change in
	 *            highlighting state
	 */
        this.createEvent("highlightEvent",this);


        this._nodes = [];

        // store a global reference
        TV.trees[this.id] = this;

        // Set up the root node
        this.root = new Widget.RootNode(this);

        var LW = Widget.LogWriter;



        if (this._initEditor) {
            this._initEditor();
        }

        // YAHOO.util.Event.onContentReady(this.id, this.handleAvailable, this,
		// true);
        // YAHOO.util.Event.on(this.id, "click", this.handleClick, this, true);
    },

    // handleAvailable: function() {
        // var Event = YAHOO.util.Event;
        // Event.on(this.id,
    // },
 /**
	 * Builds the TreeView from an object. This is the method called by the
	 * constructor to build the tree when it has a second argument. A tree can
	 * be described by an array of objects, each object corresponding to a node.
	 * Node descriptions may contain values for any property of a node plus the
	 * following extra properties:
	 * <ul>
	 * <li>type: can be one of the following:
	 * <ul>
	 * <li> A shortname for a node type (<code>'text','menu','html'</code>)
	 * </li>
	 * <li>The name of a Node class under YAHOO.widget (<code>'TextNode', 'MenuNode', 'DateNode'</code>,
	 * etc) </li>
	 * <li>a reference to an actual class: <code>YAHOO.widget.DateNode</code></li>
	 * </ul>
	 * </li>
	 * <li>children: an array containing further node definitions</li>
	 * </ul>
	 * A string instead of an object will produce a node of type 'text' with the
	 * given string as its label.
	 * 
	 * @method buildTreeFromObject
	 * @param oConfig
	 *            {Array|Object|String} array containing a full description of
	 *            the tree. An object or a string will be turned into an array
	 *            with the given object or string as its only element.
	 * 
	 */
    buildTreeFromObject: function (oConfig) {
        var build = function (parent, oConfig) {
            var i, item, node, children, type, NodeType, ThisType;
            for (i = 0; i < oConfig.length; i++) {
                item = oConfig[i];
                if (Lang.isString(item)) {
                    node = new Widget.TextNode(item, parent);
                } else if (Lang.isObject(item)) {
                    children = item.children;
                    delete item.children;
                    type = item.type || 'text';
                    delete item.type;
                    switch (Lang.isString(type) && type.toLowerCase()) {
                        case 'text':
                            node = new Widget.TextNode(item, parent);
                            break;
                        case 'menu':
                            node = new Widget.MenuNode(item, parent);
                            break;
                        case 'html':
                            node = new Widget.HTMLNode(item, parent);
                            break;
                        default:
                            if (Lang.isString(type)) {
                                NodeType = Widget[type];
                            } else {
                                NodeType = type;
                            }
                            if (Lang.isObject(NodeType)) {
                                for (ThisType = NodeType; ThisType && ThisType !== Widget.Node; ThisType = ThisType.superclass.constructor) {}
                                if (ThisType) {
                                    node = new NodeType(item, parent);
                                } else {
                                }
                            } else {
                            }
                    }
                    if (children) {
                        build(node,children);
                    }
                } else {
                }
            }
        };
        if (!Lang.isArray(oConfig)) {
            oConfig = [oConfig];
        }


        build(this.root,oConfig);
    },
/**
 * Builds the TreeView from existing markup. Markup should consist of &lt;UL&gt;
 * or &lt;OL&gt; elements containing &lt;LI&gt; elements. Each &lt;LI&gt; can
 * have one element used as label and a second optional element which is to be a
 * &lt;UL&gt; or &lt;OL&gt; containing nested nodes. Depending on what the first
 * element of the &lt;LI&gt; element is, the following Nodes will be created:
 * <ul>
 * <li>plain text: a regular TextNode</li>
 * <li>anchor &lt;A&gt;: a TextNode with its <code>href</code> and
 * <code>target</code> taken from the anchor</li>
 * <li>anything else: an HTMLNode</li>
 * </ul>
 * Only the first outermost (un-)ordered list in the markup and its children
 * will be parsed. Nodes will be collapsed unless an &lt;LI&gt; tag has a
 * className called 'expanded'. All other className attributes will be copied
 * over to the Node className property. If the &lt;LI&gt; element contains an
 * attribute called <code>yuiConfig</code>, its contents should be a
 * JSON-encoded object as the one used in method <a
 * href="#method_buildTreeFromObject">buildTreeFromObject</a>.
 * 
 * @method buildTreeFromMarkup
 * @param id
 *            {string|HTMLElement} The id of the element that contains the
 *            markup or a reference to it.
 */
    buildTreeFromMarkup: function (id) {
        var build = function (markup) {
            var el, child, branch = [], config = {}, label, yuiConfig;
            // Dom's getFirstChild and getNextSibling skip over text elements
            for (el = Dom.getFirstChild(markup); el; el = Dom.getNextSibling(el)) {
                switch (el.tagName.toUpperCase()) {
                    case 'LI':
                        label = '';
                        config = {
                            expanded: Dom.hasClass(el,'expanded'),
                            title: el.title || el.alt || null,
                            className: Lang.trim(el.className.replace(/\bexpanded\b/,'')) || null
                        };
                        // I cannot skip over text elements here because I want
						// them for labels
                        child = el.firstChild;
                        if (child.nodeType == 3) {
                            // nodes with only whitespace, tabs and new lines
							// don't count, they are probably just formatting.
                            label = Lang.trim(child.nodeValue.replace(/[\n\t\r]*/g,''));
                            if (label) {
                                config.type = 'text';
                                config.label = label;
                            } else {
                                child = Dom.getNextSibling(child);
                            }
                        }
                        if (!label) {
                            if (child.tagName.toUpperCase() == 'A') {
                                config.type = 'text';
                                config.label = child.innerHTML;
                                config.href = child.href;
                                config.target = child.target;
                                config.title = child.title || child.alt || config.title;
                            } else {
                                config.type = 'html';
                                var d = document.createElement('div');
                                d.appendChild(child.cloneNode(true));
                                config.html = d.innerHTML;
                                config.hasIcon = true;
                            }
                        }
                        // see if after the label it has a further list which
						// will become children of this node.
                        child = Dom.getNextSibling(child);
                        switch (child && child.tagName.toUpperCase()) {
                            case 'UL':
                            case 'OL':
                                config.children = build(child);
                                break;
                        }
                        // if there are further elements or text, it will be
						// ignored.

                        if (YAHOO.lang.JSON) {
                            yuiConfig = el.getAttribute('yuiConfig');
                            if (yuiConfig) {
                                yuiConfig = YAHOO.lang.JSON.parse(yuiConfig);
                                config = YAHOO.lang.merge(config,yuiConfig);
                            }
                        }

                        branch.push(config);
                        break;
                    case 'UL':
                    case 'OL':
                        config = {
                            type: 'text',
                            label: '',
                            children: build(child)
                        };
                        branch.push(config);
                        break;
                }
            }
            return branch;
        };

        var markup = Dom.getChildrenBy(Dom.get(id),function (el) {
            var tag = el.tagName.toUpperCase();
            return  tag == 'UL' || tag == 'OL';
        });
        if (markup.length) {
            this.buildTreeFromObject(build(markup[0]));
        } else {
        }
    },
  /**
	 * Returns the TD element where the event has occurred
	 * 
	 * @method _getEventTargetTdEl
	 * @private
	 */
    _getEventTargetTdEl: function (ev) {
        var target = Event.getTarget(ev);
        // go up looking for a TD with a className with a ygtv prefix
        while (target && !(target.tagName.toUpperCase() == 'TD' && Dom.hasClass(target.parentNode,'ygtvrow'))) {
            target = Dom.getAncestorByTagName(target,'td');
        }
        if (Lang.isNull(target)) { return null; }
        // If it is a spacer cell, do nothing
        if (/\bygtv(blank)?depthcell/.test(target.className)) { return null;}
        // If it has an id, search for the node number and see if it belongs to
		// a node in this tree.
        if (target.id) {
            var m = target.id.match(/\bygtv([^\d]*)(.*)/);
            if (m && m[2] && this._nodes[m[2]]) {
                return target;
            }
        }
        return null;
    },
  /**
	 * Event listener for click events
	 * 
	 * @method _onClickEvent
	 * @private
	 */
    _onClickEvent: function (ev) {
        var self = this,
            td = this._getEventTargetTdEl(ev),
            node,
            target,
            toggle = function (force) {
                node.focus();
                if (force || !node.href) {
                    node.toggle();
                    try {
                        Event.preventDefault(ev);
                    } catch (e) {
                        // @TODO
                        // For some reason IE8 is providing an event object with
                        // most of the fields missing, but only when clicking on
                        // the node's label, and only when working with inline
                        // editing. This generates a "Member not found" error
                        // in that browser. Determine if this is a browser
                        // bug, or a problem with this code. Already checked to
                        // see if the problem has to do with access the event
                        // in the outer scope, and that isn't the problem.
                        // Maybe the markup for inline editing is broken.
                    }
                }
            };

        if (!td) {
            return;
        }

        node = this.getNodeByElement(td);
        if (!node) {
            return;
        }

        // exception to handle deprecated event labelClick
        // @TODO take another look at this deprecation. It is common for people
		// to
        // only be interested in the label click, so why make them have to test
        // the node type to figure out whether the click was on the label?
        target = Event.getTarget(ev);
        if (Dom.hasClass(target, node.labelStyle) || Dom.getAncestorByClassName(target,node.labelStyle)) {
            this.fireEvent('labelClick',node);
        }
        // http://yuilibrary.com/projects/yui2/ticket/2528946
        // Ensures that any open editor is closed.
        // Since the editor is in a separate source which might not be included,
        // we first need to ensure we have the _closeEditor method available
        if (this._closeEditor) { this._closeEditor(false); }

        // If it is a toggle cell, toggle
        if (/\bygtv[tl][mp]h?h?/.test(td.className)) {
            toggle(true);
        } else {
            if (this._dblClickTimer) {
                window.clearTimeout(this._dblClickTimer);
                this._dblClickTimer = null;
            } else {
                if (this._hasDblClickSubscriber) {
                    this._dblClickTimer = window.setTimeout(function () {
                        self._dblClickTimer = null;
                        if (self.fireEvent('clickEvent', {event:ev,node:node}) !== false) {
                            toggle();
                        }
                    }, 200);
                } else {
                    if (self.fireEvent('clickEvent', {event:ev,node:node}) !== false) {
                        toggle();
                    }
                }
            }
        }
    },

  /**
	 * Event listener for double-click events
	 * 
	 * @method _onDblClickEvent
	 * @private
	 */
    _onDblClickEvent: function (ev) {
        if (!this._hasDblClickSubscriber) { return; }
        var td = this._getEventTargetTdEl(ev);
        if (!td) {return;}

        if (!(/\bygtv[tl][mp]h?h?/.test(td.className))) {
            this.fireEvent('dblClickEvent', {event:ev, node:this.getNodeByElement(td)});
            if (this._dblClickTimer) {
                window.clearTimeout(this._dblClickTimer);
                this._dblClickTimer = null;
            }
        }
    },
  /**
	 * Event listener for mouse over events
	 * 
	 * @method _onMouseOverEvent
	 * @private
	 */
    _onMouseOverEvent:function (ev) {
        var target;
        if ((target = this._getEventTargetTdEl(ev)) && (target = this.getNodeByElement(target)) && (target = target.getToggleEl())) {
            target.className = target.className.replace(/\bygtv([lt])([mp])\b/gi,'ygtv$1$2h');
        }
    },
  /**
	 * Event listener for mouse out events
	 * 
	 * @method _onMouseOutEvent
	 * @private
	 */
    _onMouseOutEvent: function (ev) {
        var target;
        if ((target = this._getEventTargetTdEl(ev)) && (target = this.getNodeByElement(target)) && (target = target.getToggleEl())) {
            target.className = target.className.replace(/\bygtv([lt])([mp])h\b/gi,'ygtv$1$2');
        }
    },
  /**
	 * Event listener for key down events
	 * 
	 * @method _onKeyDownEvent
	 * @private
	 */
    _onKeyDownEvent: function (ev) {
        var target = Event.getTarget(ev),
            node = this.getNodeByElement(target),
            newNode = node,
            KEY = YAHOO.util.KeyListener.KEY;

        switch(ev.keyCode) {
            case KEY.UP:
                do {
                    if (newNode.previousSibling) {
                        newNode = newNode.previousSibling;
                    } else {
                        newNode = newNode.parent;
                    }
                } while (newNode && !newNode._canHaveFocus());
                if (newNode) { newNode.focus(); }
                Event.preventDefault(ev);
                break;
            case KEY.DOWN:
                do {
                    if (newNode.nextSibling) {
                        newNode = newNode.nextSibling;
                    } else {
                        newNode.expand();
                        newNode = (newNode.children.length || null) && newNode.children[0];
                    }
                } while (newNode && !newNode._canHaveFocus);
                if (newNode) { newNode.focus();}
                Event.preventDefault(ev);
                break;
            case KEY.LEFT:
                do {
                    if (newNode.parent) {
                        newNode = newNode.parent;
                    } else {
                        newNode = newNode.previousSibling;
                    }
                } while (newNode && !newNode._canHaveFocus());
                if (newNode) { newNode.focus();}
                Event.preventDefault(ev);
                break;
            case KEY.RIGHT:
                var self = this,
                    moveFocusRight,
                    focusOnExpand = function (newNode) {
                        self.unsubscribe('expandComplete',focusOnExpand);
                        moveFocusRight(newNode);
                    };
                moveFocusRight = function (newNode) {
                    do {
                        if (newNode.isDynamic() && !newNode.childrenRendered) {
                            self.subscribe('expandComplete',focusOnExpand);
                            newNode.expand();
                            newNode = null;
                            break;
                        } else {
                            newNode.expand();
                            if (newNode.children.length) {
                                newNode = newNode.children[0];
                            } else {
                                newNode = newNode.nextSibling;
                            }
                        }
                    } while (newNode && !newNode._canHaveFocus());
                    if (newNode) { newNode.focus();}
                };

                moveFocusRight(newNode);
                Event.preventDefault(ev);
                break;
            case KEY.ENTER:
                if (node.href) {
                    if (node.target) {
                        window.open(node.href,node.target);
                    } else {
                        window.location(node.href);
                    }
                } else {
                    node.toggle();
                }
                this.fireEvent('enterKeyPressed',node);
                Event.preventDefault(ev);
                break;
            case KEY.HOME:
                newNode = this.getRoot();
                if (newNode.children.length) {newNode = newNode.children[0];}
                if (newNode._canHaveFocus()) { newNode.focus(); }
                Event.preventDefault(ev);
                break;
            case KEY.END:
                newNode = newNode.parent.children;
                newNode = newNode[newNode.length -1];
                if (newNode._canHaveFocus()) { newNode.focus(); }
                Event.preventDefault(ev);
                break;
            // case KEY.PAGE_UP:
                // break;
            // case KEY.PAGE_DOWN:
                // break;
            case 107:  // plus key
            case 187:  // plus key
                if (ev.shiftKey) {
                    node.parent.expandAll();
                } else {
                    node.expand();
                }
                break;
            case 109: // minus key
            case 189: // minus key
                if (ev.shiftKey) {
                    node.parent.collapseAll();
                } else {
                    node.collapse();
                }
                break;
            default:
                break;
        }
    },
    /**
	 * Renders the tree boilerplate and visible nodes
	 * 
	 * @method render
	 */
    render: function() {
        var html = this.root.getHtml(),
            el = this.getEl();
        el.innerHTML = html;
        if (!this._hasEvents) {
            Event.on(el, 'click', this._onClickEvent, this, true);
            Event.on(el, 'dblclick', this._onDblClickEvent, this, true);
            Event.on(el, 'mouseover', this._onMouseOverEvent, this, true);
            Event.on(el, 'mouseout', this._onMouseOutEvent, this, true);
            Event.on(el, 'keydown', this._onKeyDownEvent, this, true);
        }
        this._hasEvents = true;
    },

  /**
	 * Returns the tree's host element
	 * 
	 * @method getEl
	 * @return {HTMLElement} the host element
	 */
    getEl: function() {
        if (! this._el) {
            this._el = Dom.get(this.id);
        }
        return this._el;
    },

    /**
	 * Nodes register themselves with the tree instance when they are created.
	 * 
	 * @method regNode
	 * @param node
	 *            {Node} the node to register
	 * @private
	 */
    regNode: function(node) {
        this._nodes[node.index] = node;
    },

    /**
	 * Returns the root node of this tree
	 * 
	 * @method getRoot
	 * @return {Node} the root node
	 */
    getRoot: function() {
        return this.root;
    },

    /**
	 * Configures this tree to dynamically load all child data
	 * 
	 * @method setDynamicLoad
	 * @param {function}
	 *            fnDataLoader the function that will be called to get the data
	 * @param iconMode
	 *            {int} configures the icon that is displayed when a dynamic
	 *            load node is expanded the first time without children. By
	 *            default, the "collapse" icon will be used. If set to 1, the
	 *            leaf node icon will be displayed.
	 */
    setDynamicLoad: function(fnDataLoader, iconMode) {
        this.root.setDynamicLoad(fnDataLoader, iconMode);
    },

    /**
	 * Expands all child nodes. Note: this conflicts with the "multiExpand" node
	 * property. If expand all is called in a tree with nodes that do not allow
	 * multiple siblings to be displayed, only the last sibling will be
	 * expanded.
	 * 
	 * @method expandAll
	 */
    expandAll: function() {
        if (!this.locked) {
            this.root.expandAll();
        }
    },

    /**
	 * Collapses all expanded child nodes in the entire tree.
	 * 
	 * @method collapseAll
	 */
    collapseAll: function() {
        if (!this.locked) {
            this.root.collapseAll();
        }
    },

    /**
	 * Returns a node in the tree that has the specified index (this index is
	 * created internally, so this function probably will only be used in html
	 * generated for a given node.)
	 * 
	 * @method getNodeByIndex
	 * @param {int}
	 *            nodeIndex the index of the node wanted
	 * @return {Node} the node with index=nodeIndex, null if no match
	 */
    getNodeByIndex: function(nodeIndex) {
        var n = this._nodes[nodeIndex];
        return (n) ? n : null;
    },

    /**
	 * Returns a node that has a matching property and value in the data object
	 * that was passed into its constructor.
	 * 
	 * @method getNodeByProperty
	 * @param {object}
	 *            property the property to search (usually a string)
	 * @param {object}
	 *            value the value we want to find (usuall an int or string)
	 * @return {Node} the matching node, null if no match
	 */
    getNodeByProperty: function(property, value) {
        for (var i in this._nodes) {
            if (this._nodes.hasOwnProperty(i)) {
                var n = this._nodes[i];
                if ((property in n && n[property] == value) || (n.data && value == n.data[property])) {
                    return n;
                }
            }
        }

        return null;
    },

    /**
	 * Returns a collection of nodes that have a matching property and value in
	 * the data object that was passed into its constructor.
	 * 
	 * @method getNodesByProperty
	 * @param {object}
	 *            property the property to search (usually a string)
	 * @param {object}
	 *            value the value we want to find (usuall an int or string)
	 * @return {Array} the matching collection of nodes, null if no match
	 */
    getNodesByProperty: function(property, value) {
        var values = [];
        for (var i in this._nodes) {
            if (this._nodes.hasOwnProperty(i)) {
                var n = this._nodes[i];
                if ((property in n && n[property] == value) || (n.data && value == n.data[property])) {
                    values.push(n);
                }
            }
        }

        return (values.length) ? values : null;
    },


    /**
	 * Returns a collection of nodes that have passed the test function passed
	 * as its only argument. The function will receive a reference to each node
	 * to be tested.
	 * 
	 * @method getNodesBy
	 * @param {function}
	 *            a boolean function that receives a Node instance and returns
	 *            true to add the node to the results list
	 * @return {Array} the matching collection of nodes, null if no match
	 */
    getNodesBy: function(fn) {
        var values = [];
        for (var i in this._nodes) {
            if (this._nodes.hasOwnProperty(i)) {
                var n = this._nodes[i];
                if (fn(n)) {
                    values.push(n);
                }
            }
        }
        return (values.length) ? values : null;
    },
    /**
	 * Returns the treeview node reference for an ancestor element of the node,
	 * or null if it is not contained within any node in this tree.
	 * 
	 * @method getNodeByElement
	 * @param el
	 *            {HTMLElement} the element to test
	 * @return {YAHOO.widget.Node} a node reference or null
	 */
    getNodeByElement: function(el) {

        var p=el, m, re=/ygtv([^\d]*)(.*)/;

        do {

            if (p && p.id) {
                m = p.id.match(re);
                if (m && m[2]) {
                    return this.getNodeByIndex(m[2]);
                }
            }

            p = p.parentNode;

            if (!p || !p.tagName) {
                break;
            }

        }
        while (p.id !== this.id && p.tagName.toLowerCase() !== "body");

        return null;
    },

    /**
	 * When in singleNodeHighlight it returns the node highlighted or null if
	 * none. Returns null if singleNodeHighlight is false.
	 * 
	 * @method getHighlightedNode
	 * @return {YAHOO.widget.Node} a node reference or null
	 */
    getHighlightedNode: function() {
        return this._currentlyHighlighted;
    },


    /**
	 * Removes the node and its children, and optionally refreshes the branch of
	 * the tree that was affected.
	 * 
	 * @method removeNode
	 * @param {Node}
	 *            node to remove
	 * @param {boolean}
	 *            autoRefresh automatically refreshes branch if true
	 * @return {boolean} False is there was a problem, true otherwise.
	 */
    removeNode: function(node, autoRefresh) {

        // Don't delete the root node
        if (node.isRoot()) {
            return false;
        }

        // Get the branch that we may need to refresh
        var p = node.parent;
        if (p.parent) {
            p = p.parent;
        }

        // Delete the node and its children
        this._deleteNode(node);

        // Refresh the parent of the parent
        if (autoRefresh && p && p.childrenRendered) {
            p.refresh();
        }

        return true;
    },

    /**
	 * wait until the animation is complete before deleting to avoid javascript
	 * errors
	 * 
	 * @method _removeChildren_animComplete
	 * @param o
	 *            the custom event payload
	 * @private
	 */
    _removeChildren_animComplete: function(o) {
        this.unsubscribe(this._removeChildren_animComplete);
        this.removeChildren(o.node);
    },

    /**
	 * Deletes this nodes child collection, recursively. Also collapses the
	 * node, and resets the dynamic load flag. The primary use for this method
	 * is to purge a node and allow it to fetch its data dynamically again.
	 * 
	 * @method removeChildren
	 * @param {Node}
	 *            node the node to purge
	 */
    removeChildren: function(node) {

        if (node.expanded) {
            // wait until the animation is complete before deleting to
            // avoid javascript errors
            if (this._collapseAnim) {
                this.subscribe("animComplete",
                        this._removeChildren_animComplete, this, true);
                Widget.Node.prototype.collapse.call(node);
                return;
            }

            node.collapse();
        }

        while (node.children.length) {
            this._deleteNode(node.children[0]);
        }

        if (node.isRoot()) {
            Widget.Node.prototype.expand.call(node);
        }

        node.childrenRendered = false;
        node.dynamicLoadComplete = false;

        node.updateIcon();
    },

    /**
	 * Deletes the node and recurses children
	 * 
	 * @method _deleteNode
	 * @private
	 */
    _deleteNode: function(node) {
        // Remove all the child nodes first
        this.removeChildren(node);

        // Remove the node from the tree
        this.popNode(node);
    },

    /**
	 * Removes the node from the tree, preserving the child collection to make
	 * it possible to insert the branch into another part of the tree, or
	 * another tree.
	 * 
	 * @method popNode
	 * @param {Node}
	 *            node to remove
	 */
    popNode: function(node) {
        var p = node.parent;

        // Update the parent's collection of children
        var a = [];

        for (var i=0, len=p.children.length;i<len;++i) {
            if (p.children[i] != node) {
                a[a.length] = p.children[i];
            }
        }

        p.children = a;

        // reset the childrenRendered flag for the parent
        p.childrenRendered = false;

         // Update the sibling relationship
        if (node.previousSibling) {
            node.previousSibling.nextSibling = node.nextSibling;
        }

        if (node.nextSibling) {
            node.nextSibling.previousSibling = node.previousSibling;
        }

        if (this.currentFocus == node) {
            this.currentFocus = null;
        }
        if (this._currentlyHighlighted == node) {
            this._currentlyHighlighted = null;
        }

        node.parent = null;
        node.previousSibling = null;
        node.nextSibling = null;
        node.tree = null;

        // Update the tree's node collection
        delete this._nodes[node.index];
    },

    /**
	 * Nulls out the entire TreeView instance and related objects, removes
	 * attached event listeners, and clears out DOM elements inside the
	 * container. After calling this method, the instance reference should be
	 * expliclitly nulled by implementer, as in myDataTable = null. Use with
	 * caution!
	 * 
	 * @method destroy
	 */
    destroy : function() {
        // Since the label editor can be separated from the main TreeView
		// control
        // the destroy method for it might not be there.
        if (this._destroyEditor) { this._destroyEditor(); }
        var el = this.getEl();
        Event.removeListener(el,'click');
        Event.removeListener(el,'dblclick');
        Event.removeListener(el,'mouseover');
        Event.removeListener(el,'mouseout');
        Event.removeListener(el,'keydown');
        for (var i = 0 ; i < this._nodes.length; i++) {
            var node = this._nodes[i];
            if (node && node.destroy) {node.destroy(); }
        }
        el.innerHTML = '';
        this._hasEvents = false;
    },




    /**
	 * TreeView instance toString
	 * 
	 * @method toString
	 * @return {string} string representation of the tree
	 */
    toString: function() {
        return "TreeView " + this.id;
    },

    /**
	 * Count of nodes in tree
	 * 
	 * @method getNodeCount
	 * @return {int} number of nodes in the tree
	 */
    getNodeCount: function() {
        return this.getRoot().getNodeCount();
    },

    /**
	 * Returns an object which could be used to rebuild the tree. It can be
	 * passed to the tree constructor to reproduce the same tree. It will return
	 * false if any node loads dynamically, regardless of whether it is loaded
	 * or not.
	 * 
	 * @method getTreeDefinition
	 * @return {Object | false} definition of the tree or false if any node is
	 *         defined as dynamic
	 */
    getTreeDefinition: function() {
        return this.getRoot().getNodeDefinition();
    },

    /**
	 * Abstract method that is executed when a node is expanded
	 * 
	 * @method onExpand
	 * @param node
	 *            {Node} the node that was expanded
	 * @deprecated use treeobj.subscribe("expand") instead
	 */
    onExpand: function(node) { },

    /**
	 * Abstract method that is executed when a node is collapsed.
	 * 
	 * @method onCollapse
	 * @param node
	 *            {Node} the node that was collapsed.
	 * @deprecated use treeobj.subscribe("collapse") instead
	 */
    onCollapse: function(node) { },

    /**
	 * Sets the value of a property for all loaded nodes in the tree.
	 * 
	 * @method setNodesProperty
	 * @param name
	 *            {string} Name of the property to be set
	 * @param value
	 *            {any} value to be set
	 * @param refresh
	 *            {boolean} if present and true, it does a refresh
	 */
    setNodesProperty: function(name, value, refresh) {
        this.root.setNodesProperty(name,value);
        if (refresh) {
            this.root.refresh();
        }
    },
    /**
	 * Event listener to toggle node highlight. Can be assigned as listener to
	 * clickEvent, dblClickEvent and enterKeyPressed. It returns false to
	 * prevent the default action.
	 * 
	 * @method onEventToggleHighlight
	 * @param oArgs
	 *            {any} it takes the arguments of any of the events mentioned
	 *            above
	 * @return {false} Always cancels the default action for the event
	 */
    onEventToggleHighlight: function (oArgs) {
        var node;
        if ('node' in oArgs && oArgs.node instanceof Widget.Node) {
            node = oArgs.node;
        } else if (oArgs instanceof Widget.Node) {
            node = oArgs;
        } else {
            return false;
        }
        node.toggleHighlight();
        return false;
    }


};

/* Backwards compatibility aliases */
var PROT = TV.prototype;
 /**
	 * Renders the tree boilerplate and visible nodes. Alias for render
	 * 
	 * @method draw
	 * @deprecated Use render instead
	 */
PROT.draw = PROT.render;

/* end backwards compatibility aliases */

YAHOO.augment(TV, YAHOO.util.EventProvider);

/**
 * Running count of all nodes created in all trees. This is used to provide
 * unique identifies for all nodes. Deleting nodes does not change the
 * nodeCount.
 * 
 * @property YAHOO.widget.TreeView.nodeCount
 * @type int
 * @static
 */
TV.nodeCount = 0;

/**
 * Global cache of tree instances
 * 
 * @property YAHOO.widget.TreeView.trees
 * @type Array
 * @static
 * @private
 */
TV.trees = [];

/**
 * Global method for getting a tree by its id. Used in the generated tree html.
 * 
 * @method YAHOO.widget.TreeView.getTree
 * @param treeId
 *            {String} the id of the tree instance
 * @return {TreeView} the tree instance requested, null if not found.
 * @static
 */
TV.getTree = function(treeId) {
    var t = TV.trees[treeId];
    return (t) ? t : null;
};


/**
 * Global method for getting a node by its id. Used in the generated tree html.
 * 
 * @method YAHOO.widget.TreeView.getNode
 * @param treeId
 *            {String} the id of the tree instance
 * @param nodeIndex
 *            {String} the index of the node to return
 * @return {Node} the node instance requested, null if not found
 * @static
 */
TV.getNode = function(treeId, nodeIndex) {
    var t = TV.getTree(treeId);
    return (t) ? t.getNodeByIndex(nodeIndex) : null;
};


/**
 * Class name assigned to elements that have the focus
 * 
 * @property TreeView.FOCUS_CLASS_NAME
 * @type String
 * @static
 * @final
 * @default "ygtvfocus"
 * 
 */
TV.FOCUS_CLASS_NAME = 'ygtvfocus';



})();
(function () {
    var Dom = YAHOO.util.Dom,
        Lang = YAHOO.lang,
        Event = YAHOO.util.Event;
/**
 * The base class for all tree nodes. The node's presentation and behavior in
 * response to mouse events is handled in Node subclasses.
 * 
 * @namespace YAHOO.widget
 * @class Node
 * @uses YAHOO.util.EventProvider
 * @param oData
 *            {object} a string or object containing the data that will be used
 *            to render this node, and any custom attributes that should be
 *            stored with the node (which is available in noderef.data). All
 *            values in oData will be used to set equally named properties in
 *            the node as long as the node does have such properties, they are
 *            not undefined, private or functions, the rest of the values will
 *            be stored in noderef.data
 * @param oParent
 *            {Node} this node's parent node
 * @param expanded
 *            {boolean} the initial expanded/collapsed state (deprecated, use
 *            oData.expanded)
 * @constructor
 */
YAHOO.widget.Node = function(oData, oParent, expanded) {
    if (oData) { this.init(oData, oParent, expanded); }
};

YAHOO.widget.Node.prototype = {

    /**
	 * The index for this instance obtained from global counter in
	 * YAHOO.widget.TreeView.
	 * 
	 * @property index
	 * @type int
	 */
    index: 0,

    /**
	 * This node's child node collection.
	 * 
	 * @property children
	 * @type Node[]
	 */
    children: null,

    /**
	 * Tree instance this node is part of
	 * 
	 * @property tree
	 * @type TreeView
	 */
    tree: null,

    /**
	 * The data linked to this node. This can be any object or primitive value,
	 * and the data can be used in getNodeHtml().
	 * 
	 * @property data
	 * @type object
	 */
    data: null,

    /**
	 * Parent node
	 * 
	 * @property parent
	 * @type Node
	 */
    parent: null,

    /**
	 * The depth of this node. We start at -1 for the root node.
	 * 
	 * @property depth
	 * @type int
	 */
    depth: -1,

    /**
	 * The node's expanded/collapsed state
	 * 
	 * @property expanded
	 * @type boolean
	 */
    expanded: false,

    /**
	 * Can multiple children be expanded at once?
	 * 
	 * @property multiExpand
	 * @type boolean
	 */
    multiExpand: true,

    /**
	 * Should we render children for a collapsed node? It is possible that the
	 * implementer will want to render the hidden data...
	 * 
	 * @todo verify that we need this, and implement it if we do.
	 * @property renderHidden
	 * @type boolean
	 */
    renderHidden: false,

    /**
	 * This flag is set to true when the html is generated for this node's
	 * children, and set to false when new children are added.
	 * 
	 * @property childrenRendered
	 * @type boolean
	 */
    childrenRendered: false,

    /**
	 * Dynamically loaded nodes only fetch the data the first time they are
	 * expanded. This flag is set to true once the data has been fetched.
	 * 
	 * @property dynamicLoadComplete
	 * @type boolean
	 */
    dynamicLoadComplete: false,

    /**
	 * This node's previous sibling
	 * 
	 * @property previousSibling
	 * @type Node
	 */
    previousSibling: null,

    /**
	 * This node's next sibling
	 * 
	 * @property nextSibling
	 * @type Node
	 */
    nextSibling: null,

    /**
	 * We can set the node up to call an external method to get the child data
	 * dynamically.
	 * 
	 * @property _dynLoad
	 * @type boolean
	 * @private
	 */
    _dynLoad: false,

    /**
	 * Function to execute when we need to get this node's child data.
	 * 
	 * @property dataLoader
	 * @type function
	 */
    dataLoader: null,

    /**
	 * This is true for dynamically loading nodes while waiting for the callback
	 * to return.
	 * 
	 * @property isLoading
	 * @type boolean
	 */
    isLoading: false,

    /**
	 * The toggle/branch icon will not show if this is set to false. This could
	 * be useful if the implementer wants to have the child contain extra info
	 * about the parent, rather than an actual node.
	 * 
	 * @property hasIcon
	 * @type boolean
	 */
    hasIcon: true,

    /**
	 * Used to configure what happens when a dynamic load node is expanded and
	 * we discover that it does not have children. By default, it is treated as
	 * if it still could have children (plus/minus icon). Set iconMode to have
	 * it display like a leaf node instead.
	 * 
	 * @property iconMode
	 * @type int
	 */
    iconMode: 0,

    /**
	 * Specifies whether or not the content area of the node should be allowed
	 * to wrap.
	 * 
	 * @property nowrap
	 * @type boolean
	 * @default false
	 */
    nowrap: false,

 /**
	 * If true, the node will alway be rendered as a leaf node. This can be used
	 * to override the presentation when dynamically loading the entire tree.
	 * Setting this to true also disables the dynamic load call for the node.
	 * 
	 * @property isLeaf
	 * @type boolean
	 * @default false
	 */
    isLeaf: false,

/**
 * The CSS class for the html content container. Defaults to ygtvhtml, but can
 * be overridden to provide a custom presentation for a specific node.
 * 
 * @property contentStyle
 * @type string
 */
    contentStyle: "",


    /**
	 * The generated id that will contain the data passed in by the implementer.
	 * 
	 * @property contentElId
	 * @type string
	 */
    contentElId: null,

/**
 * Enables node highlighting. If true, the node can be highlighted and/or
 * propagate highlighting
 * 
 * @property enableHighlight
 * @type boolean
 * @default true
 */
    enableHighlight: true,

/**
 * Stores the highlight state. Can be any of:
 * <ul>
 * <li>0 - not highlighted</li>
 * <li>1 - highlighted</li>
 * <li>2 - some children highlighted</li>
 * </ul>
 * 
 * @property highlightState
 * @type integer
 * @default 0
 */

 highlightState: 0,

 /**
	 * Tells whether highlighting will be propagated up to the parents of the
	 * clicked node
	 * 
	 * @property propagateHighlightUp
	 * @type boolean
	 * @default false
	 */

 propagateHighlightUp: false,

 /**
	 * Tells whether highlighting will be propagated down to the children of the
	 * clicked node
	 * 
	 * @property propagateHighlightDown
	 * @type boolean
	 * @default false
	 */

 propagateHighlightDown: false,

 /**
	 * User-defined className to be added to the Node
	 * 
	 * @property className
	 * @type string
	 * @default null
	 */

 className: null,

 /**
	 * The node type
	 * 
	 * @property _type
	 * @private
	 * @type string
	 * @default "Node"
	 */
    _type: "Node",

    /*
	 * spacerPath: "http://l.yimg.com/a/i/space.gif", expandedText: "Expanded",
	 * collapsedText: "Collapsed", loadingText: "Loading",
	 */

    /**
	 * Initializes this node, gets some of the properties from the parent
	 * 
	 * @method init
	 * @param oData
	 *            {object} a string or object containing the data that will be
	 *            used to render this node
	 * @param oParent
	 *            {Node} this node's parent node
	 * @param expanded
	 *            {boolean} the initial expanded/collapsed state
	 */
    init: function(oData, oParent, expanded) {

        this.data = {};
        this.children   = [];
        this.index      = YAHOO.widget.TreeView.nodeCount;
        ++YAHOO.widget.TreeView.nodeCount;
        this.contentElId = "ygtvcontentel" + this.index;

        if (Lang.isObject(oData)) {
            for (var property in oData) {
                if (oData.hasOwnProperty(property)) {
                    if (property.charAt(0) != '_'  && !Lang.isUndefined(this[property]) && !Lang.isFunction(this[property]) ) {
                        this[property] = oData[property];
                    } else {
                        this.data[property] = oData[property];
                    }
                }
            }
        }
        if (!Lang.isUndefined(expanded) ) { this.expanded  = expanded;  }


        /**
		 * The parentChange event is fired when a parent element is applied to
		 * the node. This is useful if you need to apply tree-level properties
		 * to a tree that need to happen if a node is moved from one tree to
		 * another.
		 * 
		 * @event parentChange
		 * @type CustomEvent
		 */
        this.createEvent("parentChange", this);

        // oParent should never be null except when we create the root node.
        if (oParent) {
            oParent.appendChild(this);
        }
    },

    /**
	 * Certain properties for the node cannot be set until the parent is known.
	 * This is called after the node is inserted into a tree. the parent is also
	 * applied to this node's children in order to make it possible to move a
	 * branch from one tree to another.
	 * 
	 * @method applyParent
	 * @param {Node}
	 *            parentNode this node's parent node
	 * @return {boolean} true if the application was successful
	 */
    applyParent: function(parentNode) {
        if (!parentNode) {
            return false;
        }

        this.tree   = parentNode.tree;
        this.parent = parentNode;
        this.depth  = parentNode.depth + 1;

        // @todo why was this put here. This causes new nodes added at the
        // root level to lose the menu behavior.
        // if (! this.multiExpand) {
            // this.multiExpand = parentNode.multiExpand;
        // }

        this.tree.regNode(this);
        parentNode.childrenRendered = false;

        // cascade update existing children
        for (var i=0, len=this.children.length;i<len;++i) {
            this.children[i].applyParent(this);
        }

        this.fireEvent("parentChange");

        return true;
    },

    /**
	 * Appends a node to the child collection.
	 * 
	 * @method appendChild
	 * @param childNode
	 *            {Node} the new node
	 * @return {Node} the child node
	 * @private
	 */
    appendChild: function(childNode) {
        if (this.hasChildren()) {
            var sib = this.children[this.children.length - 1];
            sib.nextSibling = childNode;
            childNode.previousSibling = sib;
        }
        this.children[this.children.length] = childNode;
        childNode.applyParent(this);

        // part of the IE display issue workaround. If child nodes
        // are added after the initial render, and the node was
        // instantiated with expanded = true, we need to show the
        // children div now that the node has a child.
        if (this.childrenRendered && this.expanded) {
            this.getChildrenEl().style.display = "";
        }

        return childNode;
    },

    /**
	 * Appends this node to the supplied node's child collection
	 * 
	 * @method appendTo
	 * @param parentNode
	 *            {Node} the node to append to.
	 * @return {Node} The appended node
	 */
    appendTo: function(parentNode) {
        return parentNode.appendChild(this);
    },

    /**
	 * Inserts this node before this supplied node
	 * 
	 * @method insertBefore
	 * @param node
	 *            {Node} the node to insert this node before
	 * @return {Node} the inserted node
	 */
    insertBefore: function(node) {
        var p = node.parent;
        if (p) {

            if (this.tree) {
                this.tree.popNode(this);
            }

            var refIndex = node.isChildOf(p);
            p.children.splice(refIndex, 0, this);
            if (node.previousSibling) {
                node.previousSibling.nextSibling = this;
            }
            this.previousSibling = node.previousSibling;
            this.nextSibling = node;
            node.previousSibling = this;

            this.applyParent(p);
        }

        return this;
    },

    /**
	 * Inserts this node after the supplied node
	 * 
	 * @method insertAfter
	 * @param node
	 *            {Node} the node to insert after
	 * @return {Node} the inserted node
	 */
    insertAfter: function(node) {
        var p = node.parent;
        if (p) {

            if (this.tree) {
                this.tree.popNode(this);
            }

            var refIndex = node.isChildOf(p);

            if (!node.nextSibling) {
                this.nextSibling = null;
                return this.appendTo(p);
            }

            p.children.splice(refIndex + 1, 0, this);

            node.nextSibling.previousSibling = this;
            this.previousSibling = node;
            this.nextSibling = node.nextSibling;
            node.nextSibling = this;

            this.applyParent(p);
        }

        return this;
    },

    /**
	 * Returns true if the Node is a child of supplied Node
	 * 
	 * @method isChildOf
	 * @param parentNode
	 *            {Node} the Node to check
	 * @return {boolean} The node index if this Node is a child of supplied
	 *         Node, else -1.
	 * @private
	 */
    isChildOf: function(parentNode) {
        if (parentNode && parentNode.children) {
            for (var i=0, len=parentNode.children.length; i<len ; ++i) {
                if (parentNode.children[i] === this) {
                    return i;
                }
            }
        }

        return -1;
    },

    /**
	 * Returns a node array of this node's siblings, null if none.
	 * 
	 * @method getSiblings
	 * @return Node[]
	 */
    getSiblings: function() {
        var sib =  this.parent.children.slice(0);
        for (var i=0;i < sib.length && sib[i] != this;i++) {}
        sib.splice(i,1);
        if (sib.length) { return sib; }
        return null;
    },

    /**
	 * Shows this node's children
	 * 
	 * @method showChildren
	 */
    showChildren: function() {
        if (!this.tree.animateExpand(this.getChildrenEl(), this)) {
            if (this.hasChildren()) {
                this.getChildrenEl().style.display = "";
            }
        }
    },

    /**
	 * Hides this node's children
	 * 
	 * @method hideChildren
	 */
    hideChildren: function() {

        if (!this.tree.animateCollapse(this.getChildrenEl(), this)) {
            this.getChildrenEl().style.display = "none";
        }
    },

    /**
	 * Returns the id for this node's container div
	 * 
	 * @method getElId
	 * @return {string} the element id
	 */
    getElId: function() {
        return "ygtv" + this.index;
    },

    /**
	 * Returns the id for this node's children div
	 * 
	 * @method getChildrenElId
	 * @return {string} the element id for this node's children div
	 */
    getChildrenElId: function() {
        return "ygtvc" + this.index;
    },

    /**
	 * Returns the id for this node's toggle element
	 * 
	 * @method getToggleElId
	 * @return {string} the toggel element id
	 */
    getToggleElId: function() {
        return "ygtvt" + this.index;
    },


    /*
	 * Returns the id for this node's spacer image. The spacer is positioned
	 * over the toggle and provides feedback for screen readers. @method
	 * getSpacerId @return {string} the id for the spacer image
	 */
    /*
	 * getSpacerId: function() { return "ygtvspacer" + this.index; },
	 */

    /**
	 * Returns this node's container html element
	 * 
	 * @method getEl
	 * @return {HTMLElement} the container html element
	 */
    getEl: function() {
        return Dom.get(this.getElId());
    },

    /**
	 * Returns the div that was generated for this node's children
	 * 
	 * @method getChildrenEl
	 * @return {HTMLElement} this node's children div
	 */
    getChildrenEl: function() {
        return Dom.get(this.getChildrenElId());
    },

    /**
	 * Returns the element that is being used for this node's toggle.
	 * 
	 * @method getToggleEl
	 * @return {HTMLElement} this node's toggle html element
	 */
    getToggleEl: function() {
        return Dom.get(this.getToggleElId());
    },
    /**
	 * Returns the outer html element for this node's content
	 * 
	 * @method getContentEl
	 * @return {HTMLElement} the element
	 */
    getContentEl: function() {
        return Dom.get(this.contentElId);
    },


    /*
	 * Returns the element that is being used for this node's spacer. @method
	 * getSpacer @return {HTMLElement} this node's spacer html element
	 */
    /*
	 * getSpacer: function() { return document.getElementById(
	 * this.getSpacerId() ) || {}; },
	 */

    /*
	 * getStateText: function() { if (this.isLoading) { return this.loadingText; }
	 * else if (this.hasChildren(true)) { if (this.expanded) { return
	 * this.expandedText; } else { return this.collapsedText; } } else { return
	 * ""; } },
	 */

  /**
	 * Hides this nodes children (creating them if necessary), changes the
	 * toggle style.
	 * 
	 * @method collapse
	 */
    collapse: function() {
        // Only collapse if currently expanded
        if (!this.expanded) { return; }

        // fire the collapse event handler
        var ret = this.tree.onCollapse(this);

        if (false === ret) {
            return;
        }

        ret = this.tree.fireEvent("collapse", this);

        if (false === ret) {
            return;
        }


        if (!this.getEl()) {
            this.expanded = false;
        } else {
            // hide the child div
            this.hideChildren();
            this.expanded = false;

            this.updateIcon();
        }

        // this.getSpacer().title = this.getStateText();

        ret = this.tree.fireEvent("collapseComplete", this);

    },

    /**
	 * Shows this nodes children (creating them if necessary), changes the
	 * toggle style, and collapses its siblings if multiExpand is not set.
	 * 
	 * @method expand
	 */
    expand: function(lazySource) {
        // Only expand if currently collapsed.
        if (this.isLoading || (this.expanded && !lazySource)) {
            return;
        }

        var ret = true;

        // When returning from the lazy load handler, expand is called again
        // in order to render the new children. The "expand" event already
        // fired before fething the new data, so we need to skip it now.
        if (!lazySource) {
            // fire the expand event handler
            ret = this.tree.onExpand(this);

            if (false === ret) {
                return;
            }

            ret = this.tree.fireEvent("expand", this);
        }

        if (false === ret) {
            return;
        }

        if (!this.getEl()) {
            this.expanded = true;
            return;
        }

        if (!this.childrenRendered) {
            this.getChildrenEl().innerHTML = this.renderChildren();
        } else {
        }

        this.expanded = true;

        this.updateIcon();

        // this.getSpacer().title = this.getStateText();

        // We do an extra check for children here because the lazy
        // load feature can expose nodes that have no children.

        // if (!this.hasChildren()) {
        if (this.isLoading) {
            this.expanded = false;
            return;
        }

        if (! this.multiExpand) {
            var sibs = this.getSiblings();
            for (var i=0; sibs && i<sibs.length; ++i) {
                if (sibs[i] != this && sibs[i].expanded) {
                    sibs[i].collapse();
                }
            }
        }

        this.showChildren();

        ret = this.tree.fireEvent("expandComplete", this);
    },

    updateIcon: function() {
        if (this.hasIcon) {
            var el = this.getToggleEl();
            if (el) {
                el.className = el.className.replace(/\bygtv(([tl][pmn]h?)|(loading))\b/gi,this.getStyle());
            }
        }
        el = Dom.get('ygtvtableel' + this.index);
        if (el) {
            if (this.expanded) {
                Dom.replaceClass(el,'ygtv-collapsed','ygtv-expanded');
            } else {
                Dom.replaceClass(el,'ygtv-expanded','ygtv-collapsed');
            }
        }
    },

    /**
	 * Returns the css style name for the toggle
	 * 
	 * @method getStyle
	 * @return {string} the css class for this node's toggle
	 */
    getStyle: function() {
        if (this.isLoading) {
            return "ygtvloading";
        } else {
            // location top or bottom, middle nodes also get the top style
            var loc = (this.nextSibling) ? "t" : "l";

            // type p=plus(expand), m=minus(collapase), n=none(no children)
            var type = "n";
            if (this.hasChildren(true) || (this.isDynamic() && !this.getIconMode())) {
            // if (this.hasChildren(true)) {
                type = (this.expanded) ? "m" : "p";
            }

            return "ygtv" + loc + type;
        }
    },

    /**
	 * Returns the hover style for the icon
	 * 
	 * @return {string} the css class hover state
	 * @method getHoverStyle
	 */
    getHoverStyle: function() {
        var s = this.getStyle();
        if (this.hasChildren(true) && !this.isLoading) {
            s += "h";
        }
        return s;
    },

    /**
	 * Recursively expands all of this node's children.
	 * 
	 * @method expandAll
	 */
    expandAll: function() {
        var l = this.children.length;
        for (var i=0;i<l;++i) {
            var c = this.children[i];
            if (c.isDynamic()) {
                break;
            } else if (! c.multiExpand) {
                break;
            } else {
                c.expand();
                c.expandAll();
            }
        }
    },

    /**
	 * Recursively collapses all of this node's children.
	 * 
	 * @method collapseAll
	 */
    collapseAll: function() {
        for (var i=0;i<this.children.length;++i) {
            this.children[i].collapse();
            this.children[i].collapseAll();
        }
    },

    /**
	 * Configures this node for dynamically obtaining the child data when the
	 * node is first expanded. Calling it without the callback will turn off
	 * dynamic load for the node.
	 * 
	 * @method setDynamicLoad
	 * @param fmDataLoader
	 *            {function} the function that will be used to get the data.
	 * @param iconMode
	 *            {int} configures the icon that is displayed when a dynamic
	 *            load node is expanded the first time without children. By
	 *            default, the "collapse" icon will be used. If set to 1, the
	 *            leaf node icon will be displayed.
	 */
    setDynamicLoad: function(fnDataLoader, iconMode) {
        if (fnDataLoader) {
            this.dataLoader = fnDataLoader;
            this._dynLoad = true;
        } else {
            this.dataLoader = null;
            this._dynLoad = false;
        }

        if (iconMode) {
            this.iconMode = iconMode;
        }
    },

    /**
	 * Evaluates if this node is the root node of the tree
	 * 
	 * @method isRoot
	 * @return {boolean} true if this is the root node
	 */
    isRoot: function() {
        return (this == this.tree.root);
    },

    /**
	 * Evaluates if this node's children should be loaded dynamically. Looks for
	 * the property both in this instance and the root node. If the tree is
	 * defined to load all children dynamically, the data callback function is
	 * defined in the root node
	 * 
	 * @method isDynamic
	 * @return {boolean} true if this node's children are to be loaded
	 *         dynamically
	 */
    isDynamic: function() {
        if (this.isLeaf) {
            return false;
        } else {
            return (!this.isRoot() && (this._dynLoad || this.tree.root._dynLoad));
            // return lazy;
        }
    },

    /**
	 * Returns the current icon mode. This refers to the way childless dynamic
	 * load nodes appear (this comes into play only after the initial dynamic
	 * load request produced no children).
	 * 
	 * @method getIconMode
	 * @return {int} 0 for collapse style, 1 for leaf node style
	 */
    getIconMode: function() {
        return (this.iconMode || this.tree.root.iconMode);
    },

    /**
	 * Checks if this node has children. If this node is lazy-loading and the
	 * children have not been rendered, we do not know whether or not there are
	 * actual children. In most cases, we need to assume that there are children
	 * (for instance, the toggle needs to show the expandable presentation
	 * state). In other times we want to know if there are rendered children.
	 * For the latter, "checkForLazyLoad" should be false.
	 * 
	 * @method hasChildren
	 * @param checkForLazyLoad
	 *            {boolean} should we check for unloaded children?
	 * @return {boolean} true if this has children or if it might and we are
	 *         checking for this condition.
	 */
    hasChildren: function(checkForLazyLoad) {
        if (this.isLeaf) {
            return false;
        } else {
            return ( this.children.length > 0 ||
                (checkForLazyLoad && this.isDynamic() && !this.dynamicLoadComplete)
            );
        }
    },

    /**
	 * Expands if node is collapsed, collapses otherwise.
	 * 
	 * @method toggle
	 */
    toggle: function() {
        if (!this.tree.locked && ( this.hasChildren(true) || this.isDynamic()) ) {
            if (this.expanded) { this.collapse(); } else { this.expand(); }
        }
    },

    /**
	 * Returns the markup for this node and its children.
	 * 
	 * @method getHtml
	 * @return {string} the markup for this node and its expanded children.
	 */
    getHtml: function() {

        this.childrenRendered = false;

        return ['<div class="ygtvitem" id="' , this.getElId() , '">' ,this.getNodeHtml() , this.getChildrenHtml() ,'</div>'].join("");
    },

    /**
	 * Called when first rendering the tree. We always build the div that will
	 * contain this nodes children, but we don't render the children themselves
	 * unless this node is expanded.
	 * 
	 * @method getChildrenHtml
	 * @return {string} the children container div html and any expanded
	 *         children
	 * @private
	 */
    getChildrenHtml: function() {


        var sb = [];
        sb[sb.length] = '<div class="ygtvchildren" id="' + this.getChildrenElId() + '"';

        // This is a workaround for an IE rendering issue, the child div has
		// layout
        // in IE, creating extra space if a leaf node is created with the
		// expanded
        // property set to true.
        if (!this.expanded || !this.hasChildren()) {
            sb[sb.length] = ' style="display:none;"';
        }
        sb[sb.length] = '>';


        // Don't render the actual child node HTML unless this node is expanded.
        if ( (this.hasChildren(true) && this.expanded) ||
                (this.renderHidden && !this.isDynamic()) ) {
            sb[sb.length] = this.renderChildren();
        }

        sb[sb.length] = '</div>';

        return sb.join("");
    },

    /**
	 * Generates the markup for the child nodes. This is not done until the node
	 * is expanded.
	 * 
	 * @method renderChildren
	 * @return {string} the html for this node's children
	 * @private
	 */
    renderChildren: function() {


        var node = this;

        if (this.isDynamic() && !this.dynamicLoadComplete) {
            this.isLoading = true;
            this.tree.locked = true;

            if (this.dataLoader) {

                setTimeout(
                    function() {
                        node.dataLoader(node,
                            function() {
                                node.loadComplete();
                            });
                    }, 10);

            } else if (this.tree.root.dataLoader) {

                setTimeout(
                    function() {
                        node.tree.root.dataLoader(node,
                            function() {
                                node.loadComplete();
                            });
                    }, 10);

            } else {
                return "Error: data loader not found or not specified.";
            }

            return "";

        } else {
            return this.completeRender();
        }
    },

    /**
	 * Called when we know we have all the child data.
	 * 
	 * @method completeRender
	 * @return {string} children html
	 */
    completeRender: function() {
        var sb = [];

        for (var i=0; i < this.children.length; ++i) {
            // this.children[i].childrenRendered = false;
            sb[sb.length] = this.children[i].getHtml();
        }

        this.childrenRendered = true;

        return sb.join("");
    },

    /**
	 * Load complete is the callback function we pass to the data provider in
	 * dynamic load situations.
	 * 
	 * @method loadComplete
	 */
    loadComplete: function() {
        this.getChildrenEl().innerHTML = this.completeRender();
        if (this.propagateHighlightDown) {
            if (this.highlightState === 1 && !this.tree.singleNodeHighlight) {
                for (var i = 0; i < this.children.length; i++) {
                this.children[i].highlight(true);
            }
            } else if (this.highlightState === 0 || this.tree.singleNodeHighlight) {
                for (i = 0; i < this.children.length; i++) {
                    this.children[i].unhighlight(true);
                }
            } // if (highlighState == 2) leave child nodes with whichever
				// highlight state they are set
        }

        this.dynamicLoadComplete = true;
        this.isLoading = false;
        this.expand(true);
        this.tree.locked = false;
    },

    /**
	 * Returns this node's ancestor at the specified depth.
	 * 
	 * @method getAncestor
	 * @param {int}
	 *            depth the depth of the ancestor.
	 * @return {Node} the ancestor
	 */
    getAncestor: function(depth) {
        if (depth >= this.depth || depth < 0)  {
            return null;
        }

        var p = this.parent;

        while (p.depth > depth) {
            p = p.parent;
        }

        return p;
    },

    /**
	 * Returns the css class for the spacer at the specified depth for this
	 * node. If this node's ancestor at the specified depth has a next sibling
	 * the presentation is different than if it does not have a next sibling
	 * 
	 * @method getDepthStyle
	 * @param {int}
	 *            depth the depth of the ancestor.
	 * @return {string} the css class for the spacer
	 */
    getDepthStyle: function(depth) {
        return (this.getAncestor(depth).nextSibling) ?
            "ygtvdepthcell" : "ygtvblankdepthcell";
    },

    /**
	 * Get the markup for the node. This may be overrided so that we can support
	 * different types of nodes.
	 * 
	 * @method getNodeHtml
	 * @return {string} The HTML that will render this node.
	 */
    getNodeHtml: function() {
        var sb = [];

        sb[sb.length] = '<table id="ygtvtableel' + this.index + '" border="0" cellpadding="0" cellspacing="0" class="ygtvtable ygtvdepth' + this.depth;
        sb[sb.length] = ' ygtv-' + (this.expanded?'expanded':'collapsed');
        if (this.enableHighlight) {
            sb[sb.length] = ' ygtv-highlight' + this.highlightState;
        }
        if (this.className) {
            sb[sb.length] = ' ' + this.className;
        }
        sb[sb.length] = '"><tr class="ygtvrow">';

        for (var i=0;i<this.depth;++i) {
            sb[sb.length] = '<td class="ygtvcell ' + this.getDepthStyle(i) + '"><div class="ygtvspacer"></div></td>';
        }

        if (this.hasIcon) {
            sb[sb.length] = '<td id="' + this.getToggleElId();
            sb[sb.length] = '" class="ygtvcell ';
            sb[sb.length] = this.getStyle() ;
            sb[sb.length] = '"><a href="#" class="ygtvspacer">&#160;</a></td>';
        }

        sb[sb.length] = '<td id="' + this.contentElId;
        sb[sb.length] = '" class="ygtvcell ';
        sb[sb.length] = this.contentStyle  + ' ygtvcontent" ';
        sb[sb.length] = (this.nowrap) ? ' nowrap="nowrap" ' : '';
        sb[sb.length] = ' >';
        sb[sb.length] = this.getContentHtml();
        sb[sb.length] = '</td></tr></table>';

        return sb.join("");

    },
    /**
	 * Get the markup for the contents of the node. This is designed to be
	 * overrided so that we can support different types of nodes.
	 * 
	 * @method getContentHtml
	 * @return {string} The HTML that will render the content of this node.
	 */
    getContentHtml: function () {
        return "";
    },

    /**
	 * Regenerates the html for this node and its children. To be used when the
	 * node is expanded and new children have been added.
	 * 
	 * @method refresh
	 */
    refresh: function() {
        // this.loadComplete();
        this.getChildrenEl().innerHTML = this.completeRender();

        if (this.hasIcon) {
            var el = this.getToggleEl();
            if (el) {
                el.className = el.className.replace(/\bygtv[lt][nmp]h*\b/gi,this.getStyle());
            }
        }
    },

    /**
	 * Node toString
	 * 
	 * @method toString
	 * @return {string} string representation of the node
	 */
    toString: function() {
        return this._type + " (" + this.index + ")";
    },
    /**
	 * array of items that had the focus set on them so that they can be cleaned
	 * when focus is lost
	 * 
	 * @property _focusHighlightedItems
	 * @type Array of DOM elements
	 * @private
	 */
    _focusHighlightedItems: [],
    /**
	 * DOM element that actually got the browser focus
	 * 
	 * @property _focusedItem
	 * @type DOM element
	 * @private
	 */
    _focusedItem: null,

    /**
	 * Returns true if there are any elements in the node that can accept the
	 * real actual browser focus
	 * 
	 * @method _canHaveFocus
	 * @return {boolean} success
	 * @private
	 */
    _canHaveFocus: function() {
        return this.getEl().getElementsByTagName('a').length > 0;
    },
    /**
	 * Removes the focus of previously selected Node
	 * 
	 * @method _removeFocus
	 * @private
	 */
    _removeFocus:function () {
        if (this._focusedItem) {
            Event.removeListener(this._focusedItem,'blur');
            this._focusedItem = null;
        }
        var el;
        while ((el = this._focusHighlightedItems.shift())) {  // yes, it is
																// meant as an
																// assignment,
																// really
            Dom.removeClass(el,YAHOO.widget.TreeView.FOCUS_CLASS_NAME );
        }
    },
    /**
	 * Sets the focus on the node element. It will only be able to set the focus
	 * on nodes that have anchor elements in it. Toggle or branch icons have
	 * anchors and can be focused on. If will fail in nodes that have no anchor
	 * 
	 * @method focus
	 * @return {boolean} success
	 */
    focus: function () {
        var focused = false, self = this;

        if (this.tree.currentFocus) {
            this.tree.currentFocus._removeFocus();
        }

        var  expandParent = function (node) {
            if (node.parent) {
                expandParent(node.parent);
                node.parent.expand();
            }
        };
        expandParent(this);

        Dom.getElementsBy  (
            function (el) {
                return (/ygtv(([tl][pmn]h?)|(content))/).test(el.className);
            } ,
            'td' ,
            self.getEl().firstChild ,
            function (el) {
                Dom.addClass(el, YAHOO.widget.TreeView.FOCUS_CLASS_NAME );
                if (!focused) {
                    var aEl = el.getElementsByTagName('a');
                    if (aEl.length) {
                        aEl = aEl[0];
                        aEl.focus();
                        self._focusedItem = aEl;
                        Event.on(aEl,'blur',function () {
                            self.tree.fireEvent('focusChanged',{oldNode:self.tree.currentFocus,newNode:null});
                            self.tree.currentFocus = null;
                            self._removeFocus();
                        });
                        focused = true;
                    }
                }
                self._focusHighlightedItems.push(el);
            }
        );
        if (focused) {
            this.tree.fireEvent('focusChanged',{oldNode:this.tree.currentFocus,newNode:this});
            this.tree.currentFocus = this;
        } else {
            this.tree.fireEvent('focusChanged',{oldNode:self.tree.currentFocus,newNode:null});
            this.tree.currentFocus = null;
            this._removeFocus();
        }
        return focused;
    },

  /**
	 * Count of nodes in a branch
	 * 
	 * @method getNodeCount
	 * @return {int} number of nodes in the branch
	 */
    getNodeCount: function() {
        for (var i = 0, count = 0;i< this.children.length;i++) {
            count += this.children[i].getNodeCount();
        }
        return count + 1;
    },

      /**
		 * Returns an object which could be used to build a tree out of this
		 * node and its children. It can be passed to the tree constructor to
		 * reproduce this node as a tree. It will return false if the node or
		 * any children loads dynamically, regardless of whether it is loaded or
		 * not.
		 * 
		 * @method getNodeDefinition
		 * @return {Object | false} definition of the tree or false if the node
		 *         or any children is defined as dynamic
		 */
    getNodeDefinition: function() {

        if (this.isDynamic()) { return false; }

        var def, defs = Lang.merge(this.data), children = [];



        if (this.expanded) {defs.expanded = this.expanded; }
        if (!this.multiExpand) { defs.multiExpand = this.multiExpand; }
        if (this.renderHidden) { defs.renderHidden = this.renderHidden; }
        if (!this.hasIcon) { defs.hasIcon = this.hasIcon; }
        if (this.nowrap) { defs.nowrap = this.nowrap; }
        if (this.className) { defs.className = this.className; }
        if (this.editable) { defs.editable = this.editable; }
        if (!this.enableHighlight) { defs.enableHighlight = this.enableHighlight; }
        if (this.highlightState) { defs.highlightState = this.highlightState; }
        if (this.propagateHighlightUp) { defs.propagateHighlightUp = this.propagateHighlightUp; }
        if (this.propagateHighlightDown) { defs.propagateHighlightDown = this.propagateHighlightDown; }
        defs.type = this._type;



        for (var i = 0; i < this.children.length;i++) {
            def = this.children[i].getNodeDefinition();
            if (def === false) { return false;}
            children.push(def);
        }
        if (children.length) { defs.children = children; }
        return defs;
    },


    /**
	 * Generates the link that will invoke this node's toggle method
	 * 
	 * @method getToggleLink
	 * @return {string} the javascript url for toggling this node
	 */
    getToggleLink: function() {
        return 'return false;';
    },

    /**
	 * Sets the value of property for this node and all loaded descendants. Only
	 * public and defined properties can be set, not methods. Values for unknown
	 * properties will be assigned to the refNode.data object
	 * 
	 * @method setNodesProperty
	 * @param name
	 *            {string} Name of the property to be set
	 * @param value
	 *            {any} value to be set
	 * @param refresh
	 *            {boolean} if present and true, it does a refresh
	 */
    setNodesProperty: function(name, value, refresh) {
        if (name.charAt(0) != '_'  && !Lang.isUndefined(this[name]) && !Lang.isFunction(this[name]) ) {
            this[name] = value;
        } else {
            this.data[name] = value;
        }
        for (var i = 0; i < this.children.length;i++) {
            this.children[i].setNodesProperty(name,value);
        }
        if (refresh) {
            this.refresh();
        }
    },
    /**
	 * Toggles the highlighted state of a Node
	 * 
	 * @method toggleHighlight
	 */
    toggleHighlight: function() {
        if (this.enableHighlight) {
            // unhighlights only if fully highligthed. For not or partially
			// highlighted it will highlight
            if (this.highlightState == 1) {
                this.unhighlight();
            } else {
                this.highlight();
            }
        }
    },

    /**
	 * Turns highlighting on node.
	 * 
	 * @method highlight
	 * @param _silent
	 *            {boolean} optional, don't fire the highlightEvent
	 */
    highlight: function(_silent) {
        if (this.enableHighlight) {
            if (this.tree.singleNodeHighlight) {
                if (this.tree._currentlyHighlighted) {
                    this.tree._currentlyHighlighted.unhighlight(_silent);
                }
                this.tree._currentlyHighlighted = this;
            }
            this.highlightState = 1;
            this._setHighlightClassName();
            if (!this.tree.singleNodeHighlight) {
                if (this.propagateHighlightDown) {
                    for (var i = 0;i < this.children.length;i++) {
                        this.children[i].highlight(true);
                    }
                }
                if (this.propagateHighlightUp) {
                    if (this.parent) {
                        this.parent._childrenHighlighted();
                    }
                }
            }
            if (!_silent) {
                this.tree.fireEvent('highlightEvent',this);
            }
        }
    },
    /**
	 * Turns highlighting off a node.
	 * 
	 * @method unhighlight
	 * @param _silent
	 *            {boolean} optional, don't fire the highlightEvent
	 */
    unhighlight: function(_silent) {
        if (this.enableHighlight) {
            // might have checked singleNodeHighlight but it wouldn't really
			// matter either way
            this.tree._currentlyHighlighted = null;
            this.highlightState = 0;
            this._setHighlightClassName();
            if (!this.tree.singleNodeHighlight) {
                if (this.propagateHighlightDown) {
                    for (var i = 0;i < this.children.length;i++) {
                        this.children[i].unhighlight(true);
                    }
                }
                if (this.propagateHighlightUp) {
                    if (this.parent) {
                        this.parent._childrenHighlighted();
                    }
                }
            }
            if (!_silent) {
                this.tree.fireEvent('highlightEvent',this);
            }
        }
    },
    /**
	 * Checks whether all or part of the children of a node are highlighted and
	 * sets the node highlight to full, none or partial highlight. If set to
	 * propagate it will further call the parent
	 * 
	 * @method _childrenHighlighted
	 * @private
	 */
    _childrenHighlighted: function() {
        var yes = false, no = false;
        if (this.enableHighlight) {
            for (var i = 0;i < this.children.length;i++) {
                switch(this.children[i].highlightState) {
                    case 0:
                        no = true;
                        break;
                    case 1:
                        yes = true;
                        break;
                    case 2:
                        yes = no = true;
                        break;
                }
            }
            if (yes && no) {
                this.highlightState = 2;
            } else if (yes) {
                this.highlightState = 1;
            } else {
                this.highlightState = 0;
            }
            this._setHighlightClassName();
            if (this.propagateHighlightUp) {
                if (this.parent) {
                    this.parent._childrenHighlighted();
                }
            }
        }
    },

    /**
	 * Changes the classNames on the toggle and content containers to reflect
	 * the current highlighting
	 * 
	 * @method _setHighlightClassName
	 * @private
	 */
    _setHighlightClassName: function() {
        var el = Dom.get('ygtvtableel' + this.index);
        if (el) {
            el.className = el.className.replace(/\bygtv-highlight\d\b/gi,'ygtv-highlight' + this.highlightState);
        }
    }

};

YAHOO.augment(YAHOO.widget.Node, YAHOO.util.EventProvider);
})();
/**
 * A custom YAHOO.widget.Node that handles the unique nature of the virtual,
 * presentationless root node.
 * 
 * @namespace YAHOO.widget
 * @class RootNode
 * @extends YAHOO.widget.Node
 * @param oTree
 *            {YAHOO.widget.TreeView} The tree instance this node belongs to
 * @constructor
 */
YAHOO.widget.RootNode = function(oTree) {
    // Initialize the node with null params. The root node is a
    // special case where the node has no presentation. So we have
    // to alter the standard properties a bit.
    this.init(null, null, true);

    /*
	 * For the root node, we get the tree reference from as a param to the
	 * constructor instead of from the parent element.
	 */
    this.tree = oTree;
};

YAHOO.extend(YAHOO.widget.RootNode, YAHOO.widget.Node, {

   /**
	 * The node type
	 * 
	 * @property _type
	 * @type string
	 * @private
	 * @default "RootNode"
	 */
    _type: "RootNode",

    // overrides YAHOO.widget.Node
    getNodeHtml: function() {
        return "";
    },

    toString: function() {
        return this._type;
    },

    loadComplete: function() {
        this.tree.draw();
    },

   /**
	 * Count of nodes in tree. It overrides Nodes.getNodeCount because the root
	 * node should not be counted.
	 * 
	 * @method getNodeCount
	 * @return {int} number of nodes in the tree
	 */
    getNodeCount: function() {
        for (var i = 0, count = 0;i< this.children.length;i++) {
            count += this.children[i].getNodeCount();
        }
        return count;
    },

  /**
	 * Returns an object which could be used to build a tree out of this node
	 * and its children. It can be passed to the tree constructor to reproduce
	 * this node as a tree. Since the RootNode is automatically created by
	 * treeView, its own definition is excluded from the returned node
	 * definition which only contains its children.
	 * 
	 * @method getNodeDefinition
	 * @return {Object | false} definition of the tree or false if any child
	 *         node is defined as dynamic
	 */
    getNodeDefinition: function() {

        for (var def, defs = [], i = 0; i < this.children.length;i++) {
            def = this.children[i].getNodeDefinition();
            if (def === false) { return false;}
            defs.push(def);
        }
        return defs;
    },

    collapse: function() {},
    expand: function() {},
    getSiblings: function() { return null; },
    focus: function () {}

});
(function () {
    var Dom = YAHOO.util.Dom,
        Lang = YAHOO.lang,
        Event = YAHOO.util.Event;
/**
 * The default node presentation. The first parameter should be either a string
 * that will be used as the node's label, or an object that has at least a
 * string property called label. By default, clicking the label will toggle the
 * expanded/collapsed state of the node. By setting the href property of the
 * instance, this behavior can be changed so that the label will go to the
 * specified href.
 * 
 * @namespace YAHOO.widget
 * @class TextNode
 * @extends YAHOO.widget.Node
 * @constructor
 * @param oData
 *            {object} a string or object containing the data that will be used
 *            to render this node. Providing a string is the same as providing
 *            an object with a single property named label. All values in the
 *            oData will be used to set equally named properties in the node as
 *            long as the node does have such properties, they are not
 *            undefined, private or functions. All attributes are made available
 *            in noderef.data, which can be used to store custom attributes.
 *            TreeView.getNode(s)ByProperty can be used to retrieve a node by
 *            one of the attributes.
 * @param oParent
 *            {YAHOO.widget.Node} this node's parent node
 * @param expanded
 *            {boolean} the initial expanded/collapsed state (deprecated; use
 *            oData.expanded)
 */
YAHOO.widget.TextNode = function(oData, oParent, expanded) {

    if (oData) {
        if (Lang.isString(oData)) {
            oData = { label: oData };
        }
        this.init(oData, oParent, expanded);
        this.setUpLabel(oData);
    }

};

YAHOO.extend(YAHOO.widget.TextNode, YAHOO.widget.Node, {

    /**
	 * The CSS class for the label href. Defaults to ygtvlabel, but can be
	 * overridden to provide a custom presentation for a specific node.
	 * 
	 * @property labelStyle
	 * @type string
	 */
    labelStyle: "ygtvlabel",

    /**
	 * The derived element id of the label for this node
	 * 
	 * @property labelElId
	 * @type string
	 */
    labelElId: null,

    /**
	 * The text for the label. It is assumed that the oData parameter will
	 * either be a string that will be used as the label, or an object that has
	 * a property called "label" that we will use.
	 * 
	 * @property label
	 * @type string
	 */
    label: null,

    /**
	 * The text for the title (tooltip) for the label element
	 * 
	 * @property title
	 * @type string
	 */
    title: null,

    /**
	 * The href for the node's label. If one is not specified, the href will be
	 * set so that it toggles the node.
	 * 
	 * @property href
	 * @type string
	 */
    href: null,

    /**
	 * The label href target, defaults to current window
	 * 
	 * @property target
	 * @type string
	 */
    target: "_self",

    /**
	 * The node type
	 * 
	 * @property _type
	 * @private
	 * @type string
	 * @default "TextNode"
	 */
    _type: "TextNode",


    /**
	 * Sets up the node label
	 * 
	 * @method setUpLabel
	 * @param oData
	 *            string containing the label, or an object with a label
	 *            property
	 */
    setUpLabel: function(oData) {

        if (Lang.isString(oData)) {
            oData = {
                label: oData
            };
        } else {
            if (oData.style) {
                this.labelStyle = oData.style;
            }
        }

        this.label = oData.label;

        this.labelElId = "ygtvlabelel" + this.index;

    },

    /**
	 * Returns the label element
	 * 
	 * @for YAHOO.widget.TextNode
	 * @method getLabelEl
	 * @return {object} the element
	 */
    getLabelEl: function() {
        return Dom.get(this.labelElId);
    },

    // overrides YAHOO.widget.Node
    getContentHtml: function() {
        var sb = [];
        sb[sb.length] = this.href ? '<a' : '<span';
        sb[sb.length] = ' id="' + Lang.escapeHTML(this.labelElId) + '"';
        sb[sb.length] = ' class="' + Lang.escapeHTML(this.labelStyle)  + '"';
        if (this.href) {
            sb[sb.length] = ' href="' + Lang.escapeHTML(this.href) + '"';
            sb[sb.length] = ' target="' + Lang.escapeHTML(this.target) + '"';
        }
        if (this.title) {
            sb[sb.length] = ' title="' + Lang.escapeHTML(this.title) + '"';
        }
        sb[sb.length] = ' >';
        sb[sb.length] = Lang.escapeHTML(this.label);
        sb[sb.length] = this.href?'</a>':'</span>';
        return sb.join("");
    },



  /**
	 * Returns an object which could be used to build a tree out of this node
	 * and its children. It can be passed to the tree constructor to reproduce
	 * this node as a tree. It will return false if the node or any descendant
	 * loads dynamically, regardless of whether it is loaded or not.
	 * 
	 * @method getNodeDefinition
	 * @return {Object | false} definition of the tree or false if this node or
	 *         any descendant is defined as dynamic
	 */
    getNodeDefinition: function() {
        var def = YAHOO.widget.TextNode.superclass.getNodeDefinition.call(this);
        if (def === false) { return false; }

        // Node specific properties
        def.label = this.label;
        if (this.labelStyle != 'ygtvlabel') { def.style = this.labelStyle; }
        if (this.title) { def.title = this.title; }
        if (this.href) { def.href = this.href; }
        if (this.target != '_self') { def.target = this.target; }

        return def;

    },

    toString: function() {
        return YAHOO.widget.TextNode.superclass.toString.call(this) + ": " + this.label;
    },

    // deprecated
    onLabelClick: function() {
        return false;
    },
    refresh: function() {
        YAHOO.widget.TextNode.superclass.refresh.call(this);
        var label = this.getLabelEl();
        label.innerHTML = this.label;
        if (label.tagName.toUpperCase() == 'A') {
            label.href = this.href;
            label.target = this.target;
        }
    }




});
})();
/**
 * A menu-specific implementation that differs from TextNode in that only one
 * sibling can be expanded at a time.
 * 
 * @namespace YAHOO.widget
 * @class MenuNode
 * @extends YAHOO.widget.TextNode
 * @param oData
 *            {object} a string or object containing the data that will be used
 *            to render this node. Providing a string is the same as providing
 *            an object with a single property named label. All values in the
 *            oData will be used to set equally named properties in the node as
 *            long as the node does have such properties, they are not
 *            undefined, private or functions. All attributes are made available
 *            in noderef.data, which can be used to store custom attributes.
 *            TreeView.getNode(s)ByProperty can be used to retrieve a node by
 *            one of the attributes.
 * @param oParent
 *            {YAHOO.widget.Node} this node's parent node
 * @param expanded
 *            {boolean} the initial expanded/collapsed state (deprecated; use
 *            oData.expanded)
 * @constructor
 */
YAHOO.widget.MenuNode = function(oData, oParent, expanded) {
    YAHOO.widget.MenuNode.superclass.constructor.call(this,oData,oParent,expanded);

   /*
	 * Menus usually allow only one branch to be open at a time.
	 */
    this.multiExpand = false;

};

YAHOO.extend(YAHOO.widget.MenuNode, YAHOO.widget.TextNode, {

    /**
	 * The node type
	 * 
	 * @property _type
	 * @private
	 * @default "MenuNode"
	 */
    _type: "MenuNode"

});
(function () {
    var Dom = YAHOO.util.Dom,
        Lang = YAHOO.lang,
        Event = YAHOO.util.Event;

/**
 * This implementation takes either a string or object for the oData argument.
 * If is it a string, it will use it for the display of this node (and it can
 * contain any html code). If the parameter is an object,it looks for a
 * parameter called "html" that will be used for this node's display.
 * 
 * @namespace YAHOO.widget
 * @class HTMLNode
 * @extends YAHOO.widget.Node
 * @constructor
 * @param oData
 *            {object} a string or object containing the data that will be used
 *            to render this node. Providing a string is the same as providing
 *            an object with a single property named html. All values in the
 *            oData will be used to set equally named properties in the node as
 *            long as the node does have such properties, they are not
 *            undefined, private or functions. All other attributes are made
 *            available in noderef.data, which can be used to store custom
 *            attributes. TreeView.getNode(s)ByProperty can be used to retrieve
 *            a node by one of the attributes.
 * @param oParent
 *            {YAHOO.widget.Node} this node's parent node
 * @param expanded
 *            {boolean} the initial expanded/collapsed state (deprecated; use
 *            oData.expanded)
 * @param hasIcon
 *            {boolean} specifies whether or not leaf nodes should be rendered
 *            with or without a horizontal line and/or toggle icon. If the icon
 *            is not displayed, the content fills the space it would have
 *            occupied. This option operates independently of the leaf node
 *            presentation logic for dynamic nodes. (deprecated; use
 *            oData.hasIcon)
 */
var HN =  function(oData, oParent, expanded, hasIcon) {
    if (oData) {
        this.init(oData, oParent, expanded);
        this.initContent(oData, hasIcon);
    }
};


YAHOO.widget.HTMLNode = HN;
YAHOO.extend(HN, YAHOO.widget.Node, {

    /**
	 * The CSS class for the html content container. Defaults to ygtvhtml, but
	 * can be overridden to provide a custom presentation for a specific node.
	 * 
	 * @property contentStyle
	 * @type string
	 */
    contentStyle: "ygtvhtml",


    /**
	 * The HTML content to use for this node's display
	 * 
	 * @property html
	 * @type string
	 */
    html: null,

/**
 * The node type
 * 
 * @property _type
 * @private
 * @type string
 * @default "HTMLNode"
 */
    _type: "HTMLNode",

    /**
	 * Sets up the node label
	 * 
	 * @method initContent
	 * @param oData
	 *            {object} An html string or object containing an html property
	 * @param hasIcon
	 *            {boolean} determines if the node will be rendered with an icon
	 *            or not
	 */
    initContent: function(oData, hasIcon) {
        this.setHtml(oData);
        this.contentElId = "ygtvcontentel" + this.index;
        if (!Lang.isUndefined(hasIcon)) { this.hasIcon  = hasIcon; }

    },

    /**
	 * Synchronizes the node.html, and the node's content
	 * 
	 * @method setHtml
	 * @param o
	 *            {object |string | HTMLElement } An html string, an object
	 *            containing an html property or an HTML element
	 */
    setHtml: function(o) {
        this.html = (Lang.isObject(o) && 'html' in o) ? o.html : o;

        var el = this.getContentEl();
        if (el) {
            if (o.nodeType && o.nodeType == 1 && o.tagName) {
                el.innerHTML = "";
            } else {
                el.innerHTML = this.html;
            }
        }

    },

    // overrides YAHOO.widget.Node
    // If property html is a string, it sets the innerHTML for the node
    // If it is an HTMLElement, it defers appending it to the tree until the
	// HTML basic structure is built
    getContentHtml: function() {
        if (typeof this.html === "string") {
            return this.html;
        } else {

            HN._deferredNodes.push(this);
            if (!HN._timer) {
                HN._timer = window.setTimeout(function () {
                    var n;
                    while((n = HN._deferredNodes.pop())) {
                        n.getContentEl().appendChild(n.html);
                    }
                    HN._timer = null;
                },0);
            }
            return "";
        }
    },

      /**
		 * Returns an object which could be used to build a tree out of this
		 * node and its children. It can be passed to the tree constructor to
		 * reproduce this node as a tree. It will return false if any node loads
		 * dynamically, regardless of whether it is loaded or not.
		 * 
		 * @method getNodeDefinition
		 * @return {Object | false} definition of the tree or false if any node
		 *         is defined as dynamic
		 */
    getNodeDefinition: function() {
        var def = HN.superclass.getNodeDefinition.call(this);
        if (def === false) { return false; }
        def.html = this.html;
        return def;

    }
});

    /**
	 * An array of HTMLNodes created with HTML Elements that had their rendering
	 * deferred until the basic tree structure is rendered.
	 * 
	 * @property _deferredNodes
	 * @type YAHOO.widget.HTMLNode[]
	 * @default []
	 * @private
	 * @static
	 */
HN._deferredNodes = [];
    /**
	 * A system timer value used to mark whether a deferred operation is
	 * pending.
	 * 
	 * @property _timer
	 * @type System Timer
	 * @default null
	 * @private
	 * @static
	 */
HN._timer = null;
})();
(function () {
    var Dom = YAHOO.util.Dom,
        Lang = YAHOO.lang,
        Event = YAHOO.util.Event,
        Calendar = YAHOO.widget.Calendar;

/**
 * A Date-specific implementation that differs from TextNode in that it uses
 * YAHOO.widget.Calendar as an in-line editor, if available If Calendar is not
 * available, it behaves as a plain TextNode.
 * 
 * @namespace YAHOO.widget
 * @class DateNode
 * @extends YAHOO.widget.TextNode
 * @param oData
 *            {object} a string or object containing the data that will be used
 *            to render this node. Providing a string is the same as providing
 *            an object with a single property named label. All values in the
 *            oData will be used to set equally named properties in the node as
 *            long as the node does have such properties, they are not
 *            undefined, private nor functions. All attributes are made
 *            available in noderef.data, which can be used to store custom
 *            attributes. TreeView.getNode(s)ByProperty can be used to retrieve
 *            a node by one of the attributes.
 * @param oParent
 *            {YAHOO.widget.Node} this node's parent node
 * @param expanded
 *            {boolean} the initial expanded/collapsed state (deprecated; use
 *            oData.expanded)
 * @constructor
 */
YAHOO.widget.DateNode = function(oData, oParent, expanded) {
    YAHOO.widget.DateNode.superclass.constructor.call(this,oData, oParent, expanded);
};

YAHOO.extend(YAHOO.widget.DateNode, YAHOO.widget.TextNode, {

    /**
	 * The node type
	 * 
	 * @property _type
	 * @type string
	 * @private
	 * @default "DateNode"
	 */
    _type: "DateNode",

    /**
	 * Configuration object for the Calendar editor, if used. See <a
	 * href="http://developer.yahoo.com/yui/calendar/#internationalization">http://developer.yahoo.com/yui/calendar/#internationalization</a>
	 * 
	 * @property calendarConfig
	 */
    calendarConfig: null,



    /**
	 * If YAHOO.widget.Calendar is available, it will pop up a Calendar to enter
	 * a new date. Otherwise, it falls back to a plain &lt;input&gt; textbox
	 * 
	 * @method fillEditorContainer
	 * @param editorData
	 *            {YAHOO.widget.TreeView.editorData} a shortcut to the static
	 *            object holding editing information
	 * @return void
	 */
    fillEditorContainer: function (editorData) {

        var cal, container = editorData.inputContainer;

        if (Lang.isUndefined(Calendar)) {
            Dom.replaceClass(editorData.editorPanel,'ygtv-edit-DateNode','ygtv-edit-TextNode');
            YAHOO.widget.DateNode.superclass.fillEditorContainer.call(this, editorData);
            return;
        }

        if (editorData.nodeType != this._type) {
            editorData.nodeType = this._type;
            editorData.saveOnEnter = false;

            editorData.node.destroyEditorContents(editorData);

            editorData.inputObject = cal = new Calendar(container.appendChild(document.createElement('div')));
            if (this.calendarConfig) {
                cal.cfg.applyConfig(this.calendarConfig,true);
                cal.cfg.fireQueue();
            }
            cal.selectEvent.subscribe(function () {
                this.tree._closeEditor(true);
            },this,true);
        } else {
            cal = editorData.inputObject;
        }

        editorData.oldValue = this.label;
        cal.cfg.setProperty("selected",this.label, false);

        var delim = cal.cfg.getProperty('DATE_FIELD_DELIMITER');
        var pageDate = this.label.split(delim);
        cal.cfg.setProperty('pagedate',pageDate[cal.cfg.getProperty('MDY_MONTH_POSITION') -1] + delim + pageDate[cal.cfg.getProperty('MDY_YEAR_POSITION') -1]);
        cal.cfg.fireQueue();

        cal.render();
        cal.oDomContainer.focus();
    },
     /**
		 * Returns the value from the input element. Overrides
		 * Node.getEditorValue.
		 * 
		 * @method getEditorValue
		 * @param editorData
		 *            {YAHOO.widget.TreeView.editorData} a shortcut to the
		 *            static object holding editing information
		 * @return {string} date entered
		 */

    getEditorValue: function (editorData) {
        if (Lang.isUndefined(Calendar)) {
            return editorData.inputElement.value;
        } else {
            var cal = editorData.inputObject,
                date = cal.getSelectedDates()[0],
                dd = [];

            dd[cal.cfg.getProperty('MDY_DAY_POSITION') -1] = date.getDate();
            dd[cal.cfg.getProperty('MDY_MONTH_POSITION') -1] = date.getMonth() + 1;
            dd[cal.cfg.getProperty('MDY_YEAR_POSITION') -1] = date.getFullYear();
            return dd.join(cal.cfg.getProperty('DATE_FIELD_DELIMITER'));
        }
    },

    /**
	 * Finally displays the newly entered date in the tree. Overrides
	 * Node.displayEditedValue.
	 * 
	 * @method displayEditedValue
	 * @param value
	 *            {HTML} date to be displayed and stored in the node. This data
	 *            is added to the node unescaped via the innerHTML property.
	 * @param editorData
	 *            {YAHOO.widget.TreeView.editorData} a shortcut to the static
	 *            object holding editing information
	 */
    displayEditedValue: function (value,editorData) {
        var node = editorData.node;
        node.label = value;
        node.getLabelEl().innerHTML = value;
    },

   /**
	 * Returns an object which could be used to build a tree out of this node
	 * and its children. It can be passed to the tree constructor to reproduce
	 * this node as a tree. It will return false if the node or any descendant
	 * loads dynamically, regardless of whether it is loaded or not.
	 * 
	 * @method getNodeDefinition
	 * @return {Object | false} definition of the node or false if this node or
	 *         any descendant is defined as dynamic
	 */
    getNodeDefinition: function() {
        var def = YAHOO.widget.DateNode.superclass.getNodeDefinition.call(this);
        if (def === false) { return false; }
        if (this.calendarConfig) { def.calendarConfig = this.calendarConfig; }
        return def;
    }


});
})();
(function () {
    var Dom = YAHOO.util.Dom,
        Lang = YAHOO.lang,
        Event = YAHOO.util.Event,
        TV = YAHOO.widget.TreeView,
        TVproto = TV.prototype;

    /**
	 * An object to store information used for in-line editing for all Nodes of
	 * all TreeViews. It contains:
	 * <ul>
	 * <li>active {boolean}, whether there is an active cell editor </li>
	 * <li>whoHasIt {YAHOO.widget.TreeView} TreeView instance that is currently
	 * using the editor</li>
	 * <li>nodeType {string} value of static Node._type property, allows reuse
	 * of input element if node is of the same type.</li>
	 * <li>editorPanel {HTMLelement (&lt;div&gt;)} element holding the in-line
	 * editor</li>
	 * <li>inputContainer {HTMLelement (&lt;div&gt;)} element which will hold
	 * the type-specific input element(s) to be filled by the
	 * fillEditorContainer method</li>
	 * <li>buttonsContainer {HTMLelement (&lt;div&gt;)} element which holds the
	 * &lt;button&gt; elements for Ok/Cancel. If you don't want any of the
	 * buttons, hide it via CSS styles, don't destroy it</li>
	 * <li>node {YAHOO.widget.Node} reference to the Node being edited</li>
	 * <li>saveOnEnter {boolean}, whether the Enter key should be accepted as a
	 * Save command (Esc. is always taken as Cancel), disable for multi-line
	 * input elements </li>
	 * <li>oldValue {any} value before editing</li>
	 * </ul>
	 * Editors are free to use this object to store additional data.
	 * 
	 * @property editorData
	 * @static
	 * @for YAHOO.widget.TreeView
	 */
    TV.editorData = {
        active:false,
        whoHasIt:null, // which TreeView has it
        nodeType:null,
        editorPanel:null,
        inputContainer:null,
        buttonsContainer:null,
        node:null, // which Node is being edited
        saveOnEnter:true,
        oldValue:undefined
        // Each node type is free to add its own properties to this as it sees
		// fit.
    };

    /**
	 * Validator function for edited data, called from the TreeView instance
	 * scope, receives the arguments (newValue, oldValue, nodeInstance) and
	 * returns either the validated (or type-converted) value or undefined. An
	 * undefined return will prevent the editor from closing
	 * 
	 * @property validator
	 * @type function
	 * @default null
	 * @for YAHOO.widget.TreeView
	 */
    TVproto.validator = null;

    /**
	 * Entry point for initializing the editing plug-in. TreeView will call this
	 * method on initializing if it exists
	 * 
	 * @method _initEditor
	 * @for YAHOO.widget.TreeView
	 * @private
	 */

    TVproto._initEditor = function () {
        /**
		 * Fires when the user clicks on the ok button of a node editor
		 * 
		 * @event editorSaveEvent
		 * @type CustomEvent
		 * @param oArgs.newValue
		 *            {mixed} the new value just entered
		 * @param oArgs.oldValue
		 *            {mixed} the value originally in the tree
		 * @param oArgs.node
		 *            {YAHOO.widget.Node} the node that has the focus
		 * @for YAHOO.widget.TreeView
		 */
        this.createEvent("editorSaveEvent", this);

        /**
		 * Fires when the user clicks on the cancel button of a node editor
		 * 
		 * @event editorCancelEvent
		 * @type CustomEvent
		 * @param {YAHOO.widget.Node}
		 *            node the node that has the focus
		 * @for YAHOO.widget.TreeView
		 */
        this.createEvent("editorCancelEvent", this);

    };

    /**
	 * Entry point of the editing plug-in. TreeView will call this method if it
	 * exists when a node label is clicked
	 * 
	 * @method _nodeEditing
	 * @param node
	 *            {YAHOO.widget.Node} the node to be edited
	 * @return {Boolean} true to indicate that the node is editable and prevent
	 *         any further bubbling of the click.
	 * @for YAHOO.widget.TreeView
	 * @private
	 */



    TVproto._nodeEditing = function (node) {
        if (node.fillEditorContainer && node.editable) {
            var ed, topLeft, buttons, button, editorData = TV.editorData;
            editorData.active = true;
            editorData.whoHasIt = this;
            if (!editorData.nodeType) {
                // Fixes: http://yuilibrary.com/projects/yui2/ticket/2528945
                editorData.editorPanel = ed = this.getEl().appendChild(document.createElement('div'));
                Dom.addClass(ed,'ygtv-label-editor');
                ed.tabIndex = 0;

                buttons = editorData.buttonsContainer = ed.appendChild(document.createElement('div'));
                Dom.addClass(buttons,'ygtv-button-container');
                button = buttons.appendChild(document.createElement('button'));
                Dom.addClass(button,'ygtvok');
                button.innerHTML = ' ';
                button = buttons.appendChild(document.createElement('button'));
                Dom.addClass(button,'ygtvcancel');
                button.innerHTML = ' ';
                Event.on(buttons, 'click', function (ev) {
                    var target = Event.getTarget(ev),
                        editorData = TV.editorData,
                        node = editorData.node,
                        self = editorData.whoHasIt;
                    if (Dom.hasClass(target,'ygtvok')) {
                        Event.stopEvent(ev);
                        self._closeEditor(true);
                    }
                    if (Dom.hasClass(target,'ygtvcancel')) {
                        Event.stopEvent(ev);
                        self._closeEditor(false);
                    }
                });

                editorData.inputContainer = ed.appendChild(document.createElement('div'));
                Dom.addClass(editorData.inputContainer,'ygtv-input');

                Event.on(ed,'keydown',function (ev) {
                    var editorData = TV.editorData,
                        KEY = YAHOO.util.KeyListener.KEY,
                        self = editorData.whoHasIt;
                    switch (ev.keyCode) {
                        case KEY.ENTER:
                            Event.stopEvent(ev);
                            if (editorData.saveOnEnter) {
                                self._closeEditor(true);
                            }
                            break;
                        case KEY.ESCAPE:
                            Event.stopEvent(ev);
                            self._closeEditor(false);
                            break;
                    }
                });



            } else {
                ed = editorData.editorPanel;
            }
            editorData.node = node;
            if (editorData.nodeType) {
                Dom.removeClass(ed,'ygtv-edit-' + editorData.nodeType);
            }
            Dom.addClass(ed,' ygtv-edit-' + node._type);
            // Fixes: http://yuilibrary.com/projects/yui2/ticket/2528945
            Dom.setStyle(ed,'display','block');
            Dom.setXY(ed,Dom.getXY(node.getContentEl()));
            // up to here
            ed.focus();
            node.fillEditorContainer(editorData);

            return true;  // If inline editor available, don't do anything
							// else.
        }
    };

    /**
	 * Method to be associated with an event (clickEvent, dblClickEvent or
	 * enterKeyPressed) to pop up the contents editor It calls the corresponding
	 * node editNode method.
	 * 
	 * @method onEventEditNode
	 * @param oArgs
	 *            {object} Object passed as arguments to TreeView event
	 *            listeners
	 * @for YAHOO.widget.TreeView
	 */

    TVproto.onEventEditNode = function (oArgs) {
        if (oArgs instanceof YAHOO.widget.Node) {
            oArgs.editNode();
        } else if (oArgs.node instanceof YAHOO.widget.Node) {
            oArgs.node.editNode();
        }
        return false;
    };

    /**
	 * Method to be called when the inline editing is finished and the editor is
	 * to be closed
	 * 
	 * @method _closeEditor
	 * @param save
	 *            {Boolean} true if the edited value is to be saved, false if
	 *            discarded
	 * @private
	 * @for YAHOO.widget.TreeView
	 */

    TVproto._closeEditor = function (save) {
        var ed = TV.editorData,
            node = ed.node,
            close = true;
        // http://yuilibrary.com/projects/yui2/ticket/2528946
        // _closeEditor might now be called at any time, even when there is no
		// label editor open
        // so we need to ensure there is one.
        if (!node || !ed.active) { return; }
        if (save) {
            close = ed.node.saveEditorValue(ed) !== false;
        } else {
            this.fireEvent( 'editorCancelEvent', node);
        }

        if (close) {
            Dom.setStyle(ed.editorPanel,'display','none');
            ed.active = false;
            node.focus();
        }
    };

    /**
	 * Entry point for TreeView's destroy method to destroy whatever the editing
	 * plug-in has created
	 * 
	 * @method _destroyEditor
	 * @private
	 * @for YAHOO.widget.TreeView
	 */
    TVproto._destroyEditor = function() {
        var ed = TV.editorData;
        if (ed && ed.nodeType && (!ed.active || ed.whoHasIt === this)) {
            Event.removeListener(ed.editorPanel,'keydown');
            Event.removeListener(ed.buttonContainer,'click');
            ed.node.destroyEditorContents(ed);
            document.body.removeChild(ed.editorPanel);
            ed.nodeType = ed.editorPanel = ed.inputContainer = ed.buttonsContainer = ed.whoHasIt = ed.node = null;
            ed.active = false;
        }
    };

    var Nproto = YAHOO.widget.Node.prototype;

    /**
	 * Signals if the label is editable. (Ignored on TextNodes with href set.)
	 * 
	 * @property editable
	 * @type boolean
	 * @for YAHOO.widget.Node
	 */
    Nproto.editable = false;

    /**
	 * pops up the contents editor, if there is one and the node is declared
	 * editable
	 * 
	 * @method editNode
	 * @for YAHOO.widget.Node
	 */

    Nproto.editNode = function () {
        this.tree._nodeEditing(this);
    };


    /**
	 * Placeholder for a function that should provide the inline node label
	 * editor. Leaving it set to null will indicate that this node type is not
	 * editable. It should be overridden by nodes that provide inline editing.
	 * The Node-specific editing element (input box, textarea or whatever)
	 * should be inserted into editorData.inputContainer.
	 * 
	 * @method fillEditorContainer
	 * @param editorData
	 *            {YAHOO.widget.TreeView.editorData} a shortcut to the static
	 *            object holding editing information
	 * @return void
	 * @for YAHOO.widget.Node
	 */
    Nproto.fillEditorContainer = null;


    /**
	 * Node-specific destroy function to empty the contents of the inline editor
	 * panel. This function is the worst case alternative that will purge all
	 * possible events and remove the editor contents. Method Event.purgeElement
	 * is somewhat costly so if it can be replaced by specifc
	 * Event.removeListeners, it is better to do so.
	 * 
	 * @method destroyEditorContents
	 * @param editorData
	 *            {YAHOO.widget.TreeView.editorData} a shortcut to the static
	 *            object holding editing information
	 * @for YAHOO.widget.Node
	 */
    Nproto.destroyEditorContents = function (editorData) {
        // In the worst case, if the input editor (such as the Calendar) has no
		// destroy method
        // we can only try to remove all possible events on it.
        Event.purgeElement(editorData.inputContainer,true);
        editorData.inputContainer.innerHTML = '';
    };

    /**
	 * Saves the value entered into the editor.
	 * 
	 * @method saveEditorValue
	 * @param editorData
	 *            {YAHOO.widget.TreeView.editorData} a shortcut to the static
	 *            object holding editing information
	 * @return {false or none} a return of exactly false will prevent the editor
	 *         from closing
	 * @for YAHOO.widget.Node
	 */
    Nproto.saveEditorValue = function (editorData) {
        var node = editorData.node,
            value,
            validator = node.tree.validator;

        value = this.getEditorValue(editorData);

        if (Lang.isFunction(validator)) {
            value = validator(value,editorData.oldValue,node);
            if (Lang.isUndefined(value)) {
                return false;
            }
        }

        if (this.tree.fireEvent( 'editorSaveEvent', {
            newValue:value,
            oldValue:editorData.oldValue,
            node:node
        }) !== false) {
            this.displayEditedValue(value,editorData);
        }
    };


    /**
	 * Returns the value(s) from the input element(s) . Should be overridden by
	 * each node type.
	 * 
	 * @method getEditorValue
	 * @param editorData
	 *            {YAHOO.widget.TreeView.editorData} a shortcut to the static
	 *            object holding editing information
	 * @return {any} value entered
	 * @for YAHOO.widget.Node
	 */

     Nproto.getEditorValue = function (editorData) {
    };

    /**
	 * Finally displays the newly edited value(s) in the tree. Should be
	 * overridden by each node type.
	 * 
	 * @method displayEditedValue
	 * @param value
	 *            {HTML} value to be displayed and stored in the node This data
	 *            is added to the node unescaped via the innerHTML property.
	 * @param editorData
	 *            {YAHOO.widget.TreeView.editorData} a shortcut to the static
	 *            object holding editing information
	 * @for YAHOO.widget.Node
	 */
    Nproto.displayEditedValue = function (value,editorData) {
    };

    var TNproto = YAHOO.widget.TextNode.prototype;



    /**
	 * Places an &lt;input&gt; textbox in the input container and loads the
	 * label text into it.
	 * 
	 * @method fillEditorContainer
	 * @param editorData
	 *            {YAHOO.widget.TreeView.editorData} a shortcut to the static
	 *            object holding editing information
	 * @return void
	 * @for YAHOO.widget.TextNode
	 */
    TNproto.fillEditorContainer = function (editorData) {

        var input;
        // If last node edited is not of the same type as this one, delete it
		// and fill it with our editor
        if (editorData.nodeType != this._type) {
            editorData.nodeType = this._type;
            editorData.saveOnEnter = true;
            editorData.node.destroyEditorContents(editorData);

            editorData.inputElement = input = editorData.inputContainer.appendChild(document.createElement('input'));

        } else {
            // if the last node edited was of the same time, reuse the input
			// element.
            input = editorData.inputElement;
        }
        editorData.oldValue = this.label;
        input.value = this.label;
        input.focus();
        input.select();
    };

    /**
	 * Returns the value from the input element. Overrides Node.getEditorValue.
	 * 
	 * @method getEditorValue
	 * @param editorData
	 *            {YAHOO.widget.TreeView.editorData} a shortcut to the static
	 *            object holding editing information
	 * @return {string} value entered
	 * @for YAHOO.widget.TextNode
	 */

    TNproto.getEditorValue = function (editorData) {
        return editorData.inputElement.value;
    };

    /**
	 * Finally displays the newly edited value in the tree. Overrides
	 * Node.displayEditedValue.
	 * 
	 * @method displayEditedValue
	 * @param value
	 *            {string} value to be displayed and stored in the node
	 * @param editorData
	 *            {YAHOO.widget.TreeView.editorData} a shortcut to the static
	 *            object holding editing information
	 * @for YAHOO.widget.TextNode
	 */
    TNproto.displayEditedValue = function (value,editorData) {
        var node = editorData.node;
        node.label = value;
        node.getLabelEl().innerHTML = value;
    };

    /**
	 * Destroys the contents of the inline editor panel. Overrides
	 * Node.destroyEditorContent. Since we didn't set any event listeners on
	 * this inline editor, it is more efficient to avoid the generic method in
	 * Node.
	 * 
	 * @method destroyEditorContents
	 * @param editorData
	 *            {YAHOO.widget.TreeView.editorData} a shortcut to the static
	 *            object holding editing information
	 * @for YAHOO.widget.TextNode
	 */
    TNproto.destroyEditorContents = function (editorData) {
        editorData.inputContainer.innerHTML = '';
    };
})();
/**
 * A static factory class for tree view expand/collapse animations
 * 
 * @class TVAnim
 * @static
 */
YAHOO.widget.TVAnim = function() {
    return {
        /**
		 * Constant for the fade in animation
		 * 
		 * @property FADE_IN
		 * @type string
		 * @static
		 */
        FADE_IN: "TVFadeIn",

        /**
		 * Constant for the fade out animation
		 * 
		 * @property FADE_OUT
		 * @type string
		 * @static
		 */
        FADE_OUT: "TVFadeOut",

        /**
		 * Returns a ygAnim instance of the given type
		 * 
		 * @method getAnim
		 * @param type
		 *            {string} the type of animation
		 * @param el
		 *            {HTMLElement} the element to element (probably the
		 *            children div)
		 * @param callback
		 *            {function} function to invoke when the animation is done.
		 * @return {YAHOO.util.Animation} the animation instance
		 * @static
		 */
        getAnim: function(type, el, callback) {
            if (YAHOO.widget[type]) {
                return new YAHOO.widget[type](el, callback);
            } else {
                return null;
            }
        },

        /**
		 * Returns true if the specified animation class is available
		 * 
		 * @method isValid
		 * @param type
		 *            {string} the type of animation
		 * @return {boolean} true if valid, false if not
		 * @static
		 */
        isValid: function(type) {
            return (YAHOO.widget[type]);
        }
    };
} ();
/**
 * A 1/2 second fade-in animation.
 * 
 * @class TVFadeIn
 * @constructor
 * @param el
 *            {HTMLElement} the element to animate
 * @param callback
 *            {function} function to invoke when the animation is finished
 */
YAHOO.widget.TVFadeIn = function(el, callback) {
    /**
	 * The element to animate
	 * 
	 * @property el
	 * @type HTMLElement
	 */
    this.el = el;

    /**
	 * the callback to invoke when the animation is complete
	 * 
	 * @property callback
	 * @type function
	 */
    this.callback = callback;

};

YAHOO.widget.TVFadeIn.prototype = {
    /**
	 * Performs the animation
	 * 
	 * @method animate
	 */
    animate: function() {
        var tvanim = this;

        var s = this.el.style;
        s.opacity = 0.1;
        s.filter = "alpha(opacity=10)";
        s.display = "";

        var dur = 0.4; 
        var a = new YAHOO.util.Anim(this.el, {opacity: {from: 0.1, to: 1, unit:""}}, dur);
        a.onComplete.subscribe( function() { tvanim.onComplete(); } );
        a.animate();
    },

    /**
	 * Clean up and invoke callback
	 * 
	 * @method onComplete
	 */
    onComplete: function() {
        this.callback();
    },

    /**
	 * toString
	 * 
	 * @method toString
	 * @return {string} the string representation of the instance
	 */
    toString: function() {
        return "TVFadeIn";
    }
};
/**
 * A 1/2 second fade out animation.
 * 
 * @class TVFadeOut
 * @constructor
 * @param el
 *            {HTMLElement} the element to animate
 * @param callback
 *            {Function} function to invoke when the animation is finished
 */
YAHOO.widget.TVFadeOut = function(el, callback) {
    /**
	 * The element to animate
	 * 
	 * @property el
	 * @type HTMLElement
	 */
    this.el = el;

    /**
	 * the callback to invoke when the animation is complete
	 * 
	 * @property callback
	 * @type function
	 */
    this.callback = callback;

};

YAHOO.widget.TVFadeOut.prototype = {
    /**
	 * Performs the animation
	 * 
	 * @method animate
	 */
    animate: function() {
        var tvanim = this;
        var dur = 0.4;
        var a = new YAHOO.util.Anim(this.el, {opacity: {from: 1, to: 0.1, unit:""}}, dur);
        a.onComplete.subscribe( function() { tvanim.onComplete(); } );
        a.animate();
    },

    /**
	 * Clean up and invoke callback
	 * 
	 * @method onComplete
	 */
    onComplete: function() {
        var s = this.el.style;
        s.display = "none";
        s.opacity = 1;
        s.filter = "alpha(opacity=100)";
        this.callback();
    },

    /**
	 * toString
	 * 
	 * @method toString
	 * @return {string} the string representation of the instance
	 */
    toString: function() {
        return "TVFadeOut";
    }
};
YAHOO.register("treeview", YAHOO.widget.TreeView, {version: "2.9.0", build: "2800"});
